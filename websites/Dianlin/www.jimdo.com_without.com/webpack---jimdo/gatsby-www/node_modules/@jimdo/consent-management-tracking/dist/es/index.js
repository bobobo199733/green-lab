import Cookie from 'js-cookie';
import { v4 } from 'uuid';
const Languages = ["de", "en", "nl", "fr", "es", "it", "ja"];
const SpecialGeoLocations = {
  "/jp": "ja",
  "/au": "en",
  "/nl": "nl",
  "/es": "es",
  "/fr": "fr",
  "/it": "it",
  "/de": "de"
}; // german pages aren't prefixed in Unbounce
// reason: Unbounce was started with DE language, making it the default language ("/")

const UnbounceGeoLocations = {
  "/jp/": "ja",
  "/nl/": "nl",
  "/es/": "es",
  "/fr/": "fr",
  "/it/": "it",
  "/en/": "en"
};
const fallBack = "en";
const unbounceFallBack = "de";

function computeLang() {
  try {
    if (typeof window === "undefined") {
      return fallBack;
    }

    const {
      hostname,
      pathname
    } = window.location;

    if (hostname.indexOf("www-") === 0 || hostname === "jimdo.com" || hostname === "www.jimdo.com" || hostname === "localhost") {
      const match = Object.keys(SpecialGeoLocations).find(pathPrefix => pathname.startsWith(pathPrefix));
      return match ? SpecialGeoLocations[match] : fallBack;
    } // Unbounce pages at go.jimdo.com:
    // German pages aren't prefixed in Unbounce, as the tool was started in german.
    // Therefore DE is the default language


    if (hostname === "go.jimdo.com") {
      const match = Object.keys(UnbounceGeoLocations).find(pathPrefix => pathname.startsWith(pathPrefix));
      return match ? UnbounceGeoLocations[match] : unbounceFallBack;
    }

    if (hostname === "help.jimdo-dolphin.com" || hostname === "help.jimdo.com" || hostname === "jimdo-partner.zendesk.com") {
      return Languages.find(lang => pathname.startsWith(`/hc/${lang}`)) || fallBack;
    }

    if (hostname === "logo.e.jimdo.com") {
      const i18nextLng = Cookie.get("i18nextLng") || fallBack;
      return Languages.find(lang => i18nextLng.startsWith(lang)) || fallBack;
    }

    if (hostname === "account.e.jimdo.com" || hostname === "account.e.jimdo-stable-staging.com") {
      return Languages.find(lang => pathname.startsWith(`/${lang}/`)) || fallBack;
    }

    const jLang = Cookie.get("jLang") || fallBack;
    return Languages.find(lang => jLang.startsWith(lang)) || fallBack;
  } catch (e) {
    //See: https://stackoverflow.com/questions/64452484/how-can-i-safely-access-caught-error-properties-in-typescript
    const {
      message
    } = e; // eslint-disable-next-line no-console

    console.log(`Consent Management: Couldn't determine language: ${message}`);
    return fallBack;
  }
}

const documentBodyLoader = script => {
  return document.body.appendChild(script);
};

const loadScript = function (creator) {
  let {
    loader = documentBodyLoader,
    configurators
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const script = creator();
  const configuredScript = configurators ? configurators.reduce((scriptElement, configurator) => configurator(scriptElement), script) : script;
  loader(configuredScript);
};

const createScriptWithSrc = src => {
  return () => {
    const script = document.createElement("script");
    script.src = src;
    return script;
  };
};

const configureAsyncScript = function () {
  let async = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return scriptElement => {
    scriptElement.async = async;
    return scriptElement;
  };
};

const documentHeadLoader = script => {
  return document.head.appendChild(script);
};

const getGtmDataLayer$1 = () => {
  if (window && window.dataLayer) {
    return window.dataLayer;
  }

  window.dataLayer = [];
  return window.dataLayer;
};

const loadGTM = function (containerId, language) {
  let {
    consentMode
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    consentMode: false
  };

  if (typeof window === "undefined" || !containerId) {
    return;
  }

  const gtmDataLayer = getGtmDataLayer$1();

  function gtag() {
    for (var _len = arguments.length, _ = new Array(_len), _key = 0; _key < _len; _key++) {
      _[_key] = arguments[_key];
    }

    gtmDataLayer.push(arguments);
  }

  if (consentMode) {
    gtag("consent", "default", {
      ad_storage: "denied",
      analytics_storage: "denied",
      wait_for_update: 2000
    });
    gtag("set", "ads_data_redaction", true);
  }

  gtmDataLayer.push({
    "gtm.start": new Date().getTime(),
    event: "gtm.js"
  }, {
    event: "Page Meta",
    "language subdomain": language
  });
  const dl = "";
  const src = `https://www.googletagmanager.com/gtm.js?id=${containerId}${dl}`;
  loadScript(createScriptWithSrc(src), {
    loader: documentHeadLoader,
    configurators: [configureAsyncScript()]
  });
}; // This function is meant to be used exclusively for generating session ids. Since we only need to disambiguate session
// within a single (cookie_id, website_id and user_id) AND this id is not used to access anything, we use Math.random(),
// which is not cryptographically strong, in place of Crypto.getRandomValues(). Optimizes for compatibility.


const generateRandomString = () => {
  return new Array(5).fill(0).map(() => Math.random().toString(36).slice(-1)).join('');
}; // A SID is composed of the current timestamp and a random string, this lets us sort session by start time, making sure
// we have two distinct identifiers in case 2 sessions are started at the same time. This solution was chosen over using
// uuid v4 or something like ulid, for 2 reasons: the ids are shorter, saving traffic and it allows the lib to remain
// dependecy-free.


const generateSid = () => {
  return Date.now().toString() + '-' + generateRandomString();
};

(() => {
  if (typeof window === 'undefined') {
    return;
  }

  window['_fs_ready'] = function () {};
})(); // A session ID. The purpose of this ID is to uniquely identify a session, within which the `seq` is supposed to be
// monotmonotonically increasing. The session id gets generated on library load, this should mean, there is one session
// id per: browser, tab, refresh


generateSid();
generateSid();
generateSid();
/**
 * Finds earliest parent with `data-${attribute}`
 * @param {Node} el
 * @param {Attribute} attribute
 *
 * @returns - HTMLElement or null (if not found)
 */

const earliestParentNodeWith$1 = (el, attribute) => {
  if (el instanceof HTMLElement && el.dataset && el.dataset[attribute]) {
    return el;
  } // looks for data attribute on parent recursivly


  if (el.parentNode) {
    return earliestParentNodeWith$1(el.parentNode, attribute);
  }

  return null;
};
/**
 * Tranforms a DOM event into a TrackingEvent interface
 * @param category - e.g. "lp.www"
 * @param eventType - e.g. "click"
 * @param element - HTMLElement, having the data-tracking attribute (e.g. a parental <button> element of a <span>)
 * @param attribute - e.g. "tracking", used to define the eventLabel
 * @param additionalProps - e.g. ['href', 'text']
 *
 * @returns - TrackingEvent
 */


const getTrackingEventForDomEvent = (category, eventType, element, attribute, additionalProps) => {
  const payload = {};
  let eventLabel = element.dataset[attribute] ?? '';
  (additionalProps || []).forEach(prop => {
    var _element$attributes$g;

    payload[prop] = (_element$attributes$g = element.attributes.getNamedItem(prop)) === null || _element$attributes$g === void 0 ? void 0 : _element$attributes$g.value;
  }); // TODO: check whether this should be "tracking-" instead of "track-"
  // ticket: https://jimplan.atlassian.net/browse/MATO-1516
  // https://github.com/Jimdo/www/blob/master/gatsby/js/cookiebanner/src/addAutomatedTracking.js#L23-L36

  Object.keys(element.dataset).filter(x => x.indexOf('track-') === 0).forEach(trackKey => {
    payload[trackKey.replace('track-', '')] = element.dataset[trackKey];
  });
  return {
    category: category,
    action: eventType,
    label: eventLabel,
    payload // gets populated from two sources:
    // 1. the values of keys from "additionalProps"
    // 2. values from "data-track-" attributes

  };
};
/**
 * Wraps a given track function.
 *
 * @remarks
 * Extracts data from DOM element then it tracks that data
 *
 * @param category - e.g. "lp.www"
 * @param eventType - e.g. "click"
 * @param attribute - e.g. "tracking"
 * @param additionalProps - e.g. ['href', 'text']
 * @param track - which tracking function should be used
 *
 * @returns - a closure that gets triggered on events eg: click, mouseenter
 */


const trackEventType$1 = (category, eventType, attribute, additionalProps, track) => event => {
  // TODO: remove variable shadowing (2 variables named event)
  const {
    target
  } = event;

  if (target instanceof Node) {
    const element = earliestParentNodeWith$1(target, attribute);

    if (element instanceof HTMLElement) {
      const event = getTrackingEventForDomEvent(category, eventType, element, attribute, additionalProps);
      track(event);
    }
  }
};
/**
 * Gets performance metrics from the browser
 *
 * @remarks
 * Example: How long did it take to parse the DOM?
 * TODO: Take care about the deprecation warnings
 *
 * @returns - obj: DOM interactive and completion state
 */


const getPerformanceMetrics$1 = () => {
  let domInteractive = NaN;
  let domComplete = NaN;

  if (performance) {
    const entries = performance.getEntriesByType('navigation');

    if (entries.length > 0) {
      const first = entries[0];

      if (first instanceof PerformanceNavigationTiming) {
        domInteractive = first.domInteractive;
        domComplete = first.domComplete;
      }
    } else if (performance.timing && performance.timing.navigationStart && performance.timing.domInteractive && performance.timing.domComplete) {
      domInteractive = performance.timing.domInteractive - performance.timing.navigationStart;
      domComplete = performance.timing.domComplete - performance.timing.navigationStart;
    }
  }

  return {
    domInteractive,
    domComplete
  };
};
/**
 * Gets query parameters from URL
 *
 * @remarks
 * Example: ?abc=1&def=2 -> {abc: '1', def: '2'}
 * TODO: Check if URL component can do it as well
 *
 * @returns - QueryParams {abc: '1', def: '2'}
 */


const getQueryParams$1 = search => {
  const acc = {};

  if (!search) {
    return acc;
  }

  return search.substr(1).split('&').reduce((acc, param) => {
    const [key, value] = param.split('=');
    acc[key] = value ? decodeURIComponent(value.replace(/\+/g, ' ')) : '';
    return acc;
  }, acc);
};
/**
 * Initializes automated tracking for page events
 *
 * @remarks
 * Example: page load, page unload, page visibility-changes,.. etc.
 *
 * @param category - event category (e.g. lp.www)
 * @param track - tracking function
 * @returns - nothing
 */


const addAutomatedTracking = (category, track) => {
  // skip function during server side rendering
  if (typeof document === 'undefined' || typeof window === 'undefined') {
    return;
  }

  const now = Date.now();
  let maxScrollDepth = 0; // wraps the track function with data relevant for the page lifecycle
  // ex: performance metrics, elapsed time, scroll depth

  const trackPage = (label, trackPerformanceMetrics) => {
    const query = getQueryParams$1(window.location.search);
    track({
      category,
      action: 'page',
      label,
      payload: {
        timeSpentOnPageInMS: Date.now() - now,
        performance: trackPerformanceMetrics ? getPerformanceMetrics$1() : undefined,
        scrollDepth: window.scrollY,
        referrer: document.referrer,
        maxScrollDepth,
        query,
        auto: true
      }
    });
  };

  if (document.readyState === 'complete') {
    trackPage('complete', false);
  } else if (document.readyState === 'loading') {
    trackPage('loading', false);
  }

  document.addEventListener('readystatechange', () => {
    if (document.readyState === 'interactive') {
      trackPage('interactive', false);
    } else if (document.readyState === 'complete') {
      trackPage('complete', false);
    }
  });
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      trackPage('visible', false);
    } else if (document.visibilityState === 'hidden') {
      trackPage('hidden', true);
    }
  });
  window.addEventListener('beforeunload', () => {
    trackPage('unload', true);
  });
  document.body.addEventListener( // this tracks all CTAs (using data tracking attributes)
  'click', // TODO: additional "text" probably should refer to the text content
  // of a <button> or <a> tag but is always null
  trackEventType$1(category, 'click', 'tracking', ['href', 'text'], track));
  document.querySelectorAll('[data-tracking-onhover]').forEach(e => {
    e.addEventListener('mouseenter', trackEventType$1(category, 'mouseenter', 'tracking', ['href', 'text'], track));
  });
};

let anonymousTracker;

const setAnonymousTracking = (anonInstance, config) => waitForConsent => {
  waitForConsent("Jimdo Tracking without cookies")(() => {
    anonymousTracker = {
      tracker: anonInstance,
      config
    };
  });
};

const configureAutomatedAnonymousTracking = category => waitForConsent => {
  if (typeof document === "undefined" || typeof window === "undefined") {
    return;
  }

  let interval = null;

  const onAnonymousTracker = tracker => {
    if (document.readyState === "complete") {
      addAutomatedTracking(category, tracker);
    } else {
      window.onload = () => {
        addAutomatedTracking(category, tracker);
      };
    }
  };

  const waitForAnonymousTracker = () => {
    var _anonymousTracker;

    interval = setInterval(waitForAnonymousTracker, 500);

    if ((_anonymousTracker = anonymousTracker) !== null && _anonymousTracker !== void 0 && _anonymousTracker.tracker) {
      onAnonymousTracker(anonymousTracker.tracker);

      if (interval) {
        clearInterval(interval);
      }
    }
  };

  waitForConsent("Jimdo Tracking without cookies")(waitForAnonymousTracker);
};

let richTracker;

const setRichTracking = (richTrackerInstance, config) => waitForConsent => {
  waitForConsent("Jimdo Tracking")(() => {
    richTracker = {
      tracker: richTrackerInstance,
      config
    };
  });
};
/**
 * @deprecated Use setRichTracking instead
 */


const setDwh = (richTrackerInstance, config) => {
  console.warn("setDwh is deprecated and will be removed in future releases. Use setRichTracking instead.");
  return setRichTracking(richTrackerInstance, config);
};

const trackRichEvent$2 = event => {
  if (!richTracker) {
    return false;
  }

  const {
    tracker,
    config: {
      filterPayload
    } = {}
  } = richTracker;
  tracker({ ...event,
    payload: !filterPayload ? event.payload : filterPayload(event.payload)
  });
  return true;
};

const getGtmDataLayer = () => {
  if (window && window.dataLayer) {
    return window.dataLayer;
  }

  window.dataLayer = [];
  return window.dataLayer;
};

const trackEvent$3 = _ref => {
  let {
    eventCategory,
    eventAction,
    eventLabel,
    event,
    nonInteraction,
    ...props
  } = _ref;
  const gtmDataLayer = getGtmDataLayer();
  const trackingData = {
    event: event || "uaevent",
    eventCategory,
    eventAction,
    eventLabel,
    nonInteraction: typeof nonInteraction === "boolean" ? nonInteraction : true,
    ...props
  };
  gtmDataLayer.push(trackingData);
};

var TrackingTypes;

(function (TrackingTypes) {
  TrackingTypes["JIMDO_TRACKING"] = "Jimdo Tracking";
  TrackingTypes["JIMDO_TRACKING_WITHOUT_COOKIES"] = "Jimdo Tracking without cookies";
  TrackingTypes["GTM"] = "GTM";
})(TrackingTypes || (TrackingTypes = {}));

const isOptedIn = dpsName => {
  var _window$__jimdo__$CON;

  if (typeof window === "undefined") {
    return false;
  }

  if (!window.__jimdo__ || !window.__jimdo__.CONSENT_STATUS) {
    return false;
  }

  return ((_window$__jimdo__$CON = window.__jimdo__.CONSENT_STATUS[dpsName]) === null || _window$__jimdo__$CON === void 0 ? void 0 : _window$__jimdo__$CON.consent) || false;
};

const trackRichEvent$1 = (isOptedIn, queueUnsentEvent) => _ref2 => {
  let {
    category,
    action,
    label,
    payload
  } = _ref2;

  if (!isOptedIn("Jimdo Tracking")) {
    queueUnsentEvent === null || queueUnsentEvent === void 0 ? void 0 : queueUnsentEvent({
      category,
      action,
      label,
      payload
    }, TrackingTypes.JIMDO_TRACKING);
    return false;
  }

  return trackRichEvent$2({
    category,
    action,
    label,
    payload
  });
};

const trackAnonEvent$1 = (isOptedIn, queueUnsentEvent) => _ref3 => {
  let {
    category,
    anonymousCategory,
    action,
    label,
    payload
  } = _ref3;

  if (!isOptedIn("Jimdo Tracking without cookies") || !anonymousTracker) {
    queueUnsentEvent === null || queueUnsentEvent === void 0 ? void 0 : queueUnsentEvent({
      category,
      anonymousCategory,
      action,
      label,
      payload
    }, TrackingTypes.JIMDO_TRACKING_WITHOUT_COOKIES);
    return false;
  }

  const {
    tracker,
    config: {
      filterPayload
    } = {}
  } = anonymousTracker;
  tracker({
    category: anonymousCategory || category,
    action,
    label,
    payload: !filterPayload ? payload : filterPayload(payload)
  });
  return true;
};

const trackGtmEvent$1 = (isOptedIn, queueUnsentEvent) => _ref4 => {
  let {
    category,
    action,
    label,
    payload
  } = _ref4;

  if (!isOptedIn("Google Tag Manager")) {
    queueUnsentEvent === null || queueUnsentEvent === void 0 ? void 0 : queueUnsentEvent({
      category,
      action,
      label,
      payload
    }, TrackingTypes.GTM);
    return false;
  }

  trackEvent$3({
    eventCategory: category,
    eventAction: action,
    eventLabel: label,
    nonInteraction: false,
    ...payload
  });
  return true;
};

const trackEvent$2 = (isOptedIn, queueUnsentEvent) => _ref5 => {
  let {
    category,
    anonymousCategory,
    action,
    label,
    payload
  } = _ref5;
  trackRichEvent$1(isOptedIn, queueUnsentEvent)({
    category,
    action,
    label,
    payload
  });
  trackAnonEvent$1(isOptedIn, queueUnsentEvent)({
    category,
    anonymousCategory,
    action,
    label,
    payload
  });
  trackGtmEvent$1(isOptedIn, queueUnsentEvent)({
    category,
    action,
    label,
    payload
  });
};

const constructTracker = isOptedIn => {
  let unsentEvents = {};

  const getTrackFunction = trackingType => {
    switch (trackingType) {
      case TrackingTypes.JIMDO_TRACKING:
        return trackRichEvent$1;

      case TrackingTypes.JIMDO_TRACKING_WITHOUT_COOKIES:
        return trackAnonEvent$1;

      case TrackingTypes.GTM:
        return trackGtmEvent$1;
    }
  };

  const getUnsentEventId = (event, trackingType) => {
    const normalisedTrackingType = trackingType.toLowerCase().replace(/\s/g, "-");
    return `${normalisedTrackingType}-${event.category}-${event.label}-${event.action}-${Date.now()}`;
  };

  const queueUnsentEvent = (event, trackingType) => {
    var _unsentEvents$trackin;

    const id = getUnsentEventId(event, trackingType);

    if (!unsentEvents[trackingType]) {
      unsentEvents[trackingType] = [];
    }

    (_unsentEvents$trackin = unsentEvents[trackingType]) === null || _unsentEvents$trackin === void 0 ? void 0 : _unsentEvents$trackin.push({ ...event,
      id
    });
  };

  const sendUnsentEvents = () => {
    const trackingTypes = Object.keys(unsentEvents);

    for (const trackingType of trackingTypes) {
      const events = unsentEvents[trackingType];

      if (!events || events.length === 0) {
        continue;
      }

      const trackFunction = getTrackFunction(trackingType)(isOptedIn);
      let stillUnsentEvents = [];

      for (const event of events) {
        const {
          id,
          ...eventWithoutId
        } = event;
        const isSent = trackFunction(eventWithoutId);

        if (!isSent) {
          stillUnsentEvents.push(event);
        }
      }

      unsentEvents[trackingType] = stillUnsentEvents;
    }
  };

  const scheduleSendingUsentEvents = function () {
    let interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
    let iteration = 0;

    const schedule = () => {
      const timeOut = (iteration + 1) * interval;
      setTimeout(() => {
        sendUnsentEvents();
        iteration++;

        if (iteration < 10) {
          schedule();
        }
      }, timeOut);
    };

    schedule();
  };

  scheduleSendingUsentEvents();
  const eventTracker = trackEvent$2(isOptedIn, queueUnsentEvent);
  const gtmTracker = trackGtmEvent$1(isOptedIn, queueUnsentEvent);
  const richTracker = trackRichEvent$1(isOptedIn, queueUnsentEvent);
  const anonTracker = trackAnonEvent$1(isOptedIn, queueUnsentEvent);

  const createTrackFunction = tracker => (event, eventPropertiesMapper) => {
    const eventProperties = eventPropertiesMapper ? eventPropertiesMapper(event) : event;
    tracker(eventProperties);
  };

  return {
    trackEvent: createTrackFunction(eventTracker),
    trackGtmEvent: createTrackFunction(gtmTracker),
    trackRichEvent: createTrackFunction(richTracker),
    trackAnonEvent: createTrackFunction(anonTracker)
  };
};

const tracker = constructTracker(isOptedIn);
/**
 * Find earliest parent with `data-${attribute}`
 */

const earliestParentNodeWith = (el, attribute) => {
  if (el.dataset && el.dataset[attribute]) {
    return el;
  }

  if (el.parentNode) {
    return earliestParentNodeWith(el.parentNode, attribute);
  }

  return null;
};

const trackEvent$1 = _ref6 => {
  let {
    category,
    anonymousCategory,
    eventType,
    element,
    attribute,
    additionalProps
  } = _ref6;

  if (!element) {
    return;
  }

  const eventLabel = element.dataset[attribute];
  const additionalPropObj = Object.fromEntries(additionalProps.map(x => [x, element[x]]));
  const trackingProps = Object.fromEntries(Object.entries(element.dataset).filter(x => x[0].startsWith("tracking")));
  const payload = Object.assign({}, additionalPropObj, trackingProps);
  tracker.trackEvent({
    action: eventType,
    label: eventLabel,
    payload,
    category,
    anonymousCategory
  }, _ref7 => {
    let {
      action,
      label,
      payload,
      category,
      anonymousCategory
    } = _ref7;
    return {
      action: label,
      label: action,
      payload,
      category,
      anonymousCategory
    };
  });
};

const trackEventType = isOptedIn => _ref8 => {
  let {
    category,
    anonymousCategory,
    eventType,
    attribute,
    additionalProps
  } = _ref8;
  return event => {
    try {
      const {
        target
      } = event;

      if (!target || !(target instanceof HTMLElement)) {
        return;
      }

      const element = earliestParentNodeWith(target, attribute);
      trackEvent$1({
        category,
        anonymousCategory,
        eventType,
        element,
        attribute,
        additionalProps
      });
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error(`E4655: Trying to trackEvent for on ${eventType}: ${err}`);
    }
  };
};

const getPerformanceMetrics = () => {
  let domInteractive = NaN;
  let domComplete = NaN;

  if (performance && performance.timing && performance.timing.navigationStart && performance.timing.domInteractive && performance.timing.domComplete) {
    domInteractive = performance.timing.domInteractive - performance.timing.navigationStart;
    domComplete = performance.timing.domComplete - performance.timing.navigationStart;
  }

  return {
    domInteractive,
    domComplete
  };
};

const makeTrackingVisible = () => {
  if (!Cookie.get("VISUALIZE_TRACKING")) {
    return;
  }

  const style = document.createElement("style");
  style.innerText = `
        [data-tracking]{ border: 4px black dotted!important; }
        [data-tracking][data-tracking-onhover] { border: 4px blue dotted!important; }
        [data-tracking]:hover:before {
            font-size: 12px;
            color: orange;
            margin-right: 12px;
            content: attr(data-tracking);
            text-transform: lowercase;
        }

    `;
  document.head.appendChild(style);
};

const getQueryParams = search => {
  if (!search) {
    return {};
  }

  return search.substr(1).split("&").reduce((acc, param) => {
    const [key, value] = param.split("=");
    acc[key] = value ? decodeURIComponent(value.replace(/\+/g, " ")) : "";
    return acc;
  }, {});
};

const addCustomAutomatedTracking = isOptedIn => _ref9 => {
  let {
    category,
    anonymousCategory
  } = _ref9;
  let alreadyInitialized = false;
  const now = Date.now();
  let maxScrollDepth = 0;
  const trackEventTypeWithOptIn = trackEventType();

  const eventPropertiesMapper = _ref10 => {
    let {
      action,
      label,
      payload,
      category,
      anonymousCategory
    } = _ref10;
    return {
      action: label,
      label: action,
      payload,
      category,
      anonymousCategory
    };
  };

  const onload = () => {
    const query = getQueryParams(window.location.search);
    tracker.trackEvent({
      category,
      anonymousCategory,
      action: "load",
      label: "page",
      payload: {
        timeSpentOnPageInMS: Date.now() - now,
        scrollDepth: window.scrollY,
        maxScrollDepth,
        nonInteraction: true,
        query
      }
    }, eventPropertiesMapper);
    document.body.addEventListener("click", trackEventTypeWithOptIn({
      category,
      anonymousCategory,
      eventType: "click",
      attribute: "tracking",
      additionalProps: ["href", "text"]
    }));
    document.querySelectorAll("[data-tracking-onhover]").forEach(e => {
      if (e) {
        e.addEventListener("mouseenter", trackEventTypeWithOptIn({
          category,
          anonymousCategory,
          eventType: "mouseenter",
          attribute: "tracking",
          additionalProps: ["href", "text"]
        }));
      } else {
        // eslint-disable-next-line no-console
        console.log(`E7480: Could not attach listener to element`, e);
      }
    }); // Please dont track what is typed because this might autotrack passwords

    document.body.addEventListener("keydown", trackEventTypeWithOptIn({
      category,
      anonymousCategory,
      eventType: "keydown",
      attribute: "tracking",
      additionalProps: ["label"]
    }));
    document.addEventListener("scroll", () => {
      maxScrollDepth = Math.max(window.scrollY, maxScrollDepth);
    }, {
      passive: true
    });
    window.addEventListener("beforeunload", () => {
      tracker.trackEvent({
        category,
        anonymousCategory,
        action: "unload",
        label: "page",
        payload: {
          performance: getPerformanceMetrics(),
          timeSpentOnPageInMS: Date.now() - now,
          scrollDepth: window.scrollY,
          maxScrollDepth,
          nonInteraction: true
        }
      }, eventPropertiesMapper);
    });
    /**
     * Event is fired when user focuses the page
     * happens when tab is changed or user changes
     * to another application and comes back
     */

    window.addEventListener("focus", () => tracker.trackEvent({
      category,
      anonymousCategory,
      action: "focus",
      label: "page",
      payload: {
        timeSpentOnPageInMS: Date.now() - now,
        scrollDepth: window.scrollY,
        maxScrollDepth,
        nonInteraction: true
      }
    }, eventPropertiesMapper));
    window.addEventListener("blur", () => tracker.trackEvent({
      category,
      anonymousCategory,
      action: "blur",
      label: "page",
      payload: {
        performance: getPerformanceMetrics(),
        timeSpentOnPageInMS: Date.now() - now,
        scrollDepthWhileUnloading: window.scrollY,
        maxScrollDepth,
        nonInteraction: true
      }
    }, eventPropertiesMapper));
  };

  return {
    start: () => {
      if (alreadyInitialized) {
        return;
      }

      alreadyInitialized = true;

      if (document.readyState === "complete") {
        onload();
      } else {
        window.onload = onload;
      }
    }
  };
};

const extractQueryParams = () => {
  if (typeof window.location === "undefined" || typeof window.location === "undefined" || !window.location.search) {
    // serverside rendering
    return {};
  }

  const params = window.location.search.replace("?", "").split(/(=|&)/).filter(x => x !== "=" && x !== "&");
  const queryParams = {};

  for (let j = 0; j < params.length; j = j + 2) {
    queryParams[params[j]] = params[j + 1];
  }

  return queryParams;
};

const CREATOR_COOKIE_NAME = "jimdoRefAffiliate";

const unsetOldAffiliateReferrer = () => {
  Cookie.remove(CREATOR_COOKIE_NAME);
};
/**
 * @param {object} queryParams query parameters from url
 * @returns true if the value seems like a correct affiliation link
 */


const isValidAffiliateLink = queryParams => {
  return Boolean(queryParams.irclickid) && Boolean(queryParams.ref) && queryParams.ref.indexOf("imp") === 0;
};

const mapToAffiliateParameters = function () {
  let queryParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    clickId: queryParams.irclickid
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */


var r = function () {
  return (r = Object.assign || function (r) {
    for (var t, n = 1, e = arguments.length; n < e; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o]);

    return r;
  }).apply(this, arguments);
};

var e$1 = [{
  name: "ckies_necessary",
  lifetimeKey: "Y1",
  info: "Confirms that other necessary cookies get set"
}, {
  name: "ckies_functional",
  lifetimeKey: "Y1",
  info: "Opt-out for functional cookies"
}, {
  name: "ckies_performance",
  lifetimeKey: "Y1",
  info: "Opt-out for performance cookies"
}, {
  name: "ckies_marketing",
  lifetimeKey: "Y1",
  info: "Opt-out for marketing/third party/consent based cookies"
}, {
  name: "cookielaw",
  lifetimeKey: "Y1",
  info: "If this cookie is present, the cookie banner shall no longer be displayed because the user has accepted it."
}, {
  name: "userLoggedIn",
  lifetimeKey: "SESSION",
  info: "Indicates that the user is logged in."
}, {
  name: "trs",
  lifetimeKey: "M1",
  info: "Cookie for Affiliate tracking"
}, {
  name: "languageRedirect",
  lifetimeKey: "SESSION",
  info: "Saves the information if the visitor was redirected based on his / her browser language setting."
}, {
  name: "_bb_optout",
  lifetimeKey: "Y1",
  info: "This cookie contains the information that the user does not want to participate in A/B tests with Bunchbox."
}, {
  name: "shd",
  lifetimeKey: "Y1",
  info: "A cookie to identify a returning visitor\t"
}, {
  name: "csrftoken",
  lifetimeKey: "SESSION",
  info: "Mechanism for the secure transmission of data"
}, {
  name: "sessionid",
  lifetimeKey: "SESSION",
  info: "Session cookie for Jimdo Dashboard"
}, {
  name: "ClickAndChange",
  lifetimeKey: "SESSION",
  info: "Session Cookie for Creator CMS"
}, {
  name: "PHPSESSID",
  lifetimeKey: "SESSION",
  info: "Session Cookie for a.jimdo.com"
}, {
  name: "jLang",
  lifetimeKey: "SESSION",
  info: "The chosen language"
}, {
  name: "lang",
  lifetimeKey: "SESSION",
  info: "The chosen language"
}, {
  name: "ga-opt-out",
  lifetimeKey: "Y20",
  info: "Opt-out for Google Analytics and Google Optimize"
}, {
  name: "logo_id",
  lifetimeKey: "SESSION",
  info: "Contains the ID of the user created logo"
}, {
  name: "fullstory_integration",
  lifetimeKey: "D1",
  info: "This cookie is used to enable a consistent integration of the service FullStory throughout the products of Jimdo for the visitor."
}, {
  name: "jimdoRefAffiliate",
  lifetimeKey: "M2",
  info: "This cookie contains information on the users affiliate referrer (if any)"
}, {
  name: "jimdoExperiment",
  lifetimeKey: "M1",
  info: "This cookie contains the A/B test variant that the user takes part in and the functionality related to the test, to make sure that the user’s experience is consistent on our landing pages."
}, {
  name: "accept_tos_during_signup",
  lifetimeKey: "H12",
  info: "This cookie marks the acceptance of the Jimdo Account Terms of Service. (Social Signup only)"
}, {
  name: "accept_newsletter_during_signup",
  lifetimeKey: "H12",
  info: "This cookie marks the newsletter consent during Social signup."
}, {
  name: "user_account_id",
  lifetimeKey: "Y1",
  info: "ID of the Jimdo User Account."
}];
/**
 * @preserve
 * Checks whether given cookie name is part of the allowlist, and,
 * if so, returns that cookie (Cookie). If not, returns undefined
 * @param name - The name of the cookie
 */

var t = function (r) {
  return e$1.find(function (n) {
    return n.name === r;
  });
},
    o$1 = function (n) {
  return void 0 !== t(n);
},
    i$1 = function (n) {
  return o$1(n) ? Cookie.get(n) : void 0;
};

var e = [{
  key: "SESSION",
  value: 0,
  description: "Session"
}, {
  key: "H3",
  value: .125,
  description: "3 hours"
}, {
  key: "H6",
  value: .25,
  description: "6 hours"
}, {
  key: "H12",
  value: .5,
  description: "12 hours"
}, {
  key: "D1",
  value: 1,
  description: "1 day"
}, {
  key: "W1",
  value: 7,
  description: "1 week"
}, {
  key: "M1",
  value: 30,
  description: "1 month"
}, {
  key: "M2",
  value: 60,
  description: "2 months"
}, {
  key: "Y1",
  value: 365,
  description: "1 year"
}, {
  key: "Y2",
  value: 730,
  description: "2 years"
}, {
  key: "Y20",
  value: 7300,
  description: "20 years"
}],
    i = function (i) {
  return e.find(function (e) {
    return e.key === i;
  });
};

var o = function () {
  var o;
  return "undefined" != typeof process && void 0 !== process.env ? "production" === process.env.NODE_ENV : null !== (o = null === window || void 0 === window ? void 0 : window.location.hostname.includes("jimdo.com")) && void 0 !== o && o;
},
    n = function (o, n) {
  if (!o) throw new Error(n);
  console.error(n);
};
/**
 * @preserve
 * Compares cookie name to central allowlist and fetches expires information from it.
 * If the desired cookie name isn't part of that list yet,
 * you should use the js-cookie lib or add the desired cookie name to the allowlist:
 * https://github.com/Jimdo/jimdo-cookies#how-to-update-the-list
 * @param name - The name of the cookie
 * @param value - The value for that cookie
 * @param options - Options object: sameSite, path, domain, secure, but *no* expires
 */


var s = function (s, m, p) {
  void 0 === p && (p = {});
  var f = o(),
      a = t(s);

  if (a) {
    p.hasOwnProperty("expires") && (n(f, "Pls don't provide a custom value for cookie expiration! We fetch the proper value from the allowlist automatically for you."), delete p.expires);
    var d = p,
        u = i(a.lifetimeKey);
    "SESSION" !== a.lifetimeKey && u && (d = r(r({}, d), {
      expires: u.value
    })), Cookie.set(s, m, d);
  } else n(f, 'No cookie "' + s + '" found in allowlist. Check for typo or simply add it!');
};

function getRootDomain() {
  if (typeof window === "undefined" || typeof window.location === "undefined") {
    return "";
  }

  if (window.location.hostname === "localhost") {
    // Local dev
    return window.location.hostname;
  }

  if (window.location.hostname.indexOf("fastly.net") > 0) {
    // CDN
    return window.location.hostname;
  }

  return "." + window.location.hostname.split(".").slice(-2).join(".");
}
/**
 * Cookie is for this service: https://github.com/jimdo/affiliate-reporter
 */


const TRS_COOKIE_NAME = `trs`;
const TRS_COOKIE_VERSION = 1;

const setTRSCookie = value => {
  s(TRS_COOKIE_NAME, `v${TRS_COOKIE_VERSION}.` + btoa(JSON.stringify(value)), {
    domain: getRootDomain() || ".jimdo.com",
    path: "/",
    sameSite: "Lax"
  });
};

const setImpactAffiliationCookie = () => {
  const queryParams = extractQueryParams();

  if (isValidAffiliateLink(queryParams)) {
    setTRSCookie(mapToAffiliateParameters(queryParams));
    unsetOldAffiliateReferrer();
  }
};

const unsetNewAffiliateCookie = () => {
  Cookie.remove(TRS_COOKIE_NAME);
};

const getAffId = (str, regExp) => {
  const [, cookie] = (str || "").match(regExp) || [];
  return cookie;
};

const AFFILIATE_REGEX_HASH = /ref=(a?\d+)/;
const AFFILIATE_REGEX_QUERY = /[&|?]ref=(a?\d+)/;

const getOldAffIdFromUrl = _ref11 => {
  let {
    hash,
    search
  } = _ref11;

  if (AFFILIATE_REGEX_HASH.test(hash)) {
    return getAffId(hash, AFFILIATE_REGEX_HASH);
  }

  if (AFFILIATE_REGEX_QUERY.test(search)) {
    return getAffId(search, AFFILIATE_REGEX_QUERY);
  }

  return null;
};

const setOldAffiliateReferrer = () => {
  if (typeof window !== `undefined`) {
    const affiliateId = getOldAffIdFromUrl(window.location);

    if (affiliateId) {
      s(CREATOR_COOKIE_NAME, affiliateId, {
        path: "/",
        domain: getRootDomain(),
        sameSite: "Lax"
      });
      return affiliateId;
    }
  }

  return null;
};

const setCreatorAffiliationCookie = () => {
  if (getOldAffIdFromUrl(window.location)) {
    setOldAffiliateReferrer();
    unsetNewAffiliateCookie();
  }
};

const getShdCookie = () => i$1("shd");
/**
 * Refreshes live time of cookie
 */


const setShdCookie = () => {
  const shd = getShdCookie() || v4();
  s("shd", shd, {
    domain: getRootDomain() || ".jimdo.com",
    path: "/",
    sameSite: "Lax"
  });
  return shd;
};

const reload = () => {
  if (!window || !window.location) {
    return;
  }

  window.location.reload();
};

const removeCookies = cookieNames => {
  cookieNames.forEach(cookieName => {
    Cookie.remove(cookieName);
  });
};

const JIMDO_CONSENT_CHANGED_EVENT_NAME = "JIMDO_CONSENT_CHANGED";
const JIMDO_CONSENT_BANNER_INTERACTION_EVENT_NAME = "JIMDO_CONSENT_BANNER_INTERACTION";

const onConsentChange = _ref12 => {
  let {
    onAllow,
    onDeny
  } = _ref12;

  if (typeof window === "undefined") {
    return;
  }

  window.addEventListener(JIMDO_CONSENT_CHANGED_EVENT_NAME, event => {
    const {
      detail: {
        dpsName,
        consent,
        userInteraction
      }
    } = event;

    if (consent) {
      onAllow === null || onAllow === void 0 ? void 0 : onAllow(dpsName, userInteraction);
    } else {
      onDeny === null || onDeny === void 0 ? void 0 : onDeny(dpsName, userInteraction);
    }
  });
};

const waitForConsent = isOptedIn => dpsName => onAllow => {
  if (isOptedIn(dpsName)) {
    onAllow();
  } else {
    onConsentChange({
      onAllow: allowedDpsName => {
        if (allowedDpsName !== dpsName) {
          return;
        }

        onAllow();
      }
    });
  }
};

const withConsent = isOptedIn => function () {
  const waitForConsentWithOptIn = waitForConsent(isOptedIn);

  for (var _len2 = arguments.length, loaders = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    loaders[_key2] = arguments[_key2];
  }

  for (const loader of loaders) {
    loader(waitForConsentWithOptIn);
  }
};

const getAnonId = () => getShdCookie() || setShdCookie();

const getUserAccountId = () => i$1("user_account_id");

const onConsentBannerInteraction = onInteraction => {
  if (typeof window === "undefined") {
    return;
  }

  window.addEventListener(JIMDO_CONSENT_BANNER_INTERACTION_EVENT_NAME, event => {
    const {
      detail: {
        type,
        layer
      }
    } = event;
    onInteraction(type, layer);
  });
};

const trackConsentBannerInteraction = consentBannerInteractionsTrackCategory => (type, layer) => {
  tracker.trackRichEvent({
    category: consentBannerInteractionsTrackCategory,
    action: "consent_banner",
    label: type,
    payload: {
      layer
    }
  });
};

const init = _ref13 => {
  let {
    gtmContainerId,
    gtmConsentMode = false,
    customAutomatedTrackingSettings,
    getDpsCookieNames,
    consentBannerInteractionsTrackCategory
  } = _ref13;
  const language = computeLang();
  setShdCookie();
  onConsentChange({
    onAllow: dpsName => {
      switch (dpsName) {
        case "Affiliate":
          setImpactAffiliationCookie();
          setCreatorAffiliationCookie();
          break;
      }
    },
    onDeny: (dpsName, userInteraction) => {
      if (dpsName === "Affiliate") {
        unsetNewAffiliateCookie();
        unsetOldAffiliateReferrer();
        return;
      }

      if (!userInteraction) {
        return;
      }

      removeCookies(getDpsCookieNames(dpsName));
      reload();
    }
  });

  if (consentBannerInteractionsTrackCategory) {
    onConsentBannerInteraction(trackConsentBannerInteraction(consentBannerInteractionsTrackCategory));
  }

  loadGTM(gtmContainerId, language, {
    consentMode: gtmConsentMode
  });

  if (customAutomatedTrackingSettings) {
    const {
      category,
      anonymousCategory
    } = customAutomatedTrackingSettings;
    makeTrackingVisible();
    addCustomAutomatedTracking()({
      category,
      anonymousCategory
    }).start();
  }
};

const withConsentOptIn = withConsent(isOptedIn);
const waitForConsentOptIn = waitForConsent(isOptedIn);
const {
  trackEvent,
  trackGtmEvent,
  trackAnonEvent,
  trackRichEvent
} = tracker;
export { configureAutomatedAnonymousTracking, getAnonId, getUserAccountId, init, setAnonymousTracking, setDwh, setRichTracking, trackAnonEvent, trackEvent, trackGtmEvent, trackRichEvent, waitForConsentOptIn, withConsentOptIn };