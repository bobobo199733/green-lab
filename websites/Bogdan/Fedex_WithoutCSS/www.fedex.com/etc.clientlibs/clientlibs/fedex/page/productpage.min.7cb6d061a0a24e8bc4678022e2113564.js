/*! jQuery UI - v1.12.1 - 2016-09-14
 * http://jqueryui.com
 * Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
 * Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(factory) {
    if (typeof define === "function" && define.amd) {

        // AMD. Register as an anonymous module.
        define(["jquery"], factory);
    } else {

        // Browser globals
        factory(jQuery);
    }
}(function($) {

    $.ui = $.ui || {};

    var version = $.ui.version = "1.12.1";


    /*!
     * jQuery UI Widget 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Widget
    //>>group: Core
    //>>description: Provides a factory for creating stateful widgets with a common API.
    //>>docs: http://api.jqueryui.com/jQuery.widget/
    //>>demos: http://jqueryui.com/widget/



    var widgetUuid = 0;
    var widgetSlice = Array.prototype.slice;

    $.cleanData = (function(orig) {
        return function(elems) {
            var events, elem, i;
            for (i = 0;
                (elem = elems[i]) != null; i++) {
                try {

                    // Only trigger remove when necessary to save time
                    events = $._data(elem, "events");
                    if (events && events.remove) {
                        $(elem).triggerHandler("remove");
                    }

                    // Http://bugs.jquery.com/ticket/8235
                } catch (e) {}
            }
            orig(elems);
        };
    })($.cleanData);

    $.widget = function(name, base, prototype) {
        var existingConstructor, constructor, basePrototype;

        // ProxiedPrototype allows the provided prototype to remain unmodified
        // so that it can be used as a mixin for multiple widgets (#8876)
        var proxiedPrototype = {};

        var namespace = name.split(".")[0];
        name = name.split(".")[1];
        var fullName = namespace + "-" + name;

        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }

        if ($.isArray(prototype)) {
            prototype = $.extend.apply(null, [{}].concat(prototype));
        }

        // Create selector for plugin
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        };

        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function(options, element) {

            // Allow instantiation without "new" keyword
            if (!this._createWidget) {
                return new constructor(options, element);
            }

            // Allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };

        // Extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,

            // Copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),

            // Track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        });

        basePrototype = new base();

        // We need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function(prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = (function() {
                function _super() {
                    return base.prototype[prop].apply(this, arguments);
                }

                function _superApply(args) {
                    return base.prototype[prop].apply(this, args);
                }

                return function() {
                    var __super = this._super;
                    var __superApply = this._superApply;
                    var returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply(this, arguments);

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        });
        constructor.prototype = $.widget.extend(basePrototype, {

            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function(i, child) {
                var childPrototype = child.prototype;

                // Redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor,
                    child._proto);
            });

            // Remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }

        $.widget.bridge(name, constructor);

        return constructor;
    };

    $.widget.extend = function(target) {
        var input = widgetSlice.call(arguments, 1);
        var inputIndex = 0;
        var inputLength = input.length;
        var key;
        var value;

        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {

                    // Clone objects
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ?
                            $.widget.extend({}, target[key], value) :

                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend({}, value);

                        // Copy everything else by reference
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = typeof options === "string";
            var args = widgetSlice.call(arguments, 1);
            var returnValue = this;

            if (isMethodCall) {

                // If this is an empty collection, we need to have the instance method
                // return undefined instead of the jQuery instance
                if (!this.length && options === "instance") {
                    returnValue = undefined;
                } else {
                    this.each(function() {
                        var methodValue;
                        var instance = $.data(this, fullName);

                        if (options === "instance") {
                            returnValue = instance;
                            return false;
                        }

                        if (!instance) {
                            return $.error("cannot call methods on " + name +
                                " prior to initialization; " +
                                "attempted to call method '" + options + "'");
                        }

                        if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                            return $.error("no such method '" + options + "' for " + name +
                                " widget instance");
                        }

                        methodValue = instance[options].apply(instance, args);

                        if (methodValue !== instance && methodValue !== undefined) {
                            returnValue = methodValue && methodValue.jquery ?
                                returnValue.pushStack(methodValue.get()) :
                                methodValue;
                            return false;
                        }
                    });
                }
            } else {

                // Allow multiple hashes to be passed on init
                if (args.length) {
                    options = $.widget.extend.apply(null, [options].concat(args));
                }

                this.each(function() {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {});
                        if (instance._init) {
                            instance._init();
                        }
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function( /* options, element */ ) {};
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",

        options: {
            classes: {},
            disabled: false,

            // Callbacks
            create: null
        },

        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = widgetUuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            this.classesElementLookup = {};

            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function(event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ?

                    // Element within the document
                    element.ownerDocument :

                    // Element is window or document
                    element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }

            this.options = $.widget.extend({},
                this.options,
                this._getCreateOptions(),
                options);

            this._create();

            if (this.options.disabled) {
                this._setOptionDisabled(this.options.disabled);
            }

            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },

        _getCreateOptions: function() {
            return {};
        },

        _getCreateEventData: $.noop,

        _create: $.noop,

        _init: $.noop,

        destroy: function() {
            var that = this;

            this._destroy();
            $.each(this.classesElementLookup, function(key, value) {
                that._removeClass(value, key);
            });

            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .off(this.eventNamespace)
                .removeData(this.widgetFullName);
            this.widget()
                .off(this.eventNamespace)
                .removeAttr("aria-disabled");

            // Clean up events and states
            this.bindings.off(this.eventNamespace);
        },

        _destroy: $.noop,

        widget: function() {
            return this.element;
        },

        option: function(key, value) {
            var options = key;
            var parts;
            var curOption;
            var i;

            if (arguments.length === 0) {

                // Don't return a reference to the internal hash
                return $.widget.extend({}, this.options);
            }

            if (typeof key === "string") {

                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (arguments.length === 1) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (arguments.length === 1) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }

            this._setOptions(options);

            return this;
        },

        _setOptions: function(options) {
            var key;

            for (key in options) {
                this._setOption(key, options[key]);
            }

            return this;
        },

        _setOption: function(key, value) {
            if (key === "classes") {
                this._setOptionClasses(value);
            }

            this.options[key] = value;

            if (key === "disabled") {
                this._setOptionDisabled(value);
            }

            return this;
        },

        _setOptionClasses: function(value) {
            var classKey, elements, currentElements;

            for (classKey in value) {
                currentElements = this.classesElementLookup[classKey];
                if (value[classKey] === this.options.classes[classKey] ||
                    !currentElements ||
                    !currentElements.length) {
                    continue;
                }

                // We are doing this to create a new jQuery object because the _removeClass() call
                // on the next line is going to destroy the reference to the current elements being
                // tracked. We need to save a copy of this collection so that we can add the new classes
                // below.
                elements = $(currentElements.get());
                this._removeClass(currentElements, classKey);

                // We don't use _addClass() here, because that uses this.options.classes
                // for generating the string of classes. We want to use the value passed in from
                // _setOption(), this is the new value of the classes option which was passed to
                // _setOption(). We pass this value directly to _classes().
                elements.addClass(this._classes({
                    element: elements,
                    keys: classKey,
                    classes: value,
                    add: true
                }));
            }
        },

        _setOptionDisabled: function(value) {
            this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value);

            // If the widget is becoming disabled, then nothing is interactive
            if (value) {
                this._removeClass(this.hoverable, null, "ui-state-hover");
                this._removeClass(this.focusable, null, "ui-state-focus");
            }
        },

        enable: function() {
            return this._setOptions({
                disabled: false
            });
        },

        disable: function() {
            return this._setOptions({
                disabled: true
            });
        },

        _classes: function(options) {
            var full = [];
            var that = this;

            options = $.extend({
                element: this.element,
                classes: this.options.classes || {}
            }, options);

            function processClassString(classes, checkOption) {
                var current, i;
                for (i = 0; i < classes.length; i++) {
                    current = that.classesElementLookup[classes[i]] || $();
                    if (options.add) {
                        current = $($.unique(current.get().concat(options.element.get())));
                    } else {
                        current = $(current.not(options.element).get());
                    }
                    that.classesElementLookup[classes[i]] = current;
                    full.push(classes[i]);
                    if (checkOption && options.classes[classes[i]]) {
                        full.push(options.classes[classes[i]]);
                    }
                }
            }

            this._on(options.element, {
                "remove": "_untrackClassesElement"
            });

            if (options.keys) {
                processClassString(options.keys.match(/\S+/g) || [], true);
            }
            if (options.extra) {
                processClassString(options.extra.match(/\S+/g) || []);
            }

            return full.join(" ");
        },

        _untrackClassesElement: function(event) {
            var that = this;
            $.each(that.classesElementLookup, function(key, value) {
                if ($.inArray(event.target, value) !== -1) {
                    that.classesElementLookup[key] = $(value.not(event.target).get());
                }
            });
        },

        _removeClass: function(element, keys, extra) {
            return this._toggleClass(element, keys, extra, false);
        },

        _addClass: function(element, keys, extra) {
            return this._toggleClass(element, keys, extra, true);
        },

        _toggleClass: function(element, keys, extra, add) {
            add = (typeof add === "boolean") ? add : extra;
            var shift = (typeof element === "string" || element === null),
                options = {
                    extra: shift ? keys : extra,
                    keys: shift ? element : keys,
                    element: shift ? this.element : element,
                    add: add
                };
            options.element.toggleClass(this._classes(options), add);
            return this;
        },

        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement;
            var instance = this;

            // No suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // No element argument, shuffle and use this.element
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }

            $.each(handlers, function(event, handler) {
                function handlerProxy() {

                    // Allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if (!suppressDisabledCheck &&
                        (instance.options.disabled === true ||
                            $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler)
                        .apply(instance, arguments);
                }

                // Copy the guid so direct unbinding works
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match(/^([\w:-]*)\s*(.*)$/);
                var eventName = match[1] + instance.eventNamespace;
                var selector = match[2];

                if (selector) {
                    delegateElement.on(eventName, selector, handlerProxy);
                } else {
                    element.on(eventName, handlerProxy);
                }
            });
        },

        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") +
                this.eventNamespace;
            element.off(eventName).off(eventName);

            // Clear the stack to avoid memory leaks (#10056)
            this.bindings = $(this.bindings.not(element).get());
            this.focusable = $(this.focusable.not(element).get());
            this.hoverable = $(this.hoverable.not(element).get());
        },

        _delay: function(handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler)
                    .apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },

        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function(event) {
                    this._addClass($(event.currentTarget), null, "ui-state-hover");
                },
                mouseleave: function(event) {
                    this._removeClass($(event.currentTarget), null, "ui-state-hover");
                }
            });
        },

        _focusable: function(element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function(event) {
                    this._addClass($(event.currentTarget), null, "ui-state-focus");
                },
                focusout: function(event) {
                    this._removeClass($(event.currentTarget), null, "ui-state-focus");
                }
            });
        },

        _trigger: function(type, event, data) {
            var prop, orig;
            var callback = this.options[type];

            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type).toLowerCase();

            // The original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0];

            // Copy original event properties over to the new event
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }

            this.element.trigger(event, data);
            return !($.isFunction(callback) &&
                callback.apply(this.element[0], [event].concat(data)) === false ||
                event.isDefaultPrevented());
        }
    };

    $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            if (typeof options === "string") {
                options = {
                    effect: options
                };
            }

            var hasOptions;
            var effectName = !options ?
                method :
                options === true || typeof options === "number" ?
                defaultEffect :
                options.effect || defaultEffect;

            options = options || {};
            if (typeof options === "number") {
                options = {
                    duration: options
                };
            }

            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;

            if (options.delay) {
                element.delay(options.delay);
            }

            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function(next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });

    var widget = $.widget;


    /*!
     * jQuery UI Position 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/position/
     */

    //>>label: Position
    //>>group: Core
    //>>description: Positions elements relative to other elements.
    //>>docs: http://api.jqueryui.com/position/
    //>>demos: http://jqueryui.com/position/


    (function() {
        var cachedScrollbarWidth,
            max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position;

        function getOffsets(offsets, width, height) {
            return [
                parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
                parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
            ];
        }

        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0;
        }

        function getDimensions(elem) {
            var raw = elem[0];
            if (raw.nodeType === 9) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: 0,
                        left: 0
                    }
                };
            }
            if ($.isWindow(raw)) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: elem.scrollTop(),
                        left: elem.scrollLeft()
                    }
                };
            }
            if (raw.preventDefault) {
                return {
                    width: 0,
                    height: 0,
                    offset: {
                        top: raw.pageY,
                        left: raw.pageX
                    }
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }

        $.position = {
            scrollbarWidth: function() {
                if (cachedScrollbarWidth !== undefined) {
                    return cachedScrollbarWidth;
                }
                var w1, w2,
                    div = $("<div " +
                        "style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
                        "<div style='height:100px;width:auto;'></div></div>"),
                    innerDiv = div.children()[0];

                $("body").append(div);
                w1 = innerDiv.offsetWidth;
                div.css("overflow", "scroll");

                w2 = innerDiv.offsetWidth;

                if (w1 === w2) {
                    w2 = div[0].clientWidth;
                }

                div.remove();

                return (cachedScrollbarWidth = w1 - w2);
            },
            getScrollInfo: function(within) {
                var overflowX = within.isWindow || within.isDocument ? "" :
                    within.element.css("overflow-x"),
                    overflowY = within.isWindow || within.isDocument ? "" :
                    within.element.css("overflow-y"),
                    hasOverflowX = overflowX === "scroll" ||
                    (overflowX === "auto" && within.width < within.element[0].scrollWidth),
                    hasOverflowY = overflowY === "scroll" ||
                    (overflowY === "auto" && within.height < within.element[0].scrollHeight);
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function(element) {
                var withinElement = $(element || window),
                    isWindow = $.isWindow(withinElement[0]),
                    isDocument = !!withinElement[0] && withinElement[0].nodeType === 9,
                    hasOffset = !isWindow && !isDocument;
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    isDocument: isDocument,
                    offset: hasOffset ? $(element).offset() : {
                        left: 0,
                        top: 0
                    },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: withinElement.outerWidth(),
                    height: withinElement.outerHeight()
                };
            }
        };

        $.fn.position = function(options) {
            if (!options || !options.of) {
                return _position.apply(this, arguments);
            }

            // Make a copy, we don't want to modify arguments
            options = $.extend({}, options);

            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                target = $(options.of),
                within = $.position.getWithinInfo(options.within),
                scrollInfo = $.position.getScrollInfo(within),
                collision = (options.collision || "flip").split(" "),
                offsets = {};

            dimensions = getDimensions(target);
            if (target[0].preventDefault) {

                // Force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;

            // Clone to reuse original targetOffset later
            basePosition = $.extend({}, targetOffset);

            // Force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            $.each(["my", "at"], function() {
                var pos = (options[this] || "").split(" "),
                    horizontalOffset,
                    verticalOffset;

                if (pos.length === 1) {
                    pos = rhorizontal.test(pos[0]) ?
                        pos.concat(["center"]) :
                        rvertical.test(pos[0]) ? ["center"].concat(pos) : ["center", "center"];
                }
                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";

                // Calculate offsets
                horizontalOffset = roffset.exec(pos[0]);
                verticalOffset = roffset.exec(pos[1]);
                offsets[this] = [
                    horizontalOffset ? horizontalOffset[0] : 0,
                    verticalOffset ? verticalOffset[0] : 0
                ];

                // Reduce to just the positions without the offsets
                options[this] = [
                    rposition.exec(pos[0])[0],
                    rposition.exec(pos[1])[0]
                ];
            });

            // Normalize collision option
            if (collision.length === 1) {
                collision[1] = collision[0];
            }

            if (options.at[0] === "right") {
                basePosition.left += targetWidth;
            } else if (options.at[0] === "center") {
                basePosition.left += targetWidth / 2;
            }

            if (options.at[1] === "bottom") {
                basePosition.top += targetHeight;
            } else if (options.at[1] === "center") {
                basePosition.top += targetHeight / 2;
            }

            atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
            basePosition.left += atOffset[0];
            basePosition.top += atOffset[1];

            return this.each(function() {
                var collisionPosition, using,
                    elem = $(this),
                    elemWidth = elem.outerWidth(),
                    elemHeight = elem.outerHeight(),
                    marginLeft = parseCss(this, "marginLeft"),
                    marginTop = parseCss(this, "marginTop"),
                    collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") +
                    scrollInfo.width,
                    collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") +
                    scrollInfo.height,
                    position = $.extend({}, basePosition),
                    myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

                if (options.my[0] === "right") {
                    position.left -= elemWidth;
                } else if (options.my[0] === "center") {
                    position.left -= elemWidth / 2;
                }

                if (options.my[1] === "bottom") {
                    position.top -= elemHeight;
                } else if (options.my[1] === "center") {
                    position.top -= elemHeight / 2;
                }

                position.left += myOffset[0];
                position.top += myOffset[1];

                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };

                $.each(["left", "top"], function(i, dir) {
                    if ($.ui.position[collision[i]]) {
                        $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        });
                    }
                });

                if (options.using) {

                    // Adds feedback as second argument to using callback, if present
                    using = function(props) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                            feedback.horizontal = "center";
                        }
                        if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                            feedback.vertical = "middle";
                        }
                        if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call(this, props, feedback);
                    };
                }

                elem.offset($.extend(position, {
                    using: using
                }));
            });
        };

        $.ui.position = {
            fit: {
                left: function(position, data) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                        newOverRight;

                    // Element is wider than within
                    if (data.collisionWidth > outerWidth) {

                        // Element is initially over the left side of within
                        if (overLeft > 0 && overRight <= 0) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                                withinOffset;
                            position.left += overLeft - newOverRight;

                            // Element is initially over right side of within
                        } else if (overRight > 0 && overLeft <= 0) {
                            position.left = withinOffset;

                            // Element is initially over both left and right sides of within
                        } else {
                            if (overLeft > overRight) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }

                        // Too far left -> align with left edge
                    } else if (overLeft > 0) {
                        position.left += overLeft;

                        // Too far right -> align with right edge
                    } else if (overRight > 0) {
                        position.left -= overRight;

                        // Adjust based on position and margin
                    } else {
                        position.left = max(position.left - collisionPosLeft, position.left);
                    }
                },
                top: function(position, data) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                        newOverBottom;

                    // Element is taller than within
                    if (data.collisionHeight > outerHeight) {

                        // Element is initially over the top of within
                        if (overTop > 0 && overBottom <= 0) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                                withinOffset;
                            position.top += overTop - newOverBottom;

                            // Element is initially over bottom of within
                        } else if (overBottom > 0 && overTop <= 0) {
                            position.top = withinOffset;

                            // Element is initially over both top and bottom of within
                        } else {
                            if (overTop > overBottom) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }

                        // Too far up -> align with top
                    } else if (overTop > 0) {
                        position.top += overTop;

                        // Too far down -> align with bottom edge
                    } else if (overBottom > 0) {
                        position.top -= overBottom;

                        // Adjust based on position and margin
                    } else {
                        position.top = max(position.top - collisionPosTop, position.top);
                    }
                }
            },
            flip: {
                left: function(position, data) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                        myOffset = data.my[0] === "left" ?
                        -data.elemWidth :
                        data.my[0] === "right" ?
                        data.elemWidth :
                        0,
                        atOffset = data.at[0] === "left" ?
                        data.targetWidth :
                        data.at[0] === "right" ?
                        -data.targetWidth :
                        0,
                        offset = -2 * data.offset[0],
                        newOverRight,
                        newOverLeft;

                    if (overLeft < 0) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
                            outerWidth - withinOffset;
                        if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if (overRight > 0) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
                            atOffset + offset - offsetLeft;
                        if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function(position, data) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                        top = data.my[1] === "top",
                        myOffset = top ?
                        -data.elemHeight :
                        data.my[1] === "bottom" ?
                        data.elemHeight :
                        0,
                        atOffset = data.at[1] === "top" ?
                        data.targetHeight :
                        data.at[1] === "bottom" ?
                        -data.targetHeight :
                        0,
                        offset = -2 * data.offset[1],
                        newOverTop,
                        newOverBottom;
                    if (overTop < 0) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
                            outerHeight - withinOffset;
                        if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if (overBottom > 0) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
                            offset - offsetTop;
                        if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply(this, arguments);
                    $.ui.position.fit.left.apply(this, arguments);
                },
                top: function() {
                    $.ui.position.flip.top.apply(this, arguments);
                    $.ui.position.fit.top.apply(this, arguments);
                }
            }
        };

    })();

    var position = $.ui.position;


    /*!
     * jQuery UI :data 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: :data Selector
    //>>group: Core
    //>>description: Selects elements which have data stored under the specified key.
    //>>docs: http://api.jqueryui.com/data-selector/


    var data = $.extend($.expr[":"], {
        data: $.expr.createPseudo ?
            $.expr.createPseudo(function(dataName) {
                return function(elem) {
                    return !!$.data(elem, dataName);
                };
            }) :

            // Support: jQuery <1.8
            function(elem, i, match) {
                return !!$.data(elem, match[3]);
            }
    });

    /*!
     * jQuery UI Disable Selection 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: disableSelection
    //>>group: Core
    //>>description: Disable selection of text content within the set of matched elements.
    //>>docs: http://api.jqueryui.com/disableSelection/

    // This file is deprecated


    var disableSelection = $.fn.extend({
        disableSelection: (function() {
            var eventType = "onselectstart" in document.createElement("div") ?
                "selectstart" :
                "mousedown";

            return function() {
                return this.on(eventType + ".ui-disableSelection", function(event) {
                    event.preventDefault();
                });
            };
        })(),

        enableSelection: function() {
            return this.off(".ui-disableSelection");
        }
    });


    /*!
     * jQuery UI Effects 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Effects Core
    //>>group: Effects
    // jscs:disable maximumLineLength
    //>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/category/effects-core/
    //>>demos: http://jqueryui.com/effect/



    var dataSpace = "ui-effects-",
        dataSpaceStyle = "ui-effects-style",
        dataSpaceAnimated = "ui-effects-animated",

        // Create a local jQuery because jQuery Color relies on it and the
        // global may not exist with AMD and a custom build (#10199)
        jQuery = $;

    $.effects = {
        effect: {}
    };

    /*!
     * jQuery Color Animations v2.1.2
     * https://github.com/jquery/jquery-color
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * Date: Wed Jan 16 08:47:09 2013 -0600
     */
    (function(jQuery, undefined) {

        var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
            "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

            // Plusequals test for += 100 -= 100
            rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,

            // A set of RE's that can match strings and generate color tuples.
            stringParsers = [{
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function(execResult) {
                    return [
                        execResult[1],
                        execResult[2],
                        execResult[3],
                        execResult[4]
                    ];
                }
            }, {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function(execResult) {
                    return [
                        execResult[1] * 2.55,
                        execResult[2] * 2.55,
                        execResult[3] * 2.55,
                        execResult[4]
                    ];
                }
            }, {

                // This regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                parse: function(execResult) {
                    return [
                        parseInt(execResult[1], 16),
                        parseInt(execResult[2], 16),
                        parseInt(execResult[3], 16)
                    ];
                }
            }, {

                // This regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                parse: function(execResult) {
                    return [
                        parseInt(execResult[1] + execResult[1], 16),
                        parseInt(execResult[2] + execResult[2], 16),
                        parseInt(execResult[3] + execResult[3], 16)
                    ];
                }
            }, {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                space: "hsla",
                parse: function(execResult) {
                    return [
                        execResult[1],
                        execResult[2] / 100,
                        execResult[3] / 100,
                        execResult[4]
                    ];
                }
            }],

            // JQuery.Color( )
            color = jQuery.Color = function(color, green, blue, alpha) {
                return new jQuery.Color.fn.parse(color, green, blue, alpha);
            },
            spaces = {
                rgba: {
                    props: {
                        red: {
                            idx: 0,
                            type: "byte"
                        },
                        green: {
                            idx: 1,
                            type: "byte"
                        },
                        blue: {
                            idx: 2,
                            type: "byte"
                        }
                    }
                },

                hsla: {
                    props: {
                        hue: {
                            idx: 0,
                            type: "degrees"
                        },
                        saturation: {
                            idx: 1,
                            type: "percent"
                        },
                        lightness: {
                            idx: 2,
                            type: "percent"
                        }
                    }
                }
            },
            propTypes = {
                "byte": {
                    floor: true,
                    max: 255
                },
                "percent": {
                    max: 1
                },
                "degrees": {
                    mod: 360,
                    floor: true
                }
            },
            support = color.support = {},

            // Element for support tests
            supportElem = jQuery("<p>")[0],

            // Colors = jQuery.Color.names
            colors,

            // Local aliases of functions called often
            each = jQuery.each;

        // Determine rgba support immediately
        supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
        support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;

        // Define cache name and alpha properties
        // for rgba and hsla spaces
        each(spaces, function(spaceName, space) {
            space.cache = "_" + spaceName;
            space.props.alpha = {
                idx: 3,
                type: "percent",
                def: 1
            };
        });

        function clamp(value, prop, allowEmpty) {
            var type = propTypes[prop.type] || {};

            if (value == null) {
                return (allowEmpty || !prop.def) ? null : prop.def;
            }

            // ~~ is an short way of doing floor for positive numbers
            value = type.floor ? ~~value : parseFloat(value);

            // IE will pass in empty strings as value for alpha,
            // which will hit this case
            if (isNaN(value)) {
                return prop.def;
            }

            if (type.mod) {

                // We add mod before modding to make sure that negatives values
                // get converted properly: -10 -> 350
                return (value + type.mod) % type.mod;
            }

            // For now all property types without mod have min and max
            return 0 > value ? 0 : type.max < value ? type.max : value;
        }

        function stringParse(string) {
            var inst = color(),
                rgba = inst._rgba = [];

            string = string.toLowerCase();

            each(stringParsers, function(i, parser) {
                var parsed,
                    match = parser.re.exec(string),
                    values = match && parser.parse(match),
                    spaceName = parser.space || "rgba";

                if (values) {
                    parsed = inst[spaceName](values);

                    // If this was an rgba parse the assignment might happen twice
                    // oh well....
                    inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                    rgba = inst._rgba = parsed._rgba;

                    // Exit each( stringParsers ) here because we matched
                    return false;
                }
            });

            // Found a stringParser that handled it
            if (rgba.length) {

                // If this came from a parsed string, force "transparent" when alpha is 0
                // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
                if (rgba.join() === "0,0,0,0") {
                    jQuery.extend(rgba, colors.transparent);
                }
                return inst;
            }

            // Named colors
            return colors[string];
        }

        color.fn = jQuery.extend(color.prototype, {
            parse: function(red, green, blue, alpha) {
                if (red === undefined) {
                    this._rgba = [null, null, null, null];
                    return this;
                }
                if (red.jquery || red.nodeType) {
                    red = jQuery(red).css(green);
                    green = undefined;
                }

                var inst = this,
                    type = jQuery.type(red),
                    rgba = this._rgba = [];

                // More than 1 argument specified - assume ( red, green, blue, alpha )
                if (green !== undefined) {
                    red = [red, green, blue, alpha];
                    type = "array";
                }

                if (type === "string") {
                    return this.parse(stringParse(red) || colors._default);
                }

                if (type === "array") {
                    each(spaces.rgba.props, function(key, prop) {
                        rgba[prop.idx] = clamp(red[prop.idx], prop);
                    });
                    return this;
                }

                if (type === "object") {
                    if (red instanceof color) {
                        each(spaces, function(spaceName, space) {
                            if (red[space.cache]) {
                                inst[space.cache] = red[space.cache].slice();
                            }
                        });
                    } else {
                        each(spaces, function(spaceName, space) {
                            var cache = space.cache;
                            each(space.props, function(key, prop) {

                                // If the cache doesn't exist, and we know how to convert
                                if (!inst[cache] && space.to) {

                                    // If the value was null, we don't need to copy it
                                    // if the key was alpha, we don't need to copy it either
                                    if (key === "alpha" || red[key] == null) {
                                        return;
                                    }
                                    inst[cache] = space.to(inst._rgba);
                                }

                                // This is the only case where we allow nulls for ALL properties.
                                // call clamp with alwaysAllowEmpty
                                inst[cache][prop.idx] = clamp(red[key], prop, true);
                            });

                            // Everything defined but alpha?
                            if (inst[cache] &&
                                jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {

                                // Use the default of 1
                                inst[cache][3] = 1;
                                if (space.from) {
                                    inst._rgba = space.from(inst[cache]);
                                }
                            }
                        });
                    }
                    return this;
                }
            },
            is: function(compare) {
                var is = color(compare),
                    same = true,
                    inst = this;

                each(spaces, function(_, space) {
                    var localCache,
                        isCache = is[space.cache];
                    if (isCache) {
                        localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                        each(space.props, function(_, prop) {
                            if (isCache[prop.idx] != null) {
                                same = (isCache[prop.idx] === localCache[prop.idx]);
                                return same;
                            }
                        });
                    }
                    return same;
                });
                return same;
            },
            _space: function() {
                var used = [],
                    inst = this;
                each(spaces, function(spaceName, space) {
                    if (inst[space.cache]) {
                        used.push(spaceName);
                    }
                });
                return used.pop();
            },
            transition: function(other, distance) {
                var end = color(other),
                    spaceName = end._space(),
                    space = spaces[spaceName],
                    startColor = this.alpha() === 0 ? color("transparent") : this,
                    start = startColor[space.cache] || space.to(startColor._rgba),
                    result = start.slice();

                end = end[space.cache];
                each(space.props, function(key, prop) {
                    var index = prop.idx,
                        startValue = start[index],
                        endValue = end[index],
                        type = propTypes[prop.type] || {};

                    // If null, don't override start value
                    if (endValue === null) {
                        return;
                    }

                    // If null - use end
                    if (startValue === null) {
                        result[index] = endValue;
                    } else {
                        if (type.mod) {
                            if (endValue - startValue > type.mod / 2) {
                                startValue += type.mod;
                            } else if (startValue - endValue > type.mod / 2) {
                                startValue -= type.mod;
                            }
                        }
                        result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                    }
                });
                return this[spaceName](result);
            },
            blend: function(opaque) {

                // If we are already opaque - return ourself
                if (this._rgba[3] === 1) {
                    return this;
                }

                var rgb = this._rgba.slice(),
                    a = rgb.pop(),
                    blend = color(opaque)._rgba;

                return color(jQuery.map(rgb, function(v, i) {
                    return (1 - a) * blend[i] + a * v;
                }));
            },
            toRgbaString: function() {
                var prefix = "rgba(",
                    rgba = jQuery.map(this._rgba, function(v, i) {
                        return v == null ? (i > 2 ? 1 : 0) : v;
                    });

                if (rgba[3] === 1) {
                    rgba.pop();
                    prefix = "rgb(";
                }

                return prefix + rgba.join() + ")";
            },
            toHslaString: function() {
                var prefix = "hsla(",
                    hsla = jQuery.map(this.hsla(), function(v, i) {
                        if (v == null) {
                            v = i > 2 ? 1 : 0;
                        }

                        // Catch 1 and 2
                        if (i && i < 3) {
                            v = Math.round(v * 100) + "%";
                        }
                        return v;
                    });

                if (hsla[3] === 1) {
                    hsla.pop();
                    prefix = "hsl(";
                }
                return prefix + hsla.join() + ")";
            },
            toHexString: function(includeAlpha) {
                var rgba = this._rgba.slice(),
                    alpha = rgba.pop();

                if (includeAlpha) {
                    rgba.push(~~(alpha * 255));
                }

                return "#" + jQuery.map(rgba, function(v) {

                    // Default to 0 when nulls exist
                    v = (v || 0).toString(16);
                    return v.length === 1 ? "0" + v : v;
                }).join("");
            },
            toString: function() {
                return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
            }
        });
        color.fn.parse.prototype = color.fn;

        // Hsla conversions adapted from:
        // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

        function hue2rgb(p, q, h) {
            h = (h + 1) % 1;
            if (h * 6 < 1) {
                return p + (q - p) * h * 6;
            }
            if (h * 2 < 1) {
                return q;
            }
            if (h * 3 < 2) {
                return p + (q - p) * ((2 / 3) - h) * 6;
            }
            return p;
        }

        spaces.hsla.to = function(rgba) {
            if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                return [null, null, null, rgba[3]];
            }
            var r = rgba[0] / 255,
                g = rgba[1] / 255,
                b = rgba[2] / 255,
                a = rgba[3],
                max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                diff = max - min,
                add = max + min,
                l = add * 0.5,
                h, s;

            if (min === max) {
                h = 0;
            } else if (r === max) {
                h = (60 * (g - b) / diff) + 360;
            } else if (g === max) {
                h = (60 * (b - r) / diff) + 120;
            } else {
                h = (60 * (r - g) / diff) + 240;
            }

            // Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
            // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
            if (diff === 0) {
                s = 0;
            } else if (l <= 0.5) {
                s = diff / add;
            } else {
                s = diff / (2 - add);
            }
            return [Math.round(h) % 360, s, l, a == null ? 1 : a];
        };

        spaces.hsla.from = function(hsla) {
            if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                return [null, null, null, hsla[3]];
            }
            var h = hsla[0] / 360,
                s = hsla[1],
                l = hsla[2],
                a = hsla[3],
                q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
                p = 2 * l - q;

            return [
                Math.round(hue2rgb(p, q, h + (1 / 3)) * 255),
                Math.round(hue2rgb(p, q, h) * 255),
                Math.round(hue2rgb(p, q, h - (1 / 3)) * 255),
                a
            ];
        };

        each(spaces, function(spaceName, space) {
            var props = space.props,
                cache = space.cache,
                to = space.to,
                from = space.from;

            // Makes rgba() and hsla()
            color.fn[spaceName] = function(value) {

                // Generate a cache for this space if it doesn't exist
                if (to && !this[cache]) {
                    this[cache] = to(this._rgba);
                }
                if (value === undefined) {
                    return this[cache].slice();
                }

                var ret,
                    type = jQuery.type(value),
                    arr = (type === "array" || type === "object") ? value : arguments,
                    local = this[cache].slice();

                each(props, function(key, prop) {
                    var val = arr[type === "object" ? key : prop.idx];
                    if (val == null) {
                        val = local[prop.idx];
                    }
                    local[prop.idx] = clamp(val, prop);
                });

                if (from) {
                    ret = color(from(local));
                    ret[cache] = local;
                    return ret;
                } else {
                    return color(local);
                }
            };

            // Makes red() green() blue() alpha() hue() saturation() lightness()
            each(props, function(key, prop) {

                // Alpha is included in more than one space
                if (color.fn[key]) {
                    return;
                }
                color.fn[key] = function(value) {
                    var vtype = jQuery.type(value),
                        fn = (key === "alpha" ? (this._hsla ? "hsla" : "rgba") : spaceName),
                        local = this[fn](),
                        cur = local[prop.idx],
                        match;

                    if (vtype === "undefined") {
                        return cur;
                    }

                    if (vtype === "function") {
                        value = value.call(this, cur);
                        vtype = jQuery.type(value);
                    }
                    if (value == null && prop.empty) {
                        return this;
                    }
                    if (vtype === "string") {
                        match = rplusequals.exec(value);
                        if (match) {
                            value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                        }
                    }
                    local[prop.idx] = value;
                    return this[fn](local);
                };
            });
        });

        // Add cssHook and .fx.step function for each named hook.
        // accept a space separated string of properties
        color.hook = function(hook) {
            var hooks = hook.split(" ");
            each(hooks, function(i, hook) {
                jQuery.cssHooks[hook] = {
                    set: function(elem, value) {
                        var parsed, curElem,
                            backgroundColor = "";

                        if (value !== "transparent" && (jQuery.type(value) !== "string" ||
                                (parsed = stringParse(value)))) {
                            value = color(parsed || value);
                            if (!support.rgba && value._rgba[3] !== 1) {
                                curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                while (
                                    (backgroundColor === "" || backgroundColor === "transparent") &&
                                    curElem && curElem.style
                                ) {
                                    try {
                                        backgroundColor = jQuery.css(curElem, "backgroundColor");
                                        curElem = curElem.parentNode;
                                    } catch (e) {}
                                }

                                value = value.blend(backgroundColor && backgroundColor !== "transparent" ?
                                    backgroundColor :
                                    "_default");
                            }

                            value = value.toRgbaString();
                        }
                        try {
                            elem.style[hook] = value;
                        } catch (e) {

                            // Wrapped to prevent IE from throwing errors on "invalid" values like
                            // 'auto' or 'inherit'
                        }
                    }
                };
                jQuery.fx.step[hook] = function(fx) {
                    if (!fx.colorInit) {
                        fx.start = color(fx.elem, hook);
                        fx.end = color(fx.end);
                        fx.colorInit = true;
                    }
                    jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                };
            });

        };

        color.hook(stepHooks);

        jQuery.cssHooks.borderColor = {
            expand: function(value) {
                var expanded = {};

                each(["Top", "Right", "Bottom", "Left"], function(i, part) {
                    expanded["border" + part + "Color"] = value;
                });
                return expanded;
            }
        };

        // Basic color names only.
        // Usage of any of the other color names requires adding yourself or including
        // jquery.color.svg-names.js.
        colors = jQuery.Color.names = {

            // 4.1. Basic color keywords
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",

            // 4.2.3. "transparent" color keyword
            transparent: [null, null, null, 0],

            _default: "#ffffff"
        };

    })(jQuery);

    /******************************************************************************/
    /****************************** CLASS ANIMATIONS ******************************/
    /******************************************************************************/
    (function() {

        var classAnimationActions = ["add", "remove", "toggle"],
            shorthandStyles = {
                border: 1,
                borderBottom: 1,
                borderColor: 1,
                borderLeft: 1,
                borderRight: 1,
                borderTop: 1,
                borderWidth: 1,
                margin: 1,
                padding: 1
            };

        $.each(
            ["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"],
            function(_, prop) {
                $.fx.step[prop] = function(fx) {
                    if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                        jQuery.style(fx.elem, prop, fx.end);
                        fx.setAttr = true;
                    }
                };
            }
        );

        function getElementStyles(elem) {
            var key, len,
                style = elem.ownerDocument.defaultView ?
                elem.ownerDocument.defaultView.getComputedStyle(elem, null) :
                elem.currentStyle,
                styles = {};

            if (style && style.length && style[0] && style[style[0]]) {
                len = style.length;
                while (len--) {
                    key = style[len];
                    if (typeof style[key] === "string") {
                        styles[$.camelCase(key)] = style[key];
                    }
                }

                // Support: Opera, IE <9
            } else {
                for (key in style) {
                    if (typeof style[key] === "string") {
                        styles[key] = style[key];
                    }
                }
            }

            return styles;
        }

        function styleDifference(oldStyle, newStyle) {
            var diff = {},
                name, value;

            for (name in newStyle) {
                value = newStyle[name];
                if (oldStyle[name] !== value) {
                    if (!shorthandStyles[name]) {
                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                            diff[name] = value;
                        }
                    }
                }
            }

            return diff;
        }

        // Support: jQuery <1.8
        if (!$.fn.addBack) {
            $.fn.addBack = function(selector) {
                return this.add(selector == null ?
                    this.prevObject : this.prevObject.filter(selector)
                );
            };
        }

        $.effects.animateClass = function(value, duration, easing, callback) {
            var o = $.speed(duration, easing, callback);

            return this.queue(function() {
                var animated = $(this),
                    baseClass = animated.attr("class") || "",
                    applyClassChange,
                    allAnimations = o.children ? animated.find("*").addBack() : animated;

                // Map the animated objects to store the original styles.
                allAnimations = allAnimations.map(function() {
                    var el = $(this);
                    return {
                        el: el,
                        start: getElementStyles(this)
                    };
                });

                // Apply class change
                applyClassChange = function() {
                    $.each(classAnimationActions, function(i, action) {
                        if (value[action]) {
                            animated[action + "Class"](value[action]);
                        }
                    });
                };
                applyClassChange();

                // Map all animated objects again - calculate new styles and diff
                allAnimations = allAnimations.map(function() {
                    this.end = getElementStyles(this.el[0]);
                    this.diff = styleDifference(this.start, this.end);
                    return this;
                });

                // Apply original class
                animated.attr("class", baseClass);

                // Map all animated objects again - this time collecting a promise
                allAnimations = allAnimations.map(function() {
                    var styleInfo = this,
                        dfd = $.Deferred(),
                        opts = $.extend({}, o, {
                            queue: false,
                            complete: function() {
                                dfd.resolve(styleInfo);
                            }
                        });

                    this.el.animate(this.diff, opts);
                    return dfd.promise();
                });

                // Once all animations have completed:
                $.when.apply($, allAnimations.get()).done(function() {

                    // Set the final class
                    applyClassChange();

                    // For each animated element,
                    // clear all css properties that were animated
                    $.each(arguments, function() {
                        var el = this.el;
                        $.each(this.diff, function(key) {
                            el.css(key, "");
                        });
                    });

                    // This is guarnteed to be there if you use jQuery.speed()
                    // it also handles dequeuing the next anim...
                    o.complete.call(animated[0]);
                });
            });
        };

        $.fn.extend({
            addClass: (function(orig) {
                return function(classNames, speed, easing, callback) {
                    return speed ?
                        $.effects.animateClass.call(this, {
                            add: classNames
                        }, speed, easing, callback) :
                        orig.apply(this, arguments);
                };
            })($.fn.addClass),

            removeClass: (function(orig) {
                return function(classNames, speed, easing, callback) {
                    return arguments.length > 1 ?
                        $.effects.animateClass.call(this, {
                            remove: classNames
                        }, speed, easing, callback) :
                        orig.apply(this, arguments);
                };
            })($.fn.removeClass),

            toggleClass: (function(orig) {
                return function(classNames, force, speed, easing, callback) {
                    if (typeof force === "boolean" || force === undefined) {
                        if (!speed) {

                            // Without speed parameter
                            return orig.apply(this, arguments);
                        } else {
                            return $.effects.animateClass.call(this,
                                (force ? {
                                    add: classNames
                                } : {
                                    remove: classNames
                                }),
                                speed, easing, callback);
                        }
                    } else {

                        // Without force parameter
                        return $.effects.animateClass.call(this, {
                            toggle: classNames
                        }, force, speed, easing);
                    }
                };
            })($.fn.toggleClass),

            switchClass: function(remove, add, speed, easing, callback) {
                return $.effects.animateClass.call(this, {
                    add: add,
                    remove: remove
                }, speed, easing, callback);
            }
        });

    })();

    /******************************************************************************/
    /*********************************** EFFECTS **********************************/
    /******************************************************************************/

    (function() {

        if ($.expr && $.expr.filters && $.expr.filters.animated) {
            $.expr.filters.animated = (function(orig) {
                return function(elem) {
                    return !!$(elem).data(dataSpaceAnimated) || orig(elem);
                };
            })($.expr.filters.animated);
        }

        if ($.uiBackCompat !== false) {
            $.extend($.effects, {

                // Saves a set of properties in a data storage
                save: function(element, set) {
                    var i = 0,
                        length = set.length;
                    for (; i < length; i++) {
                        if (set[i] !== null) {
                            element.data(dataSpace + set[i], element[0].style[set[i]]);
                        }
                    }
                },

                // Restores a set of previously saved properties from a data storage
                restore: function(element, set) {
                    var val, i = 0,
                        length = set.length;
                    for (; i < length; i++) {
                        if (set[i] !== null) {
                            val = element.data(dataSpace + set[i]);
                            element.css(set[i], val);
                        }
                    }
                },

                setMode: function(el, mode) {
                    if (mode === "toggle") {
                        mode = el.is(":hidden") ? "show" : "hide";
                    }
                    return mode;
                },

                // Wraps the element around a wrapper that copies position properties
                createWrapper: function(element) {

                    // If the element is already wrapped, return it
                    if (element.parent().is(".ui-effects-wrapper")) {
                        return element.parent();
                    }

                    // Wrap the element
                    var props = {
                            width: element.outerWidth(true),
                            height: element.outerHeight(true),
                            "float": element.css("float")
                        },
                        wrapper = $("<div></div>")
                        .addClass("ui-effects-wrapper")
                        .css({
                            fontSize: "100%",
                            background: "transparent",
                            border: "none",
                            margin: 0,
                            padding: 0
                        }),

                        // Store the size in case width/height are defined in % - Fixes #5245
                        size = {
                            width: element.width(),
                            height: element.height()
                        },
                        active = document.activeElement;

                    // Support: Firefox
                    // Firefox incorrectly exposes anonymous content
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                    try {
                        active.id;
                    } catch (e) {
                        active = document.body;
                    }

                    element.wrap(wrapper);

                    // Fixes #7595 - Elements lose focus when wrapped.
                    if (element[0] === active || $.contains(element[0], active)) {
                        $(active).trigger("focus");
                    }

                    // Hotfix for jQuery 1.4 since some change in wrap() seems to actually
                    // lose the reference to the wrapped element
                    wrapper = element.parent();

                    // Transfer positioning properties to the wrapper
                    if (element.css("position") === "static") {
                        wrapper.css({
                            position: "relative"
                        });
                        element.css({
                            position: "relative"
                        });
                    } else {
                        $.extend(props, {
                            position: element.css("position"),
                            zIndex: element.css("z-index")
                        });
                        $.each(["top", "left", "bottom", "right"], function(i, pos) {
                            props[pos] = element.css(pos);
                            if (isNaN(parseInt(props[pos], 10))) {
                                props[pos] = "auto";
                            }
                        });
                        element.css({
                            position: "relative",
                            top: 0,
                            left: 0,
                            right: "auto",
                            bottom: "auto"
                        });
                    }
                    element.css(size);

                    return wrapper.css(props).show();
                },

                removeWrapper: function(element) {
                    var active = document.activeElement;

                    if (element.parent().is(".ui-effects-wrapper")) {
                        element.parent().replaceWith(element);

                        // Fixes #7595 - Elements lose focus when wrapped.
                        if (element[0] === active || $.contains(element[0], active)) {
                            $(active).trigger("focus");
                        }
                    }

                    return element;
                }
            });
        }

        $.extend($.effects, {
            version: "1.12.1",

            define: function(name, mode, effect) {
                if (!effect) {
                    effect = mode;
                    mode = "effect";
                }

                $.effects.effect[name] = effect;
                $.effects.effect[name].mode = mode;

                return effect;
            },

            scaledDimensions: function(element, percent, direction) {
                if (percent === 0) {
                    return {
                        height: 0,
                        width: 0,
                        outerHeight: 0,
                        outerWidth: 0
                    };
                }

                var x = direction !== "horizontal" ? ((percent || 100) / 100) : 1,
                    y = direction !== "vertical" ? ((percent || 100) / 100) : 1;

                return {
                    height: element.height() * y,
                    width: element.width() * x,
                    outerHeight: element.outerHeight() * y,
                    outerWidth: element.outerWidth() * x
                };

            },

            clipToBox: function(animation) {
                return {
                    width: animation.clip.right - animation.clip.left,
                    height: animation.clip.bottom - animation.clip.top,
                    left: animation.clip.left,
                    top: animation.clip.top
                };
            },

            // Injects recently queued functions to be first in line (after "inprogress")
            unshift: function(element, queueLength, count) {
                var queue = element.queue();

                if (queueLength > 1) {
                    queue.splice.apply(queue, [1, 0].concat(queue.splice(queueLength, count)));
                }
                element.dequeue();
            },

            saveStyle: function(element) {
                element.data(dataSpaceStyle, element[0].style.cssText);
            },

            restoreStyle: function(element) {
                element[0].style.cssText = element.data(dataSpaceStyle) || "";
                element.removeData(dataSpaceStyle);
            },

            mode: function(element, mode) {
                var hidden = element.is(":hidden");

                if (mode === "toggle") {
                    mode = hidden ? "show" : "hide";
                }
                if (hidden ? mode === "hide" : mode === "show") {
                    mode = "none";
                }
                return mode;
            },

            // Translates a [top,left] array into a baseline value
            getBaseline: function(origin, original) {
                var y, x;

                switch (origin[0]) {
                    case "top":
                        y = 0;
                        break;
                    case "middle":
                        y = 0.5;
                        break;
                    case "bottom":
                        y = 1;
                        break;
                    default:
                        y = origin[0] / original.height;
                }

                switch (origin[1]) {
                    case "left":
                        x = 0;
                        break;
                    case "center":
                        x = 0.5;
                        break;
                    case "right":
                        x = 1;
                        break;
                    default:
                        x = origin[1] / original.width;
                }

                return {
                    x: x,
                    y: y
                };
            },

            // Creates a placeholder element so that the original element can be made absolute
            createPlaceholder: function(element) {
                var placeholder,
                    cssPosition = element.css("position"),
                    position = element.position();

                // Lock in margins first to account for form elements, which
                // will change margin if you explicitly set height
                // see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380
                // Support: Safari
                element.css({
                        marginTop: element.css("marginTop"),
                        marginBottom: element.css("marginBottom"),
                        marginLeft: element.css("marginLeft"),
                        marginRight: element.css("marginRight")
                    })
                    .outerWidth(element.outerWidth())
                    .outerHeight(element.outerHeight());

                if (/^(static|relative)/.test(cssPosition)) {
                    cssPosition = "absolute";

                    placeholder = $("<" + element[0].nodeName + ">").insertAfter(element).css({

                            // Convert inline to inline block to account for inline elements
                            // that turn to inline block based on content (like img)
                            display: /^(inline|ruby)/.test(element.css("display")) ?
                                "inline-block" : "block",
                            visibility: "hidden",

                            // Margins need to be set to account for margin collapse
                            marginTop: element.css("marginTop"),
                            marginBottom: element.css("marginBottom"),
                            marginLeft: element.css("marginLeft"),
                            marginRight: element.css("marginRight"),
                            "float": element.css("float")
                        })
                        .outerWidth(element.outerWidth())
                        .outerHeight(element.outerHeight())
                        .addClass("ui-effects-placeholder");

                    element.data(dataSpace + "placeholder", placeholder);
                }

                element.css({
                    position: cssPosition,
                    left: position.left,
                    top: position.top
                });

                return placeholder;
            },

            removePlaceholder: function(element) {
                var dataKey = dataSpace + "placeholder",
                    placeholder = element.data(dataKey);

                if (placeholder) {
                    placeholder.remove();
                    element.removeData(dataKey);
                }
            },

            // Removes a placeholder if it exists and restores
            // properties that were modified during placeholder creation
            cleanUp: function(element) {
                $.effects.restoreStyle(element);
                $.effects.removePlaceholder(element);
            },

            setTransition: function(element, list, factor, value) {
                value = value || {};
                $.each(list, function(i, x) {
                    var unit = element.cssUnit(x);
                    if (unit[0] > 0) {
                        value[x] = unit[0] * factor + unit[1];
                    }
                });
                return value;
            }
        });

        // Return an effect options object for the given parameters:
        function _normalizeArguments(effect, options, speed, callback) {

            // Allow passing all options as the first parameter
            if ($.isPlainObject(effect)) {
                options = effect;
                effect = effect.effect;
            }

            // Convert to an object
            effect = {
                effect: effect
            };

            // Catch (effect, null, ...)
            if (options == null) {
                options = {};
            }

            // Catch (effect, callback)
            if ($.isFunction(options)) {
                callback = options;
                speed = null;
                options = {};
            }

            // Catch (effect, speed, ?)
            if (typeof options === "number" || $.fx.speeds[options]) {
                callback = speed;
                speed = options;
                options = {};
            }

            // Catch (effect, options, callback)
            if ($.isFunction(speed)) {
                callback = speed;
                speed = null;
            }

            // Add options to effect
            if (options) {
                $.extend(effect, options);
            }

            speed = speed || options.duration;
            effect.duration = $.fx.off ? 0 :
                typeof speed === "number" ? speed :
                speed in $.fx.speeds ? $.fx.speeds[speed] :
                $.fx.speeds._default;

            effect.complete = callback || options.complete;

            return effect;
        }

        function standardAnimationOption(option) {

            // Valid standard speeds (nothing, number, named speed)
            if (!option || typeof option === "number" || $.fx.speeds[option]) {
                return true;
            }

            // Invalid strings - treat as "normal" speed
            if (typeof option === "string" && !$.effects.effect[option]) {
                return true;
            }

            // Complete callback
            if ($.isFunction(option)) {
                return true;
            }

            // Options hash (but not naming an effect)
            if (typeof option === "object" && !option.effect) {
                return true;
            }

            // Didn't match any standard API
            return false;
        }

        $.fn.extend({
            effect: function( /* effect, options, speed, callback */ ) {
                var args = _normalizeArguments.apply(this, arguments),
                    effectMethod = $.effects.effect[args.effect],
                    defaultMode = effectMethod.mode,
                    queue = args.queue,
                    queueName = queue || "fx",
                    complete = args.complete,
                    mode = args.mode,
                    modes = [],
                    prefilter = function(next) {
                        var el = $(this),
                            normalizedMode = $.effects.mode(el, mode) || defaultMode;

                        // Sentinel for duck-punching the :animated psuedo-selector
                        el.data(dataSpaceAnimated, true);

                        // Save effect mode for later use,
                        // we can't just call $.effects.mode again later,
                        // as the .show() below destroys the initial state
                        modes.push(normalizedMode);

                        // See $.uiBackCompat inside of run() for removal of defaultMode in 1.13
                        if (defaultMode && (normalizedMode === "show" ||
                                (normalizedMode === defaultMode && normalizedMode === "hide"))) {
                            el.show();
                        }

                        if (!defaultMode || normalizedMode !== "none") {
                            $.effects.saveStyle(el);
                        }

                        if ($.isFunction(next)) {
                            next();
                        }
                    };

                if ($.fx.off || !effectMethod) {

                    // Delegate to the original method (e.g., .show()) if possible
                    if (mode) {
                        return this[mode](args.duration, complete);
                    } else {
                        return this.each(function() {
                            if (complete) {
                                complete.call(this);
                            }
                        });
                    }
                }

                function run(next) {
                    var elem = $(this);

                    function cleanup() {
                        elem.removeData(dataSpaceAnimated);

                        $.effects.cleanUp(elem);

                        if (args.mode === "hide") {
                            elem.hide();
                        }

                        done();
                    }

                    function done() {
                        if ($.isFunction(complete)) {
                            complete.call(elem[0]);
                        }

                        if ($.isFunction(next)) {
                            next();
                        }
                    }

                    // Override mode option on a per element basis,
                    // as toggle can be either show or hide depending on element state
                    args.mode = modes.shift();

                    if ($.uiBackCompat !== false && !defaultMode) {
                        if (elem.is(":hidden") ? mode === "hide" : mode === "show") {

                            // Call the core method to track "olddisplay" properly
                            elem[mode]();
                            done();
                        } else {
                            effectMethod.call(elem[0], args, done);
                        }
                    } else {
                        if (args.mode === "none") {

                            // Call the core method to track "olddisplay" properly
                            elem[mode]();
                            done();
                        } else {
                            effectMethod.call(elem[0], args, cleanup);
                        }
                    }
                }

                // Run prefilter on all elements first to ensure that
                // any showing or hiding happens before placeholder creation,
                // which ensures that any layout changes are correctly captured.
                return queue === false ?
                    this.each(prefilter).each(run) :
                    this.queue(queueName, prefilter).queue(queueName, run);
            },

            show: (function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "show";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.show),

            hide: (function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "hide";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.hide),

            toggle: (function(orig) {
                return function(option) {
                    if (standardAnimationOption(option) || typeof option === "boolean") {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "toggle";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.toggle),

            cssUnit: function(key) {
                var style = this.css(key),
                    val = [];

                $.each(["em", "px", "%", "pt"], function(i, unit) {
                    if (style.indexOf(unit) > 0) {
                        val = [parseFloat(style), unit];
                    }
                });
                return val;
            },

            cssClip: function(clipObj) {
                if (clipObj) {
                    return this.css("clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " +
                        clipObj.bottom + "px " + clipObj.left + "px)");
                }
                return parseClip(this.css("clip"), this);
            },

            transfer: function(options, done) {
                var element = $(this),
                    target = $(options.to),
                    targetFixed = target.css("position") === "fixed",
                    body = $("body"),
                    fixTop = targetFixed ? body.scrollTop() : 0,
                    fixLeft = targetFixed ? body.scrollLeft() : 0,
                    endPosition = target.offset(),
                    animation = {
                        top: endPosition.top - fixTop,
                        left: endPosition.left - fixLeft,
                        height: target.innerHeight(),
                        width: target.innerWidth()
                    },
                    startPosition = element.offset(),
                    transfer = $("<div class='ui-effects-transfer'></div>")
                    .appendTo("body")
                    .addClass(options.className)
                    .css({
                        top: startPosition.top - fixTop,
                        left: startPosition.left - fixLeft,
                        height: element.innerHeight(),
                        width: element.innerWidth(),
                        position: targetFixed ? "fixed" : "absolute"
                    })
                    .animate(animation, options.duration, options.easing, function() {
                        transfer.remove();
                        if ($.isFunction(done)) {
                            done();
                        }
                    });
            }
        });

        function parseClip(str, element) {
            var outerWidth = element.outerWidth(),
                outerHeight = element.outerHeight(),
                clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
                values = clipRegex.exec(str) || ["", 0, outerWidth, outerHeight, 0];

            return {
                top: parseFloat(values[1]) || 0,
                right: values[2] === "auto" ? outerWidth : parseFloat(values[2]),
                bottom: values[3] === "auto" ? outerHeight : parseFloat(values[3]),
                left: parseFloat(values[4]) || 0
            };
        }

        $.fx.step.clip = function(fx) {
            if (!fx.clipInit) {
                fx.start = $(fx.elem).cssClip();
                if (typeof fx.end === "string") {
                    fx.end = parseClip(fx.end, fx.elem);
                }
                fx.clipInit = true;
            }

            $(fx.elem).cssClip({
                top: fx.pos * (fx.end.top - fx.start.top) + fx.start.top,
                right: fx.pos * (fx.end.right - fx.start.right) + fx.start.right,
                bottom: fx.pos * (fx.end.bottom - fx.start.bottom) + fx.start.bottom,
                left: fx.pos * (fx.end.left - fx.start.left) + fx.start.left
            });
        };

    })();

    /******************************************************************************/
    /*********************************** EASING ***********************************/
    /******************************************************************************/

    (function() {

        // Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

        var baseEasings = {};

        $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function(i, name) {
            baseEasings[name] = function(p) {
                return Math.pow(p, i + 2);
            };
        });

        $.extend(baseEasings, {
            Sine: function(p) {
                return 1 - Math.cos(p * Math.PI / 2);
            },
            Circ: function(p) {
                return 1 - Math.sqrt(1 - p * p);
            },
            Elastic: function(p) {
                return p === 0 || p === 1 ? p :
                    -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
            },
            Back: function(p) {
                return p * p * (3 * p - 2);
            },
            Bounce: function(p) {
                var pow2,
                    bounce = 4;

                while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
                return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
            }
        });

        $.each(baseEasings, function(name, easeIn) {
            $.easing["easeIn" + name] = easeIn;
            $.easing["easeOut" + name] = function(p) {
                return 1 - easeIn(1 - p);
            };
            $.easing["easeInOut" + name] = function(p) {
                return p < 0.5 ?
                    easeIn(p * 2) / 2 :
                    1 - easeIn(p * -2 + 2) / 2;
            };
        });

    })();

    var effect = $.effects;


    /*!
     * jQuery UI Effects Blind 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Blind Effect
    //>>group: Effects
    //>>description: Blinds the element.
    //>>docs: http://api.jqueryui.com/blind-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectBlind = $.effects.define("blind", "hide", function(options, done) {
        var map = {
                up: ["bottom", "top"],
                vertical: ["bottom", "top"],
                down: ["top", "bottom"],
                left: ["right", "left"],
                horizontal: ["right", "left"],
                right: ["left", "right"]
            },
            element = $(this),
            direction = options.direction || "up",
            start = element.cssClip(),
            animate = {
                clip: $.extend({}, start)
            },
            placeholder = $.effects.createPlaceholder(element);

        animate.clip[map[direction][0]] = animate.clip[map[direction][1]];

        if (options.mode === "show") {
            element.cssClip(animate.clip);
            if (placeholder) {
                placeholder.css($.effects.clipToBox(animate));
            }

            animate.clip = start;
        }

        if (placeholder) {
            placeholder.animate($.effects.clipToBox(animate), options.duration, options.easing);
        }

        element.animate(animate, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });


    /*!
     * jQuery UI Effects Bounce 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Bounce Effect
    //>>group: Effects
    //>>description: Bounces an element horizontally or vertically n times.
    //>>docs: http://api.jqueryui.com/bounce-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectBounce = $.effects.define("bounce", function(options, done) {
        var upAnim, downAnim, refValue,
            element = $(this),

            // Defaults:
            mode = options.mode,
            hide = mode === "hide",
            show = mode === "show",
            direction = options.direction || "up",
            distance = options.distance,
            times = options.times || 5,

            // Number of internal animations
            anims = times * 2 + (show || hide ? 1 : 0),
            speed = options.duration / anims,
            easing = options.easing,

            // Utility:
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            motion = (direction === "up" || direction === "left"),
            i = 0,

            queuelen = element.queue().length;

        $.effects.createPlaceholder(element);

        refValue = element.css(ref);

        // Default distance for the BIGGEST bounce is the outer Distance / 3
        if (!distance) {
            distance = element[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
        }

        if (show) {
            downAnim = {
                opacity: 1
            };
            downAnim[ref] = refValue;

            // If we are showing, force opacity 0 and set the initial position
            // then do the "first" animation
            element
                .css("opacity", 0)
                .css(ref, motion ? -distance * 2 : distance * 2)
                .animate(downAnim, speed, easing);
        }

        // Start at the smallest distance if we are hiding
        if (hide) {
            distance = distance / Math.pow(2, times - 1);
        }

        downAnim = {};
        downAnim[ref] = refValue;

        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
        for (; i < times; i++) {
            upAnim = {};
            upAnim[ref] = (motion ? "-=" : "+=") + distance;

            element
                .animate(upAnim, speed, easing)
                .animate(downAnim, speed, easing);

            distance = hide ? distance * 2 : distance / 2;
        }

        // Last Bounce when Hiding
        if (hide) {
            upAnim = {
                opacity: 0
            };
            upAnim[ref] = (motion ? "-=" : "+=") + distance;

            element.animate(upAnim, speed, easing);
        }

        element.queue(done);

        $.effects.unshift(element, queuelen, anims + 1);
    });


    /*!
     * jQuery UI Effects Clip 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Clip Effect
    //>>group: Effects
    //>>description: Clips the element on and off like an old TV.
    //>>docs: http://api.jqueryui.com/clip-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectClip = $.effects.define("clip", "hide", function(options, done) {
        var start,
            animate = {},
            element = $(this),
            direction = options.direction || "vertical",
            both = direction === "both",
            horizontal = both || direction === "horizontal",
            vertical = both || direction === "vertical";

        start = element.cssClip();
        animate.clip = {
            top: vertical ? (start.bottom - start.top) / 2 : start.top,
            right: horizontal ? (start.right - start.left) / 2 : start.right,
            bottom: vertical ? (start.bottom - start.top) / 2 : start.bottom,
            left: horizontal ? (start.right - start.left) / 2 : start.left
        };

        $.effects.createPlaceholder(element);

        if (options.mode === "show") {
            element.cssClip(animate.clip);
            animate.clip = start;
        }

        element.animate(animate, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });

    });


    /*!
     * jQuery UI Effects Drop 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Drop Effect
    //>>group: Effects
    //>>description: Moves an element in one direction and hides it at the same time.
    //>>docs: http://api.jqueryui.com/drop-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectDrop = $.effects.define("drop", "hide", function(options, done) {

        var distance,
            element = $(this),
            mode = options.mode,
            show = mode === "show",
            direction = options.direction || "left",
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            motion = (direction === "up" || direction === "left") ? "-=" : "+=",
            oppositeMotion = (motion === "+=") ? "-=" : "+=",
            animation = {
                opacity: 0
            };

        $.effects.createPlaceholder(element);

        distance = options.distance ||
            element[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;

        animation[ref] = motion + distance;

        if (show) {
            element.css(animation);

            animation[ref] = oppositeMotion + distance;
            animation.opacity = 1;
        }

        // Animate
        element.animate(animation, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });


    /*!
     * jQuery UI Effects Explode 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Explode Effect
    //>>group: Effects
    // jscs:disable maximumLineLength
    //>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/explode-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectExplode = $.effects.define("explode", "hide", function(options, done) {

        var i, j, left, top, mx, my,
            rows = options.pieces ? Math.round(Math.sqrt(options.pieces)) : 3,
            cells = rows,
            element = $(this),
            mode = options.mode,
            show = mode === "show",

            // Show and then visibility:hidden the element before calculating offset
            offset = element.show().css("visibility", "hidden").offset(),

            // Width and height of a piece
            width = Math.ceil(element.outerWidth() / cells),
            height = Math.ceil(element.outerHeight() / rows),
            pieces = [];

        // Children animate complete:
        function childComplete() {
            pieces.push(this);
            if (pieces.length === rows * cells) {
                animComplete();
            }
        }

        // Clone the element for each row and cell.
        for (i = 0; i < rows; i++) { // ===>
            top = offset.top + i * height;
            my = i - (rows - 1) / 2;

            for (j = 0; j < cells; j++) { // |||
                left = offset.left + j * width;
                mx = j - (cells - 1) / 2;

                // Create a clone of the now hidden main element that will be absolute positioned
                // within a wrapper div off the -left and -top equal to size of our pieces
                element
                    .clone()
                    .appendTo("body")
                    .wrap("<div></div>")
                    .css({
                        position: "absolute",
                        visibility: "visible",
                        left: -j * width,
                        top: -i * height
                    })

                    // Select the wrapper - make it overflow: hidden and absolute positioned based on
                    // where the original was located +left and +top equal to the size of pieces
                    .parent()
                    .addClass("ui-effects-explode")
                    .css({
                        position: "absolute",
                        overflow: "hidden",
                        width: width,
                        height: height,
                        left: left + (show ? mx * width : 0),
                        top: top + (show ? my * height : 0),
                        opacity: show ? 0 : 1
                    })
                    .animate({
                        left: left + (show ? 0 : mx * width),
                        top: top + (show ? 0 : my * height),
                        opacity: show ? 1 : 0
                    }, options.duration || 500, options.easing, childComplete);
            }
        }

        function animComplete() {
            element.css({
                visibility: "visible"
            });
            $(pieces).remove();
            done();
        }
    });


    /*!
     * jQuery UI Effects Fade 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Fade Effect
    //>>group: Effects
    //>>description: Fades the element.
    //>>docs: http://api.jqueryui.com/fade-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectFade = $.effects.define("fade", "toggle", function(options, done) {
        var show = options.mode === "show";

        $(this)
            .css("opacity", show ? 0 : 1)
            .animate({
                opacity: show ? 1 : 0
            }, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            });
    });


    /*!
     * jQuery UI Effects Fold 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Fold Effect
    //>>group: Effects
    //>>description: Folds an element first horizontally and then vertically.
    //>>docs: http://api.jqueryui.com/fold-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectFold = $.effects.define("fold", "hide", function(options, done) {

        // Create element
        var element = $(this),
            mode = options.mode,
            show = mode === "show",
            hide = mode === "hide",
            size = options.size || 15,
            percent = /([0-9]+)%/.exec(size),
            horizFirst = !!options.horizFirst,
            ref = horizFirst ? ["right", "bottom"] : ["bottom", "right"],
            duration = options.duration / 2,

            placeholder = $.effects.createPlaceholder(element),

            start = element.cssClip(),
            animation1 = {
                clip: $.extend({}, start)
            },
            animation2 = {
                clip: $.extend({}, start)
            },

            distance = [start[ref[0]], start[ref[1]]],

            queuelen = element.queue().length;

        if (percent) {
            size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
        }
        animation1.clip[ref[0]] = size;
        animation2.clip[ref[0]] = size;
        animation2.clip[ref[1]] = 0;

        if (show) {
            element.cssClip(animation2.clip);
            if (placeholder) {
                placeholder.css($.effects.clipToBox(animation2));
            }

            animation2.clip = start;
        }

        // Animate
        element
            .queue(function(next) {
                if (placeholder) {
                    placeholder
                        .animate($.effects.clipToBox(animation1), duration, options.easing)
                        .animate($.effects.clipToBox(animation2), duration, options.easing);
                }

                next();
            })
            .animate(animation1, duration, options.easing)
            .animate(animation2, duration, options.easing)
            .queue(done);

        $.effects.unshift(element, queuelen, 4);
    });


    /*!
     * jQuery UI Effects Highlight 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Highlight Effect
    //>>group: Effects
    //>>description: Highlights the background of an element in a defined color for a custom duration.
    //>>docs: http://api.jqueryui.com/highlight-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectHighlight = $.effects.define("highlight", "show", function(options, done) {
        var element = $(this),
            animation = {
                backgroundColor: element.css("backgroundColor")
            };

        if (options.mode === "hide") {
            animation.opacity = 0;
        }

        $.effects.saveStyle(element);

        element
            .css({
                backgroundImage: "none",
                backgroundColor: options.color || "#ffff99"
            })
            .animate(animation, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            });
    });


    /*!
     * jQuery UI Effects Size 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Size Effect
    //>>group: Effects
    //>>description: Resize an element to a specified width and height.
    //>>docs: http://api.jqueryui.com/size-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectSize = $.effects.define("size", function(options, done) {

        // Create element
        var baseline, factor, temp,
            element = $(this),

            // Copy for children
            cProps = ["fontSize"],
            vProps = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
            hProps = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],

            // Set options
            mode = options.mode,
            restore = mode !== "effect",
            scale = options.scale || "both",
            origin = options.origin || ["middle", "center"],
            position = element.css("position"),
            pos = element.position(),
            original = $.effects.scaledDimensions(element),
            from = options.from || original,
            to = options.to || $.effects.scaledDimensions(element, 0);

        $.effects.createPlaceholder(element);

        if (mode === "show") {
            temp = from;
            from = to;
            to = temp;
        }

        // Set scaling factor
        factor = {
            from: {
                y: from.height / original.height,
                x: from.width / original.width
            },
            to: {
                y: to.height / original.height,
                x: to.width / original.width
            }
        };

        // Scale the css box
        if (scale === "box" || scale === "both") {

            // Vertical props scaling
            if (factor.from.y !== factor.to.y) {
                from = $.effects.setTransition(element, vProps, factor.from.y, from);
                to = $.effects.setTransition(element, vProps, factor.to.y, to);
            }

            // Horizontal props scaling
            if (factor.from.x !== factor.to.x) {
                from = $.effects.setTransition(element, hProps, factor.from.x, from);
                to = $.effects.setTransition(element, hProps, factor.to.x, to);
            }
        }

        // Scale the content
        if (scale === "content" || scale === "both") {

            // Vertical props scaling
            if (factor.from.y !== factor.to.y) {
                from = $.effects.setTransition(element, cProps, factor.from.y, from);
                to = $.effects.setTransition(element, cProps, factor.to.y, to);
            }
        }

        // Adjust the position properties based on the provided origin points
        if (origin) {
            baseline = $.effects.getBaseline(origin, original);
            from.top = (original.outerHeight - from.outerHeight) * baseline.y + pos.top;
            from.left = (original.outerWidth - from.outerWidth) * baseline.x + pos.left;
            to.top = (original.outerHeight - to.outerHeight) * baseline.y + pos.top;
            to.left = (original.outerWidth - to.outerWidth) * baseline.x + pos.left;
        }
        element.css(from);

        // Animate the children if desired
        if (scale === "content" || scale === "both") {

            vProps = vProps.concat(["marginTop", "marginBottom"]).concat(cProps);
            hProps = hProps.concat(["marginLeft", "marginRight"]);

            // Only animate children with width attributes specified
            // TODO: is this right? should we include anything with css width specified as well
            element.find("*[width]").each(function() {
                var child = $(this),
                    childOriginal = $.effects.scaledDimensions(child),
                    childFrom = {
                        height: childOriginal.height * factor.from.y,
                        width: childOriginal.width * factor.from.x,
                        outerHeight: childOriginal.outerHeight * factor.from.y,
                        outerWidth: childOriginal.outerWidth * factor.from.x
                    },
                    childTo = {
                        height: childOriginal.height * factor.to.y,
                        width: childOriginal.width * factor.to.x,
                        outerHeight: childOriginal.height * factor.to.y,
                        outerWidth: childOriginal.width * factor.to.x
                    };

                // Vertical props scaling
                if (factor.from.y !== factor.to.y) {
                    childFrom = $.effects.setTransition(child, vProps, factor.from.y, childFrom);
                    childTo = $.effects.setTransition(child, vProps, factor.to.y, childTo);
                }

                // Horizontal props scaling
                if (factor.from.x !== factor.to.x) {
                    childFrom = $.effects.setTransition(child, hProps, factor.from.x, childFrom);
                    childTo = $.effects.setTransition(child, hProps, factor.to.x, childTo);
                }

                if (restore) {
                    $.effects.saveStyle(child);
                }

                // Animate children
                child.css(childFrom);
                child.animate(childTo, options.duration, options.easing, function() {

                    // Restore children
                    if (restore) {
                        $.effects.restoreStyle(child);
                    }
                });
            });
        }

        // Animate
        element.animate(to, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: function() {

                var offset = element.offset();

                if (to.opacity === 0) {
                    element.css("opacity", from.opacity);
                }

                if (!restore) {
                    element
                        .css("position", position === "static" ? "relative" : position)
                        .offset(offset);

                    // Need to save style here so that automatic style restoration
                    // doesn't restore to the original styles from before the animation.
                    $.effects.saveStyle(element);
                }

                done();
            }
        });

    });


    /*!
     * jQuery UI Effects Scale 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Scale Effect
    //>>group: Effects
    //>>description: Grows or shrinks an element and its content.
    //>>docs: http://api.jqueryui.com/scale-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectScale = $.effects.define("scale", function(options, done) {

        // Create element
        var el = $(this),
            mode = options.mode,
            percent = parseInt(options.percent, 10) ||
            (parseInt(options.percent, 10) === 0 ? 0 : (mode !== "effect" ? 0 : 100)),

            newOptions = $.extend(true, {
                from: $.effects.scaledDimensions(el),
                to: $.effects.scaledDimensions(el, percent, options.direction || "both"),
                origin: options.origin || ["middle", "center"]
            }, options);

        // Fade option to support puff
        if (options.fade) {
            newOptions.from.opacity = 1;
            newOptions.to.opacity = 0;
        }

        $.effects.effect.size.call(this, newOptions, done);
    });


    /*!
     * jQuery UI Effects Puff 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Puff Effect
    //>>group: Effects
    //>>description: Creates a puff effect by scaling the element up and hiding it at the same time.
    //>>docs: http://api.jqueryui.com/puff-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectPuff = $.effects.define("puff", "hide", function(options, done) {
        var newOptions = $.extend(true, {}, options, {
            fade: true,
            percent: parseInt(options.percent, 10) || 150
        });

        $.effects.effect.scale.call(this, newOptions, done);
    });


    /*!
     * jQuery UI Effects Pulsate 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Pulsate Effect
    //>>group: Effects
    //>>description: Pulsates an element n times by changing the opacity to zero and back.
    //>>docs: http://api.jqueryui.com/pulsate-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectPulsate = $.effects.define("pulsate", "show", function(options, done) {
        var element = $(this),
            mode = options.mode,
            show = mode === "show",
            hide = mode === "hide",
            showhide = show || hide,

            // Showing or hiding leaves off the "last" animation
            anims = ((options.times || 5) * 2) + (showhide ? 1 : 0),
            duration = options.duration / anims,
            animateTo = 0,
            i = 1,
            queuelen = element.queue().length;

        if (show || !element.is(":visible")) {
            element.css("opacity", 0).show();
            animateTo = 1;
        }

        // Anims - 1 opacity "toggles"
        for (; i < anims; i++) {
            element.animate({
                opacity: animateTo
            }, duration, options.easing);
            animateTo = 1 - animateTo;
        }

        element.animate({
            opacity: animateTo
        }, duration, options.easing);

        element.queue(done);

        $.effects.unshift(element, queuelen, anims + 1);
    });


    /*!
     * jQuery UI Effects Shake 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Shake Effect
    //>>group: Effects
    //>>description: Shakes an element horizontally or vertically n times.
    //>>docs: http://api.jqueryui.com/shake-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectShake = $.effects.define("shake", function(options, done) {

        var i = 1,
            element = $(this),
            direction = options.direction || "left",
            distance = options.distance || 20,
            times = options.times || 3,
            anims = times * 2 + 1,
            speed = Math.round(options.duration / anims),
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            positiveMotion = (direction === "up" || direction === "left"),
            animation = {},
            animation1 = {},
            animation2 = {},

            queuelen = element.queue().length;

        $.effects.createPlaceholder(element);

        // Animation
        animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
        animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
        animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;

        // Animate
        element.animate(animation, speed, options.easing);

        // Shakes
        for (; i < times; i++) {
            element
                .animate(animation1, speed, options.easing)
                .animate(animation2, speed, options.easing);
        }

        element
            .animate(animation1, speed, options.easing)
            .animate(animation, speed / 2, options.easing)
            .queue(done);

        $.effects.unshift(element, queuelen, anims + 1);
    });


    /*!
     * jQuery UI Effects Slide 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Slide Effect
    //>>group: Effects
    //>>description: Slides an element in and out of the viewport.
    //>>docs: http://api.jqueryui.com/slide-effect/
    //>>demos: http://jqueryui.com/effect/



    var effectsEffectSlide = $.effects.define("slide", "show", function(options, done) {
        var startClip, startRef,
            element = $(this),
            map = {
                up: ["bottom", "top"],
                down: ["top", "bottom"],
                left: ["right", "left"],
                right: ["left", "right"]
            },
            mode = options.mode,
            direction = options.direction || "left",
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            positiveMotion = (direction === "up" || direction === "left"),
            distance = options.distance ||
            element[ref === "top" ? "outerHeight" : "outerWidth"](true),
            animation = {};

        $.effects.createPlaceholder(element);

        startClip = element.cssClip();
        startRef = element.position()[ref];

        // Define hide animation
        animation[ref] = (positiveMotion ? -1 : 1) * distance + startRef;
        animation.clip = element.cssClip();
        animation.clip[map[direction][1]] = animation.clip[map[direction][0]];

        // Reverse the animation if we're showing
        if (mode === "show") {
            element.cssClip(animation.clip);
            element.css(ref, animation[ref]);
            animation.clip = startClip;
            animation[ref] = startRef;
        }

        // Actually animate
        element.animate(animation, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });


    /*!
     * jQuery UI Effects Transfer 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Transfer Effect
    //>>group: Effects
    //>>description: Displays a transfer effect from one element to another.
    //>>docs: http://api.jqueryui.com/transfer-effect/
    //>>demos: http://jqueryui.com/effect/



    var effect;
    if ($.uiBackCompat !== false) {
        effect = $.effects.define("transfer", function(options, done) {
            $(this).transfer(options, done);
        });
    }
    var effectsEffectTransfer = effect;


    /*!
     * jQuery UI Focusable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: :focusable Selector
    //>>group: Core
    //>>description: Selects elements which can be focused.
    //>>docs: http://api.jqueryui.com/focusable-selector/



    // Selectors
    $.ui.focusable = function(element, hasTabindex) {
        var map, mapName, img, focusableIfVisible, fieldset,
            nodeName = element.nodeName.toLowerCase();

        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap='#" + mapName + "']");
            return img.length > 0 && img.is(":visible");
        }

        if (/^(input|select|textarea|button|object)$/.test(nodeName)) {
            focusableIfVisible = !element.disabled;

            if (focusableIfVisible) {

                // Form controls within a disabled fieldset are disabled.
                // However, controls within the fieldset's legend do not get disabled.
                // Since controls generally aren't placed inside legends, we skip
                // this portion of the check.
                fieldset = $(element).closest("fieldset")[0];
                if (fieldset) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ("a" === nodeName) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }

        return focusableIfVisible && $(element).is(":visible") && visible($(element));
    };

    // Support: IE 8 only
    // IE 8 doesn't resolve inherit to visible/hidden for computed values
    function visible(element) {
        var visibility = element.css("visibility");
        while (visibility === "inherit") {
            element = element.parent();
            visibility = element.css("visibility");
        }
        return visibility !== "hidden";
    }

    $.extend($.expr[":"], {
        focusable: function(element) {
            return $.ui.focusable(element, $.attr(element, "tabindex") != null);
        }
    });

    var focusable = $.ui.focusable;




    // Support: IE8 Only
    // IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
    // with a string, so we need to find the proper form.
    var form = $.fn.form = function() {
        return typeof this[0].form === "string" ? this.closest("form") : $(this[0].form);
    };


    /*!
     * jQuery UI Form Reset Mixin 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Form Reset Mixin
    //>>group: Core
    //>>description: Refresh input widgets when their form is reset
    //>>docs: http://api.jqueryui.com/form-reset-mixin/



    var formResetMixin = $.ui.formResetMixin = {
        _formResetHandler: function() {
            var form = $(this);

            // Wait for the form reset to actually happen before refreshing
            setTimeout(function() {
                var instances = form.data("ui-form-reset-instances");
                $.each(instances, function() {
                    this.refresh();
                });
            });
        },

        _bindFormResetHandler: function() {
            this.form = this.element.form();
            if (!this.form.length) {
                return;
            }

            var instances = this.form.data("ui-form-reset-instances") || [];
            if (!instances.length) {

                // We don't use _on() here because we use a single event handler per form
                this.form.on("reset.ui-form-reset", this._formResetHandler);
            }
            instances.push(this);
            this.form.data("ui-form-reset-instances", instances);
        },

        _unbindFormResetHandler: function() {
            if (!this.form.length) {
                return;
            }

            var instances = this.form.data("ui-form-reset-instances");
            instances.splice($.inArray(this, instances), 1);
            if (instances.length) {
                this.form.data("ui-form-reset-instances", instances);
            } else {
                this.form
                    .removeData("ui-form-reset-instances")
                    .off("reset.ui-form-reset");
            }
        }
    };


    /*!
     * jQuery UI Support for jQuery core 1.7.x 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     */

    //>>label: jQuery 1.7 Support
    //>>group: Core
    //>>description: Support version 1.7.x of jQuery core



    // Support: jQuery 1.7 only
    // Not a great way to check versions, but since we only support 1.7+ and only
    // need to detect <1.8, this is a simple check that should suffice. Checking
    // for "1.7." would be a bit safer, but the version string is 1.7, not 1.7.0
    // and we'll never reach 1.70.0 (if we do, we certainly won't be supporting
    // 1.7 anymore). See #11197 for why we're not using feature detection.
    if ($.fn.jquery.substring(0, 3) === "1.7") {

        // Setters for .innerWidth(), .innerHeight(), .outerWidth(), .outerHeight()
        // Unlike jQuery Core 1.8+, these only support numeric values to set the
        // dimensions in pixels
        $.each(["Width", "Height"], function(i, name) {
            var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };

            function reduce(elem, size, border, margin) {
                $.each(side, function() {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }

            $.fn["inner" + name] = function(size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }

                return this.each(function() {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };

            $.fn["outer" + name] = function(size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }

                return this.each(function() {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });

        $.fn.addBack = function(selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        };
    }

    ;
    /*!
     * jQuery UI Keycode 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Keycode
    //>>group: Core
    //>>description: Provide keycodes as keynames
    //>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


    var keycode = $.ui.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    };




    // Internal use only
    var escapeSelector = $.ui.escapeSelector = (function() {
        var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
        return function(selector) {
            return selector.replace(selectorEscape, "\\$1");
        };
    })();


    /*!
     * jQuery UI Labels 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: labels
    //>>group: Core
    //>>description: Find all the labels associated with a given input
    //>>docs: http://api.jqueryui.com/labels/



    var labels = $.fn.labels = function() {
        var ancestor, selector, id, labels, ancestors;

        // Check control.labels first
        if (this[0].labels && this[0].labels.length) {
            return this.pushStack(this[0].labels);
        }

        // Support: IE <= 11, FF <= 37, Android <= 2.3 only
        // Above browsers do not support control.labels. Everything below is to support them
        // as well as document fragments. control.labels does not work on document fragments
        labels = this.eq(0).parents("label");

        // Look for the label based on the id
        id = this.attr("id");
        if (id) {

            // We don't search against the document in case the element
            // is disconnected from the DOM
            ancestor = this.eq(0).parents().last();

            // Get a full set of top level ancestors
            ancestors = ancestor.add(ancestor.length ? ancestor.siblings() : this.siblings());

            // Create a selector for the label based on the id
            selector = "label[for='" + $.ui.escapeSelector(id) + "']";

            labels = labels.add(ancestors.find(selector).addBack(selector));

        }

        // Return whatever we have found for labels
        return this.pushStack(labels);
    };


    /*!
     * jQuery UI Scroll Parent 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: scrollParent
    //>>group: Core
    //>>description: Get the closest ancestor element that is scrollable.
    //>>docs: http://api.jqueryui.com/scrollParent/



    var scrollParent = $.fn.scrollParent = function(includeHidden) {
        var position = this.css("position"),
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollParent = this.parents().filter(function() {
                var parent = $(this);
                if (excludeStaticParent && parent.css("position") === "static") {
                    return false;
                }
                return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") +
                    parent.css("overflow-x"));
            }).eq(0);

        return position === "fixed" || !scrollParent.length ?
            $(this[0].ownerDocument || document) :
            scrollParent;
    };


    /*!
     * jQuery UI Tabbable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: :tabbable Selector
    //>>group: Core
    //>>description: Selects elements which can be tabbed to.
    //>>docs: http://api.jqueryui.com/tabbable-selector/



    var tabbable = $.extend($.expr[":"], {
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"),
                hasTabindex = tabIndex != null;
            return (!hasTabindex || tabIndex >= 0) && $.ui.focusable(element, hasTabindex);
        }
    });


    /*!
     * jQuery UI Unique ID 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: uniqueId
    //>>group: Core
    //>>description: Functions to generate and remove uniqueId's
    //>>docs: http://api.jqueryui.com/uniqueId/



    var uniqueId = $.fn.extend({
        uniqueId: (function() {
            var uuid = 0;

            return function() {
                return this.each(function() {
                    if (!this.id) {
                        this.id = "ui-id-" + (++uuid);
                    }
                });
            };
        })(),

        removeUniqueId: function() {
            return this.each(function() {
                if (/^ui-id-\d+$/.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });


    /*!
     * jQuery UI Accordion 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Accordion
    //>>group: Widgets
    // jscs:disable maximumLineLength
    //>>description: Displays collapsible content panels for presenting information in a limited amount of space.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/accordion/
    //>>demos: http://jqueryui.com/accordion/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/accordion.css
    //>>css.theme: ../../themes/base/theme.css



    var widgetsAccordion = $.widget("ui.accordion", {
        version: "1.12.1",
        options: {
            active: 0,
            animate: {},
            classes: {
                "ui-accordion-header": "ui-corner-top",
                "ui-accordion-header-collapsed": "ui-corner-all",
                "ui-accordion-content": "ui-corner-bottom"
            },
            collapsible: false,
            event: "click",
            header: "> li > :first-child, > :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },

            // Callbacks
            activate: null,
            beforeActivate: null
        },

        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide"
        },

        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show"
        },

        _create: function() {
            var options = this.options;

            this.prevShow = this.prevHide = $();
            this._addClass("ui-accordion", "ui-widget ui-helper-reset");
            this.element.attr("role", "tablist");

            // Don't allow collapsible: false and active: false / null
            if (!options.collapsible && (options.active === false || options.active == null)) {
                options.active = 0;
            }

            this._processPanels();

            // handle negative values
            if (options.active < 0) {
                options.active += this.headers.length;
            }
            this._refresh();
        },

        _getCreateEventData: function() {
            return {
                header: this.active,
                panel: !this.active.length ? $() : this.active.next()
            };
        },

        _createIcons: function() {
            var icon, children,
                icons = this.options.icons;

            if (icons) {
                icon = $("<span>");
                this._addClass(icon, "ui-accordion-header-icon", "ui-icon " + icons.header);
                icon.prependTo(this.headers);
                children = this.active.children(".ui-accordion-header-icon");
                this._removeClass(children, icons.header)
                    ._addClass(children, null, icons.activeHeader)
                    ._addClass(this.headers, "ui-accordion-icons");
            }
        },

        _destroyIcons: function() {
            this._removeClass(this.headers, "ui-accordion-icons");
            this.headers.children(".ui-accordion-header-icon").remove();
        },

        _destroy: function() {
            var contents;

            // Clean up main element
            this.element.removeAttr("role");

            // Clean up headers
            this.headers
                .removeAttr("role aria-expanded aria-selected aria-controls tabIndex")
                .removeUniqueId();

            this._destroyIcons();

            // Clean up content panels
            contents = this.headers.next()
                .css("display", "")
                .removeAttr("role aria-hidden aria-labelledby")
                .removeUniqueId();

            if (this.options.heightStyle !== "content") {
                contents.css("height", "");
            }
        },

        _setOption: function(key, value) {
            if (key === "active") {

                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            if (key === "event") {
                if (this.options.event) {
                    this._off(this.headers, this.options.event);
                }
                this._setupEvents(value);
            }

            this._super(key, value);

            // Setting collapsible: false while collapsed; open first panel
            if (key === "collapsible" && !value && this.options.active === false) {
                this._activate(0);
            }

            if (key === "icons") {
                this._destroyIcons();
                if (value) {
                    this._createIcons();
                }
            }
        },

        _setOptionDisabled: function(value) {
            this._super(value);

            this.element.attr("aria-disabled", value);

            // Support: IE8 Only
            // #5332 / #6059 - opacity doesn't cascade to positioned elements in IE
            // so we need to add the disabled class to the headers and panels
            this._toggleClass(null, "ui-state-disabled", !!value);
            this._toggleClass(this.headers.add(this.headers.next()), null, "ui-state-disabled", !!value);
        },

        _keydown: function(event) {
            if (event.altKey || event.ctrlKey) {
                return;
            }

            var keyCode = $.ui.keyCode,
                length = this.headers.length,
                currentIndex = this.headers.index(event.target),
                toFocus = false;

            switch (event.keyCode) {
                case keyCode.RIGHT:
                case keyCode.DOWN:
                    toFocus = this.headers[(currentIndex + 1) % length];
                    break;
                case keyCode.LEFT:
                case keyCode.UP:
                    toFocus = this.headers[(currentIndex - 1 + length) % length];
                    break;
                case keyCode.SPACE:
                case keyCode.ENTER:
                    this._eventHandler(event);
                    break;
                case keyCode.HOME:
                    toFocus = this.headers[0];
                    break;
                case keyCode.END:
                    toFocus = this.headers[length - 1];
                    break;
            }

            if (toFocus) {
                $(event.target).attr("tabIndex", -1);
                $(toFocus).attr("tabIndex", 0);
                $(toFocus).trigger("focus");
                event.preventDefault();
            }
        },

        _panelKeyDown: function(event) {
            if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                $(event.currentTarget).prev().trigger("focus");
            }
        },

        refresh: function() {
            var options = this.options;
            this._processPanels();

            // Was collapsed or no panel
            if ((options.active === false && options.collapsible === true) ||
                !this.headers.length) {
                options.active = false;
                this.active = $();

                // active false only when collapsible is true
            } else if (options.active === false) {
                this._activate(0);

                // was active, but active panel is gone
            } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {

                // all remaining panel are disabled
                if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                    options.active = false;
                    this.active = $();

                    // activate previous panel
                } else {
                    this._activate(Math.max(0, options.active - 1));
                }

                // was active, active panel still exists
            } else {

                // make sure active index is correct
                options.active = this.headers.index(this.active);
            }

            this._destroyIcons();

            this._refresh();
        },

        _processPanels: function() {
            var prevHeaders = this.headers,
                prevPanels = this.panels;

            this.headers = this.element.find(this.options.header);
            this._addClass(this.headers, "ui-accordion-header ui-accordion-header-collapsed",
                "ui-state-default");

            this.panels = this.headers.next().filter(":not(.ui-accordion-content-active)").hide();
            this._addClass(this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content");

            // Avoid memory leaks (#10056)
            if (prevPanels) {
                this._off(prevHeaders.not(this.headers));
                this._off(prevPanels.not(this.panels));
            }
        },

        _refresh: function() {
            var maxHeight,
                options = this.options,
                heightStyle = options.heightStyle,
                parent = this.element.parent();

            this.active = this._findActive(options.active);
            this._addClass(this.active, "ui-accordion-header-active", "ui-state-active")
                ._removeClass(this.active, "ui-accordion-header-collapsed");
            this._addClass(this.active.next(), "ui-accordion-content-active");
            this.active.next().show();

            this.headers
                .attr("role", "tab")
                .each(function() {
                    var header = $(this),
                        headerId = header.uniqueId().attr("id"),
                        panel = header.next(),
                        panelId = panel.uniqueId().attr("id");
                    header.attr("aria-controls", panelId);
                    panel.attr("aria-labelledby", headerId);
                })
                .next()
                .attr("role", "tabpanel");

            this.headers
                .not(this.active)
                .attr({
                    "aria-selected": "false",
                    "aria-expanded": "false",
                    tabIndex: -1
                })
                .next()
                .attr({
                    "aria-hidden": "true"
                })
                .hide();

            // Make sure at least one header is in the tab order
            if (!this.active.length) {
                this.headers.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    })
                    .next()
                    .attr({
                        "aria-hidden": "false"
                    });
            }

            this._createIcons();

            this._setupEvents(options.event);

            if (heightStyle === "fill") {
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });

                this.headers.each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.headers.next()
                    .each(function() {
                        $(this).height(Math.max(0, maxHeight -
                            $(this).innerHeight() + $(this).height()));
                    })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.headers.next()
                    .each(function() {
                        var isVisible = $(this).is(":visible");
                        if (!isVisible) {
                            $(this).show();
                        }
                        maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                        if (!isVisible) {
                            $(this).hide();
                        }
                    })
                    .height(maxHeight);
            }
        },

        _activate: function(index) {
            var active = this._findActive(index)[0];

            // Trying to activate the already active panel
            if (active === this.active[0]) {
                return;
            }

            // Trying to collapse, simulate a click on the currently active header
            active = active || this.active[0];

            this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            });
        },

        _findActive: function(selector) {
            return typeof selector === "number" ? this.headers.eq(selector) : $();
        },

        _setupEvents: function(event) {
            var events = {
                keydown: "_keydown"
            };
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.headers.add(this.headers.next()));
            this._on(this.headers, events);
            this._on(this.headers.next(), {
                keydown: "_panelKeyDown"
            });
            this._hoverable(this.headers);
            this._focusable(this.headers);
        },

        _eventHandler: function(event) {
            var activeChildren, clickedChildren,
                options = this.options,
                active = this.active,
                clicked = $(event.currentTarget),
                clickedIsActive = clicked[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : clicked.next(),
                toHide = active.next(),
                eventData = {
                    oldHeader: active,
                    oldPanel: toHide,
                    newHeader: collapsing ? $() : clicked,
                    newPanel: toShow
                };

            event.preventDefault();

            if (

                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||

                // allow canceling activation
                (this._trigger("beforeActivate", event, eventData) === false)) {
                return;
            }

            options.active = collapsing ? false : this.headers.index(clicked);

            // When the call to ._toggle() comes after the class changes
            // it causes a very odd bug in IE 8 (see #6720)
            this.active = clickedIsActive ? $() : clicked;
            this._toggle(eventData);

            // Switch classes
            // corner classes on the previously active header stay after the animation
            this._removeClass(active, "ui-accordion-header-active", "ui-state-active");
            if (options.icons) {
                activeChildren = active.children(".ui-accordion-header-icon");
                this._removeClass(activeChildren, null, options.icons.activeHeader)
                    ._addClass(activeChildren, null, options.icons.header);
            }

            if (!clickedIsActive) {
                this._removeClass(clicked, "ui-accordion-header-collapsed")
                    ._addClass(clicked, "ui-accordion-header-active", "ui-state-active");
                if (options.icons) {
                    clickedChildren = clicked.children(".ui-accordion-header-icon");
                    this._removeClass(clickedChildren, null, options.icons.header)
                        ._addClass(clickedChildren, null, options.icons.activeHeader);
                }

                this._addClass(clicked.next(), "ui-accordion-content-active");
            }
        },

        _toggle: function(data) {
            var toShow = data.newPanel,
                toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

            // Handle activating a panel during the animation for another activation
            this.prevShow.add(this.prevHide).stop(true, true);
            this.prevShow = toShow;
            this.prevHide = toHide;

            if (this.options.animate) {
                this._animate(toShow, toHide, data);
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete(data);
            }

            toHide.attr({
                "aria-hidden": "true"
            });
            toHide.prev().attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            });

            // if we're switching panels, remove the old header from the tab order
            // if we're opening from collapsed state, remove the previous header from the tab order
            // if we're collapsing, then keep the collapsing header in the tab order
            if (toShow.length && toHide.length) {
                toHide.prev().attr({
                    "tabIndex": -1,
                    "aria-expanded": "false"
                });
            } else if (toShow.length) {
                this.headers.filter(function() {
                        return parseInt($(this).attr("tabIndex"), 10) === 0;
                    })
                    .attr("tabIndex", -1);
            }

            toShow
                .attr("aria-hidden", "false")
                .prev()
                .attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                });
        },

        _animate: function(toShow, toHide, data) {
            var total, easing, duration,
                that = this,
                adjust = 0,
                boxSizing = toShow.css("box-sizing"),
                down = toShow.length &&
                (!toHide.length || (toShow.index() < toHide.index())),
                animate = this.options.animate || {},
                options = down && animate.down || animate,
                complete = function() {
                    that._toggleComplete(data);
                };

            if (typeof options === "number") {
                duration = options;
            }
            if (typeof options === "string") {
                easing = options;
            }

            // fall back from options to animation in case of partial down settings
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;

            if (!toHide.length) {
                return toShow.animate(this.showProps, duration, easing, complete);
            }
            if (!toShow.length) {
                return toHide.animate(this.hideProps, duration, easing, complete);
            }

            total = toShow.show().outerHeight();
            toHide.animate(this.hideProps, {
                duration: duration,
                easing: easing,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                }
            });
            toShow
                .hide()
                .animate(this.showProps, {
                    duration: duration,
                    easing: easing,
                    complete: complete,
                    step: function(now, fx) {
                        fx.now = Math.round(now);
                        if (fx.prop !== "height") {
                            if (boxSizing === "content-box") {
                                adjust += fx.now;
                            }
                        } else if (that.options.heightStyle !== "content") {
                            fx.now = Math.round(total - toHide.outerHeight() - adjust);
                            adjust = 0;
                        }
                    }
                });
        },

        _toggleComplete: function(data) {
            var toHide = data.oldPanel,
                prev = toHide.prev();

            this._removeClass(toHide, "ui-accordion-content-active");
            this._removeClass(prev, "ui-accordion-header-active")
                ._addClass(prev, "ui-accordion-header-collapsed");

            // Work around for rendering bug in IE (#5421)
            if (toHide.length) {
                toHide.parent()[0].className = toHide.parent()[0].className;
            }
            this._trigger("activate", null, data);
        }
    });



    var safeActiveElement = $.ui.safeActiveElement = function(document) {
        var activeElement;

        // Support: IE 9 only
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
            activeElement = document.activeElement;
        } catch (error) {
            activeElement = document.body;
        }

        // Support: IE 9 - 11 only
        // IE may return null instead of an element
        // Interestingly, this only seems to occur when NOT in an iframe
        if (!activeElement) {
            activeElement = document.body;
        }

        // Support: IE 11 only
        // IE11 returns a seemingly empty object in some cases when accessing
        // document.activeElement from an <iframe>
        if (!activeElement.nodeName) {
            activeElement = document.body;
        }

        return activeElement;
    };


    /*!
     * jQuery UI Menu 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Menu
    //>>group: Widgets
    //>>description: Creates nestable menus.
    //>>docs: http://api.jqueryui.com/menu/
    //>>demos: http://jqueryui.com/menu/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/menu.css
    //>>css.theme: ../../themes/base/theme.css



    var widgetsMenu = $.widget("ui.menu", {
        version: "1.12.1",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-caret-1-e"
            },
            items: "> *",
            menus: "ul",
            position: {
                my: "left top",
                at: "right top"
            },
            role: "menu",

            // Callbacks
            blur: null,
            focus: null,
            select: null
        },

        _create: function() {
            this.activeMenu = this.element;

            // Flag used to prevent firing of the click handler
            // as the event bubbles up through nested menus
            this.mouseHandled = false;
            this.element
                .uniqueId()
                .attr({
                    role: this.options.role,
                    tabIndex: 0
                });

            this._addClass("ui-menu", "ui-widget ui-widget-content");
            this._on({

                // Prevent focus from sticking to links inside menu after clicking
                // them (focus should always stay on UL during navigation).
                "mousedown .ui-menu-item": function(event) {
                    event.preventDefault();
                },
                "click .ui-menu-item": function(event) {
                    var target = $(event.target);
                    var active = $($.ui.safeActiveElement(this.document[0]));
                    if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                        this.select(event);

                        // Only set the mouseHandled flag if the event will bubble, see #9469.
                        if (!event.isPropagationStopped()) {
                            this.mouseHandled = true;
                        }

                        // Open submenu on click
                        if (target.has(".ui-menu").length) {
                            this.expand(event);
                        } else if (!this.element.is(":focus") &&
                            active.closest(".ui-menu").length) {

                            // Redirect focus to the menu
                            this.element.trigger("focus", [true]);

                            // If the active item is on the top level, let it stay active.
                            // Otherwise, blur the active item since it is no longer visible.
                            if (this.active && this.active.parents(".ui-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": function(event) {

                    // Ignore mouse events while typeahead is active, see #10458.
                    // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
                    // is over an item in the menu
                    if (this.previousFilter) {
                        return;
                    }

                    var actualTarget = $(event.target).closest(".ui-menu-item"),
                        target = $(event.currentTarget);

                    // Ignore bubbled events on parent items, see #11641
                    if (actualTarget[0] !== target[0]) {
                        return;
                    }

                    // Remove ui-state-active class from siblings of the newly focused menu item
                    // to avoid a jump caused by adjacent elements both having a class with a border
                    this._removeClass(target.siblings().children(".ui-state-active"),
                        null, "ui-state-active");
                    this.focus(event, target);
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function(event, keepActiveItem) {

                    // If there's already an active item, keep it active
                    // If not, activate the first item
                    var item = this.active || this.element.find(this.options.items).eq(0);

                    if (!keepActiveItem) {
                        this.focus(event, item);
                    }
                },
                blur: function(event) {
                    this._delay(function() {
                        var notContained = !$.contains(
                            this.element[0],
                            $.ui.safeActiveElement(this.document[0])
                        );
                        if (notContained) {
                            this.collapseAll(event);
                        }
                    });
                },
                keydown: "_keydown"
            });

            this.refresh();

            // Clicks outside of a menu collapse any open menus
            this._on(this.document, {
                click: function(event) {
                    if (this._closeOnDocumentClick(event)) {
                        this.collapseAll(event);
                    }

                    // Reset the mouseHandled flag
                    this.mouseHandled = false;
                }
            });
        },

        _destroy: function() {
            var items = this.element.find(".ui-menu-item")
                .removeAttr("role aria-disabled"),
                submenus = items.children(".ui-menu-item-wrapper")
                .removeUniqueId()
                .removeAttr("tabIndex role aria-haspopup");

            // Destroy (sub)menus
            this.element
                .removeAttr("aria-activedescendant")
                .find(".ui-menu").addBack()
                .removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled " +
                    "tabIndex")
                .removeUniqueId()
                .show();

            submenus.children().each(function() {
                var elem = $(this);
                if (elem.data("ui-menu-submenu-caret")) {
                    elem.remove();
                }
            });
        },

        _keydown: function(event) {
            var match, prev, character, skip,
                preventDefault = true;

            switch (event.keyCode) {
                case $.ui.keyCode.PAGE_UP:
                    this.previousPage(event);
                    break;
                case $.ui.keyCode.PAGE_DOWN:
                    this.nextPage(event);
                    break;
                case $.ui.keyCode.HOME:
                    this._move("first", "first", event);
                    break;
                case $.ui.keyCode.END:
                    this._move("last", "last", event);
                    break;
                case $.ui.keyCode.UP:
                    this.previous(event);
                    break;
                case $.ui.keyCode.DOWN:
                    this.next(event);
                    break;
                case $.ui.keyCode.LEFT:
                    this.collapse(event);
                    break;
                case $.ui.keyCode.RIGHT:
                    if (this.active && !this.active.is(".ui-state-disabled")) {
                        this.expand(event);
                    }
                    break;
                case $.ui.keyCode.ENTER:
                case $.ui.keyCode.SPACE:
                    this._activate(event);
                    break;
                case $.ui.keyCode.ESCAPE:
                    this.collapse(event);
                    break;
                default:
                    preventDefault = false;
                    prev = this.previousFilter || "";
                    skip = false;

                    // Support number pad values
                    character = event.keyCode >= 96 && event.keyCode <= 105 ?
                        (event.keyCode - 96).toString() : String.fromCharCode(event.keyCode);

                    clearTimeout(this.filterTimer);

                    if (character === prev) {
                        skip = true;
                    } else {
                        character = prev + character;
                    }

                    match = this._filterMenuItems(character);
                    match = skip && match.index(this.active.next()) !== -1 ?
                        this.active.nextAll(".ui-menu-item") :
                        match;

                    // If no matches on the current filter, reset to the last character pressed
                    // to move down the menu to the first item that starts with that character
                    if (!match.length) {
                        character = String.fromCharCode(event.keyCode);
                        match = this._filterMenuItems(character);
                    }

                    if (match.length) {
                        this.focus(event, match);
                        this.previousFilter = character;
                        this.filterTimer = this._delay(function() {
                            delete this.previousFilter;
                        }, 1000);
                    } else {
                        delete this.previousFilter;
                    }
            }

            if (preventDefault) {
                event.preventDefault();
            }
        },

        _activate: function(event) {
            if (this.active && !this.active.is(".ui-state-disabled")) {
                if (this.active.children("[aria-haspopup='true']").length) {
                    this.expand(event);
                } else {
                    this.select(event);
                }
            }
        },

        refresh: function() {
            var menus, items, newSubmenus, newItems, newWrappers,
                that = this,
                icon = this.options.icons.submenu,
                submenus = this.element.find(this.options.menus);

            this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length);

            // Initialize nested menus
            newSubmenus = submenus.filter(":not(.ui-menu)")
                .hide()
                .attr({
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false"
                })
                .each(function() {
                    var menu = $(this),
                        item = menu.prev(),
                        submenuCaret = $("<span>").data("ui-menu-submenu-caret", true);

                    that._addClass(submenuCaret, "ui-menu-icon", "ui-icon " + icon);
                    item
                        .attr("aria-haspopup", "true")
                        .prepend(submenuCaret);
                    menu.attr("aria-labelledby", item.attr("id"));
                });

            this._addClass(newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front");

            menus = submenus.add(this.element);
            items = menus.find(this.options.items);

            // Initialize menu-items containing spaces and/or dashes only as dividers
            items.not(".ui-menu-item").each(function() {
                var item = $(this);
                if (that._isDivider(item)) {
                    that._addClass(item, "ui-menu-divider", "ui-widget-content");
                }
            });

            // Don't refresh list items that are already adapted
            newItems = items.not(".ui-menu-item, .ui-menu-divider");
            newWrappers = newItems.children()
                .not(".ui-menu")
                .uniqueId()
                .attr({
                    tabIndex: -1,
                    role: this._itemRole()
                });
            this._addClass(newItems, "ui-menu-item")
                ._addClass(newWrappers, "ui-menu-item-wrapper");

            // Add aria-disabled attribute to any disabled menu item
            items.filter(".ui-state-disabled").attr("aria-disabled", "true");

            // If the active item has been removed, blur the menu
            if (this.active && !$.contains(this.element[0], this.active[0])) {
                this.blur();
            }
        },

        _itemRole: function() {
            return {
                menu: "menuitem",
                listbox: "option"
            }[this.options.role];
        },

        _setOption: function(key, value) {
            if (key === "icons") {
                var icons = this.element.find(".ui-menu-icon");
                this._removeClass(icons, null, this.options.icons.submenu)
                    ._addClass(icons, null, value.submenu);
            }
            this._super(key, value);
        },

        _setOptionDisabled: function(value) {
            this._super(value);

            this.element.attr("aria-disabled", String(value));
            this._toggleClass(null, "ui-state-disabled", !!value);
        },

        focus: function(event, item) {
            var nested, focused, activeParent;
            this.blur(event, event && event.type === "focus");

            this._scrollIntoView(item);

            this.active = item.first();

            focused = this.active.children(".ui-menu-item-wrapper");
            this._addClass(focused, null, "ui-state-active");

            // Only update aria-activedescendant if there's a role
            // otherwise we assume focus is managed elsewhere
            if (this.options.role) {
                this.element.attr("aria-activedescendant", focused.attr("id"));
            }

            // Highlight active parent menu item, if any
            activeParent = this.active
                .parent()
                .closest(".ui-menu-item")
                .children(".ui-menu-item-wrapper");
            this._addClass(activeParent, null, "ui-state-active");

            if (event && event.type === "keydown") {
                this._close();
            } else {
                this.timer = this._delay(function() {
                    this._close();
                }, this.delay);
            }

            nested = item.children(".ui-menu");
            if (nested.length && event && (/^mouse/.test(event.type))) {
                this._startOpening(nested);
            }
            this.activeMenu = item.parent();

            this._trigger("focus", event, {
                item: item
            });
        },

        _scrollIntoView: function(item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            if (this._hasScroll()) {
                borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.outerHeight();

                if (offset < 0) {
                    this.activeMenu.scrollTop(scroll + offset);
                } else if (offset + itemHeight > elementHeight) {
                    this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                }
            }
        },

        blur: function(event, fromFocus) {
            if (!fromFocus) {
                clearTimeout(this.timer);
            }

            if (!this.active) {
                return;
            }

            this._removeClass(this.active.children(".ui-menu-item-wrapper"),
                null, "ui-state-active");

            this._trigger("blur", event, {
                item: this.active
            });
            this.active = null;
        },

        _startOpening: function(submenu) {
            clearTimeout(this.timer);

            // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the caret icon
            if (submenu.attr("aria-hidden") !== "true") {
                return;
            }

            this.timer = this._delay(function() {
                this._close();
                this._open(submenu);
            }, this.delay);
        },

        _open: function(submenu) {
            var position = $.extend({ of: this.active
            }, this.options.position);

            clearTimeout(this.timer);
            this.element.find(".ui-menu").not(submenu.parents(".ui-menu"))
                .hide()
                .attr("aria-hidden", "true");

            submenu
                .show()
                .removeAttr("aria-hidden")
                .attr("aria-expanded", "true")
                .position(position);
        },

        collapseAll: function(event, all) {
            clearTimeout(this.timer);
            this.timer = this._delay(function() {

                // If we were passed an event, look for the submenu that contains the event
                var currentMenu = all ? this.element :
                    $(event && event.target).closest(this.element.find(".ui-menu"));

                // If we found no valid submenu ancestor, use the main menu to close all
                // sub menus anyway
                if (!currentMenu.length) {
                    currentMenu = this.element;
                }

                this._close(currentMenu);

                this.blur(event);

                // Work around active item staying active after menu is blurred
                this._removeClass(currentMenu.find(".ui-state-active"), null, "ui-state-active");

                this.activeMenu = currentMenu;
            }, this.delay);
        },

        // With no arguments, closes the currently active menu - if nothing is active
        // it closes all menus.  If passed an argument, it will search for menus BELOW
        _close: function(startMenu) {
            if (!startMenu) {
                startMenu = this.active ? this.active.parent() : this.element;
            }

            startMenu.find(".ui-menu")
                .hide()
                .attr("aria-hidden", "true")
                .attr("aria-expanded", "false");
        },

        _closeOnDocumentClick: function(event) {
            return !$(event.target).closest(".ui-menu").length;
        },

        _isDivider: function(item) {

            // Match hyphen, em dash, en dash
            return !/[^\-\u2014\u2013\s]/.test(item.text());
        },

        collapse: function(event) {
            var newItem = this.active &&
                this.active.parent().closest(".ui-menu-item", this.element);
            if (newItem && newItem.length) {
                this._close();
                this.focus(event, newItem);
            }
        },

        expand: function(event) {
            var newItem = this.active &&
                this.active
                .children(".ui-menu ")
                .find(this.options.items)
                .first();

            if (newItem && newItem.length) {
                this._open(newItem.parent());

                // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                this._delay(function() {
                    this.focus(event, newItem);
                });
            }
        },

        next: function(event) {
            this._move("next", "first", event);
        },

        previous: function(event) {
            this._move("prev", "last", event);
        },

        isFirstItem: function() {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },

        isLastItem: function() {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },

        _move: function(direction, filter, event) {
            var next;
            if (this.active) {
                if (direction === "first" || direction === "last") {
                    next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item")
                        .eq(-1);
                } else {
                    next = this.active[direction + "All"](".ui-menu-item")
                        .eq(0);
                }
            }
            if (!next || !next.length || !this.active) {
                next = this.activeMenu.find(this.options.items)[filter]();
            }

            this.focus(event, next);
        },

        nextPage: function(event) {
            var item, base, height;

            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isLastItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.nextAll(".ui-menu-item").each(function() {
                    item = $(this);
                    return item.offset().top - base - height < 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.find(this.options.items)[!this.active ? "first" : "last"]());
            }
        },

        previousPage: function(event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isFirstItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.prevAll(".ui-menu-item").each(function() {
                    item = $(this);
                    return item.offset().top - base + height > 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.find(this.options.items).first());
            }
        },

        _hasScroll: function() {
            return this.element.outerHeight() < this.element.prop("scrollHeight");
        },

        select: function(event) {

            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active = this.active || $(event.target).closest(".ui-menu-item");
            var ui = {
                item: this.active
            };
            if (!this.active.has(".ui-menu").length) {
                this.collapseAll(event, true);
            }
            this._trigger("select", event, ui);
        },

        _filterMenuItems: function(character) {
            var escapedCharacter = character.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
                regex = new RegExp("^" + escapedCharacter, "i");

            return this.activeMenu
                .find(this.options.items)

                // Only match on items, not dividers or other content (#10571)
                .filter(".ui-menu-item")
                .filter(function() {
                    return regex.test(
                        $.trim($(this).children(".ui-menu-item-wrapper").text()));
                });
        }
    });


    /*!
     * jQuery UI Autocomplete 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Autocomplete
    //>>group: Widgets
    //>>description: Lists suggested words as the user is typing.
    //>>docs: http://api.jqueryui.com/autocomplete/
    //>>demos: http://jqueryui.com/autocomplete/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/autocomplete.css
    //>>css.theme: ../../themes/base/theme.css



    $.widget("ui.autocomplete", {
        version: "1.12.1",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,

            // Callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },

        requestIndex: 0,
        pending: 0,

        _create: function() {

            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
                nodeName = this.element[0].nodeName.toLowerCase(),
                isTextarea = nodeName === "textarea",
                isInput = nodeName === "input";

            // Textareas are always multi-line
            // Inputs are always single-line, even if inside a contentEditable element
            // IE also treats inputs as contentEditable
            // All other element types are determined by whether or not they're contentEditable
            this.isMultiLine = isTextarea || !isInput && this._isContentEditable(this.element);

            this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
            this.isNewMenu = true;

            this._addClass("ui-autocomplete-input");
            this.element.attr("autocomplete", "off");

            this._on(this.element, {
                keydown: function(event) {
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }

                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            suppressKeyPress = true;
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            suppressKeyPress = true;
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            suppressKeyPress = true;
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            suppressKeyPress = true;
                            this._keyEvent("next", event);
                            break;
                        case keyCode.ENTER:

                            // when menu is open and has focus
                            if (this.menu.active) {

                                // #6055 - Opera still allows the keypress to occur
                                // which causes forms to submit
                                suppressKeyPress = true;
                                event.preventDefault();
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.TAB:
                            if (this.menu.active) {
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.ESCAPE:
                            if (this.menu.element.is(":visible")) {
                                if (!this.isMultiLine) {
                                    this._value(this.term);
                                }
                                this.close(event);

                                // Different browsers have different default behavior for escape
                                // Single press can mean undo or clear
                                // Double press in IE means clear the whole form
                                event.preventDefault();
                            }
                            break;
                        default:
                            suppressKeyPressRepeat = true;

                            // search timeout should be triggered before the input value is changed
                            this._searchTimeout(event);
                            break;
                    }
                },
                keypress: function(event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        if (!this.isMultiLine || this.menu.element.is(":visible")) {
                            event.preventDefault();
                        }
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }

                    // Replicate some key handlers to allow them to repeat in Firefox and Opera
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            this._keyEvent("next", event);
                            break;
                    }
                },
                input: function(event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                focus: function() {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function(event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }

                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                }
            });

            this._initSource();
            this.menu = $("<ul>")
                .appendTo(this._appendTo())
                .menu({

                    // disable ARIA support, the live region takes care of that
                    role: null
                })
                .hide()
                .menu("instance");

            this._addClass(this.menu.element, "ui-autocomplete", "ui-front");
            this._on(this.menu.element, {
                mousedown: function(event) {

                    // prevent moving focus out of the text field
                    event.preventDefault();

                    // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    this.cancelBlur = true;
                    this._delay(function() {
                        delete this.cancelBlur;

                        // Support: IE 8 only
                        // Right clicking a menu item or selecting text from the menu items will
                        // result in focus moving out of the input. However, we've already received
                        // and ignored the blur event because of the cancelBlur flag set above. So
                        // we restore focus to ensure that the menu closes properly based on the user's
                        // next actions.
                        if (this.element[0] !== $.ui.safeActiveElement(this.document[0])) {
                            this.element.trigger("focus");
                        }
                    });
                },
                menufocus: function(event, ui) {
                    var label, item;

                    // support: Firefox
                    // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                            this.menu.blur();

                            this.document.one("mousemove", function() {
                                $(event.target).trigger(event.originalEvent);
                            });

                            return;
                        }
                    }

                    item = ui.item.data("ui-autocomplete-item");
                    if (false !== this._trigger("focus", event, {
                            item: item
                        })) {

                        // use value to match what will end up in the input, if it was a key event
                        if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                            this._value(item.value);
                        }
                    }

                    // Announce the value in the liveRegion
                    label = ui.item.attr("aria-label") || item.value;
                    if (label && $.trim(label).length) {
                        this.liveRegion.children().hide();
                        $("<div>").text(label).appendTo(this.liveRegion);
                    }
                },
                menuselect: function(event, ui) {
                    var item = ui.item.data("ui-autocomplete-item"),
                        previous = this.previous;

                    // Only trigger when focus was lost (click on menu)
                    if (this.element[0] !== $.ui.safeActiveElement(this.document[0])) {
                        this.element.trigger("focus");
                        this.previous = previous;

                        // #6109 - IE triggers two focus events and the second
                        // is asynchronous, so we need to reset the previous
                        // term synchronously and asynchronously :-(
                        this._delay(function() {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }

                    if (false !== this._trigger("select", event, {
                            item: item
                        })) {
                        this._value(item.value);
                    }

                    // reset the term after the select event
                    // this allows custom select handling to work properly
                    this.term = this._value();

                    this.close(event);
                    this.selectedItem = item;
                }
            });

            this.liveRegion = $("<div>", {
                    role: "status",
                    "aria-live": "assertive",
                    "aria-relevant": "additions"
                })
                .appendTo(this.document[0].body);

            this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible");

            // Turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },

        _destroy: function() {
            clearTimeout(this.searching);
            this.element.removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },

        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this._appendTo());
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },

        _isEventTargetInWidget: function(event) {
            var menuElement = this.menu.element[0];

            return event.target === this.element[0] ||
                event.target === menuElement ||
                $.contains(menuElement, event.target);
        },

        _closeOnClickOutside: function(event) {
            if (!this._isEventTargetInWidget(event)) {
                this.close();
            }
        },

        _appendTo: function() {
            var element = this.options.appendTo;

            if (element) {
                element = element.jquery || element.nodeType ?
                    $(element) :
                    this.document.find(element).eq(0);
            }

            if (!element || !element[0]) {
                element = this.element.closest(".ui-front, dialog");
            }

            if (!element.length) {
                element = this.document[0].body;
            }

            return element;
        },

        _initSource: function() {
            var array, url,
                that = this;
            if ($.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function(request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };
            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function(request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function(data) {
                            response(data);
                        },
                        error: function() {
                            response([]);
                        }
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },

        _searchTimeout: function(event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function() {

                // Search if the value has changed, or if the user retypes the same value (see #7434)
                var equalValues = this.term === this._value(),
                    menuVisible = this.menu.element.is(":visible"),
                    modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

                if (!equalValues || (equalValues && !menuVisible && !modifierKey)) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },

        search: function(value, event) {
            value = value != null ? value : this._value();

            // Always save the actual value, not the one passed as an argument
            this.term = this._value();

            if (value.length < this.options.minLength) {
                return this.close(event);
            }

            if (this._trigger("search", event) === false) {
                return;
            }

            return this._search(value);
        },

        _search: function(value) {
            this.pending++;
            this._addClass("ui-autocomplete-loading");
            this.cancelSearch = false;

            this.source({
                term: value
            }, this._response());
        },

        _response: function() {
            var index = ++this.requestIndex;

            return $.proxy(function(content) {
                if (index === this.requestIndex) {
                    this.__response(content);
                }

                this.pending--;
                if (!this.pending) {
                    this._removeClass("ui-autocomplete-loading");
                }
            }, this);
        },

        __response: function(content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, {
                content: content
            });
            if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                this._suggest(content);
                this._trigger("open");
            } else {

                // use ._close() instead of .close() so we don't cancel future searches
                this._close();
            }
        },

        close: function(event) {
            this.cancelSearch = true;
            this._close(event);
        },

        _close: function(event) {

            // Remove the handler that closes the menu on outside clicks
            this._off(this.document, "mousedown");

            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },

        _change: function(event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, {
                    item: this.selectedItem
                });
            }
        },

        _normalize: function(items) {

            // assume all items have the right format when the first item is complete
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function(item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend({}, item, {
                    label: item.label || item.value,
                    value: item.value || item.label
                });
            });
        },

        _suggest: function(items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items);
            this.isNewMenu = true;
            this.menu.refresh();

            // Size and position menu
            ul.show();
            this._resizeMenu();
            ul.position($.extend({ of: this.element
            }, this.options.position));

            if (this.options.autoFocus) {
                this.menu.next();
            }

            // Listen for interactions outside of the widget (#6642)
            this._on(this.document, {
                mousedown: "_closeOnClickOutside"
            });
        },

        _resizeMenu: function() {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(

                // Firefox wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping (#7513)
                ul.width("").outerWidth() + 1,
                this.element.outerWidth()
            ));
        },

        _renderMenu: function(ul, items) {
            var that = this;
            $.each(items, function(index, item) {
                that._renderItemData(ul, item);
            });
        },

        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },

        _renderItem: function(ul, item) {
            return $("<li>")
                .append($("<div>").text(item.label))
                .appendTo(ul);
        },

        _move: function(direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (this.menu.isFirstItem() && /^previous/.test(direction) ||
                this.menu.isLastItem() && /^next/.test(direction)) {

                if (!this.isMultiLine) {
                    this._value(this.term);
                }

                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },

        widget: function() {
            return this.menu.element;
        },

        _value: function() {
            return this.valueMethod.apply(this.element, arguments);
        },

        _keyEvent: function(keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);

                // Prevents moving cursor to beginning/end of the text field in some browsers
                event.preventDefault();
            }
        },

        // Support: Chrome <=50
        // We should be able to just use this.element.prop( "isContentEditable" )
        // but hidden elements always report false in Chrome.
        // https://code.google.com/p/chromium/issues/detail?id=313082
        _isContentEditable: function(element) {
            if (!element.length) {
                return false;
            }

            var editable = element.prop("contentEditable");

            if (editable === "inherit") {
                return this._isContentEditable(element.parent());
            }

            return editable === "true";
        }
    });

    $.extend($.ui.autocomplete, {
        escapeRegex: function(value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function(array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function(value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });

    // Live region extension, adding a `messages` option
    // NOTE: This is an experimental API. We are still investigating
    // a full solution for string manipulation and internationalization.
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function(amount) {
                    return amount + (amount > 1 ? " results are" : " result is") +
                        " available, use up and down arrow keys to navigate.";
                }
            }
        },

        __response: function(content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.children().hide();
            $("<div>").text(message).appendTo(this.liveRegion);
        }
    });

    var widgetsAutocomplete = $.ui.autocomplete;


    /*!
     * jQuery UI Controlgroup 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Controlgroup
    //>>group: Widgets
    //>>description: Visually groups form control widgets
    //>>docs: http://api.jqueryui.com/controlgroup/
    //>>demos: http://jqueryui.com/controlgroup/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/controlgroup.css
    //>>css.theme: ../../themes/base/theme.css


    var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;

    var widgetsControlgroup = $.widget("ui.controlgroup", {
        version: "1.12.1",
        defaultElement: "<div>",
        options: {
            direction: "horizontal",
            disabled: null,
            onlyVisible: true,
            items: {
                "button": "input[type=button], input[type=submit], input[type=reset], button, a",
                "controlgroupLabel": ".ui-controlgroup-label",
                "checkboxradio": "input[type='checkbox'], input[type='radio']",
                "selectmenu": "select",
                "spinner": ".ui-spinner-input"
            }
        },

        _create: function() {
            this._enhance();
        },

        // To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
        _enhance: function() {
            this.element.attr("role", "toolbar");
            this.refresh();
        },

        _destroy: function() {
            this._callChildMethod("destroy");
            this.childWidgets.removeData("ui-controlgroup-data");
            this.element.removeAttr("role");
            if (this.options.items.controlgroupLabel) {
                this.element
                    .find(this.options.items.controlgroupLabel)
                    .find(".ui-controlgroup-label-contents")
                    .contents().unwrap();
            }
        },

        _initWidgets: function() {
            var that = this,
                childWidgets = [];

            // First we iterate over each of the items options
            $.each(this.options.items, function(widget, selector) {
                var labels;
                var options = {};

                // Make sure the widget has a selector set
                if (!selector) {
                    return;
                }

                if (widget === "controlgroupLabel") {
                    labels = that.element.find(selector);
                    labels.each(function() {
                        var element = $(this);

                        if (element.children(".ui-controlgroup-label-contents").length) {
                            return;
                        }
                        element.contents()
                            .wrapAll("<span class='ui-controlgroup-label-contents'></span>");
                    });
                    that._addClass(labels, null, "ui-widget ui-widget-content ui-state-default");
                    childWidgets = childWidgets.concat(labels.get());
                    return;
                }

                // Make sure the widget actually exists
                if (!$.fn[widget]) {
                    return;
                }

                // We assume everything is in the middle to start because we can't determine
                // first / last elements until all enhancments are done.
                if (that["_" + widget + "Options"]) {
                    options = that["_" + widget + "Options"]("middle");
                } else {
                    options = {
                        classes: {}
                    };
                }

                // Find instances of this widget inside controlgroup and init them
                that.element
                    .find(selector)
                    .each(function() {
                        var element = $(this);
                        var instance = element[widget]("instance");

                        // We need to clone the default options for this type of widget to avoid
                        // polluting the variable options which has a wider scope than a single widget.
                        var instanceOptions = $.widget.extend({}, options);

                        // If the button is the child of a spinner ignore it
                        // TODO: Find a more generic solution
                        if (widget === "button" && element.parent(".ui-spinner").length) {
                            return;
                        }

                        // Create the widget if it doesn't exist
                        if (!instance) {
                            instance = element[widget]()[widget]("instance");
                        }
                        if (instance) {
                            instanceOptions.classes =
                                that._resolveClassesValues(instanceOptions.classes, instance);
                        }
                        element[widget](instanceOptions);

                        // Store an instance of the controlgroup to be able to reference
                        // from the outermost element for changing options and refresh
                        var widgetElement = element[widget]("widget");
                        $.data(widgetElement[0], "ui-controlgroup-data",
                            instance ? instance : element[widget]("instance"));

                        childWidgets.push(widgetElement[0]);
                    });
            });

            this.childWidgets = $($.unique(childWidgets));
            this._addClass(this.childWidgets, "ui-controlgroup-item");
        },

        _callChildMethod: function(method) {
            this.childWidgets.each(function() {
                var element = $(this),
                    data = element.data("ui-controlgroup-data");
                if (data && data[method]) {
                    data[method]();
                }
            });
        },

        _updateCornerClass: function(element, position) {
            var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
            var add = this._buildSimpleOptions(position, "label").classes.label;

            this._removeClass(element, null, remove);
            this._addClass(element, null, add);
        },

        _buildSimpleOptions: function(position, key) {
            var direction = this.options.direction === "vertical";
            var result = {
                classes: {}
            };
            result.classes[key] = {
                "middle": "",
                "first": "ui-corner-" + (direction ? "top" : "left"),
                "last": "ui-corner-" + (direction ? "bottom" : "right"),
                "only": "ui-corner-all"
            }[position];

            return result;
        },

        _spinnerOptions: function(position) {
            var options = this._buildSimpleOptions(position, "ui-spinner");

            options.classes["ui-spinner-up"] = "";
            options.classes["ui-spinner-down"] = "";

            return options;
        },

        _buttonOptions: function(position) {
            return this._buildSimpleOptions(position, "ui-button");
        },

        _checkboxradioOptions: function(position) {
            return this._buildSimpleOptions(position, "ui-checkboxradio-label");
        },

        _selectmenuOptions: function(position) {
            var direction = this.options.direction === "vertical";
            return {
                width: direction ? "auto" : false,
                classes: {
                    middle: {
                        "ui-selectmenu-button-open": "",
                        "ui-selectmenu-button-closed": ""
                    },
                    first: {
                        "ui-selectmenu-button-open": "ui-corner-" + (direction ? "top" : "tl"),
                        "ui-selectmenu-button-closed": "ui-corner-" + (direction ? "top" : "left")
                    },
                    last: {
                        "ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
                        "ui-selectmenu-button-closed": "ui-corner-" + (direction ? "bottom" : "right")
                    },
                    only: {
                        "ui-selectmenu-button-open": "ui-corner-top",
                        "ui-selectmenu-button-closed": "ui-corner-all"
                    }

                }[position]
            };
        },

        _resolveClassesValues: function(classes, instance) {
            var result = {};
            $.each(classes, function(key) {
                var current = instance.options.classes[key] || "";
                current = $.trim(current.replace(controlgroupCornerRegex, ""));
                result[key] = (current + " " + classes[key]).replace(/\s+/g, " ");
            });
            return result;
        },

        _setOption: function(key, value) {
            if (key === "direction") {
                this._removeClass("ui-controlgroup-" + this.options.direction);
            }

            this._super(key, value);
            if (key === "disabled") {
                this._callChildMethod(value ? "disable" : "enable");
                return;
            }

            this.refresh();
        },

        refresh: function() {
            var children,
                that = this;

            this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction);

            if (this.options.direction === "horizontal") {
                this._addClass(null, "ui-helper-clearfix");
            }
            this._initWidgets();

            children = this.childWidgets;

            // We filter here because we need to track all childWidgets not just the visible ones
            if (this.options.onlyVisible) {
                children = children.filter(":visible");
            }

            if (children.length) {

                // We do this last because we need to make sure all enhancment is done
                // before determining first and last
                $.each(["first", "last"], function(index, value) {
                    var instance = children[value]().data("ui-controlgroup-data");

                    if (instance && that["_" + instance.widgetName + "Options"]) {
                        var options = that["_" + instance.widgetName + "Options"](
                            children.length === 1 ? "only" : value
                        );
                        options.classes = that._resolveClassesValues(options.classes, instance);
                        instance.element[instance.widgetName](options);
                    } else {
                        that._updateCornerClass(children[value](), value);
                    }
                });

                // Finally call the refresh method on each of the child widgets.
                this._callChildMethod("refresh");
            }
        }
    });

    /*!
     * jQuery UI Checkboxradio 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Checkboxradio
    //>>group: Widgets
    //>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
    //>>docs: http://api.jqueryui.com/checkboxradio/
    //>>demos: http://jqueryui.com/checkboxradio/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/button.css
    //>>css.structure: ../../themes/base/checkboxradio.css
    //>>css.theme: ../../themes/base/theme.css



    $.widget("ui.checkboxradio", [$.ui.formResetMixin, {
        version: "1.12.1",
        options: {
            disabled: null,
            label: null,
            icon: true,
            classes: {
                "ui-checkboxradio-label": "ui-corner-all",
                "ui-checkboxradio-icon": "ui-corner-all"
            }
        },

        _getCreateOptions: function() {
            var disabled, labels;
            var that = this;
            var options = this._super() || {};

            // We read the type here, because it makes more sense to throw a element type error first,
            // rather then the error for lack of a label. Often if its the wrong type, it
            // won't have a label (e.g. calling on a div, btn, etc)
            this._readType();

            labels = this.element.labels();

            // If there are multiple labels, use the last one
            this.label = $(labels[labels.length - 1]);
            if (!this.label.length) {
                $.error("No label found for checkboxradio widget");
            }

            this.originalLabel = "";

            // We need to get the label text but this may also need to make sure it does not contain the
            // input itself.
            this.label.contents().not(this.element[0]).each(function() {

                // The label contents could be text, html, or a mix. We concat each element to get a
                // string representation of the label, without the input as part of it.
                that.originalLabel += this.nodeType === 3 ? $(this).text() : this.outerHTML;
            });

            // Set the label option if we found label text
            if (this.originalLabel) {
                options.label = this.originalLabel;
            }

            disabled = this.element[0].disabled;
            if (disabled != null) {
                options.disabled = disabled;
            }
            return options;
        },

        _create: function() {
            var checked = this.element[0].checked;

            this._bindFormResetHandler();

            if (this.options.disabled == null) {
                this.options.disabled = this.element[0].disabled;
            }

            this._setOption("disabled", this.options.disabled);
            this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible");
            this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget");

            if (this.type === "radio") {
                this._addClass(this.label, "ui-checkboxradio-radio-label");
            }

            if (this.options.label && this.options.label !== this.originalLabel) {
                this._updateLabel();
            } else if (this.originalLabel) {
                this.options.label = this.originalLabel;
            }

            this._enhance();

            if (checked) {
                this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active");
                if (this.icon) {
                    this._addClass(this.icon, null, "ui-state-hover");
                }
            }

            this._on({
                change: "_toggleClasses",
                focus: function() {
                    this._addClass(this.label, null, "ui-state-focus ui-visual-focus");
                },
                blur: function() {
                    this._removeClass(this.label, null, "ui-state-focus ui-visual-focus");
                }
            });
        },

        _readType: function() {
            var nodeName = this.element[0].nodeName.toLowerCase();
            this.type = this.element[0].type;
            if (nodeName !== "input" || !/radio|checkbox/.test(this.type)) {
                $.error("Can't create checkboxradio on element.nodeName=" + nodeName +
                    " and element.type=" + this.type);
            }
        },

        // Support jQuery Mobile enhanced option
        _enhance: function() {
            this._updateIcon(this.element[0].checked);
        },

        widget: function() {
            return this.label;
        },

        _getRadioGroup: function() {
            var group;
            var name = this.element[0].name;
            var nameSelector = "input[name='" + $.ui.escapeSelector(name) + "']";

            if (!name) {
                return $([]);
            }

            if (this.form.length) {
                group = $(this.form[0].elements).filter(nameSelector);
            } else {

                // Not inside a form, check all inputs that also are not inside a form
                group = $(nameSelector).filter(function() {
                    return $(this).form().length === 0;
                });
            }

            return group.not(this.element);
        },

        _toggleClasses: function() {
            var checked = this.element[0].checked;
            this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked);

            if (this.options.icon && this.type === "checkbox") {
                this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", checked)
                    ._toggleClass(this.icon, null, "ui-icon-blank", !checked);
            }

            if (this.type === "radio") {
                this._getRadioGroup()
                    .each(function() {
                        var instance = $(this).checkboxradio("instance");

                        if (instance) {
                            instance._removeClass(instance.label,
                                "ui-checkboxradio-checked", "ui-state-active");
                        }
                    });
            }
        },

        _destroy: function() {
            this._unbindFormResetHandler();

            if (this.icon) {
                this.icon.remove();
                this.iconSpace.remove();
            }
        },

        _setOption: function(key, value) {

            // We don't allow the value to be set to nothing
            if (key === "label" && !value) {
                return;
            }

            this._super(key, value);

            if (key === "disabled") {
                this._toggleClass(this.label, null, "ui-state-disabled", value);
                this.element[0].disabled = value;

                // Don't refresh when setting disabled
                return;
            }
            this.refresh();
        },

        _updateIcon: function(checked) {
            var toAdd = "ui-icon ui-icon-background ";

            if (this.options.icon) {
                if (!this.icon) {
                    this.icon = $("<span>");
                    this.iconSpace = $("<span> </span>");
                    this._addClass(this.iconSpace, "ui-checkboxradio-icon-space");
                }

                if (this.type === "checkbox") {
                    toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
                    this._removeClass(this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check");
                } else {
                    toAdd += "ui-icon-blank";
                }
                this._addClass(this.icon, "ui-checkboxradio-icon", toAdd);
                if (!checked) {
                    this._removeClass(this.icon, null, "ui-icon-check ui-state-checked");
                }
                this.icon.prependTo(this.label).after(this.iconSpace);
            } else if (this.icon !== undefined) {
                this.icon.remove();
                this.iconSpace.remove();
                delete this.icon;
            }
        },

        _updateLabel: function() {

            // Remove the contents of the label ( minus the icon, icon space, and input )
            var contents = this.label.contents().not(this.element[0]);
            if (this.icon) {
                contents = contents.not(this.icon[0]);
            }
            if (this.iconSpace) {
                contents = contents.not(this.iconSpace[0]);
            }
            contents.remove();

            this.label.append(this.options.label);
        },

        refresh: function() {
            var checked = this.element[0].checked,
                isDisabled = this.element[0].disabled;

            this._updateIcon(checked);
            this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked);
            if (this.options.label !== null) {
                this._updateLabel();
            }

            if (isDisabled !== this.options.disabled) {
                this._setOptions({
                    "disabled": isDisabled
                });
            }
        }

    }]);

    var widgetsCheckboxradio = $.ui.checkboxradio;


    /*!
     * jQuery UI Button 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Button
    //>>group: Widgets
    //>>description: Enhances a form with themeable buttons.
    //>>docs: http://api.jqueryui.com/button/
    //>>demos: http://jqueryui.com/button/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/button.css
    //>>css.theme: ../../themes/base/theme.css



    $.widget("ui.button", {
        version: "1.12.1",
        defaultElement: "<button>",
        options: {
            classes: {
                "ui-button": "ui-corner-all"
            },
            disabled: null,
            icon: null,
            iconPosition: "beginning",
            label: null,
            showLabel: true
        },

        _getCreateOptions: function() {
            var disabled,

                // This is to support cases like in jQuery Mobile where the base widget does have
                // an implementation of _getCreateOptions
                options = this._super() || {};

            this.isInput = this.element.is("input");

            disabled = this.element[0].disabled;
            if (disabled != null) {
                options.disabled = disabled;
            }

            this.originalLabel = this.isInput ? this.element.val() : this.element.html();
            if (this.originalLabel) {
                options.label = this.originalLabel;
            }

            return options;
        },

        _create: function() {
            if (!this.option.showLabel & !this.options.icon) {
                this.options.showLabel = true;
            }

            // We have to check the option again here even though we did in _getCreateOptions,
            // because null may have been passed on init which would override what was set in
            // _getCreateOptions
            if (this.options.disabled == null) {
                this.options.disabled = this.element[0].disabled || false;
            }

            this.hasTitle = !!this.element.attr("title");

            // Check to see if the label needs to be set or if its already correct
            if (this.options.label && this.options.label !== this.originalLabel) {
                if (this.isInput) {
                    this.element.val(this.options.label);
                } else {
                    this.element.html(this.options.label);
                }
            }
            this._addClass("ui-button", "ui-widget");
            this._setOption("disabled", this.options.disabled);
            this._enhance();

            if (this.element.is("a")) {
                this._on({
                    "keyup": function(event) {
                        if (event.keyCode === $.ui.keyCode.SPACE) {
                            event.preventDefault();

                            // Support: PhantomJS <= 1.9, IE 8 Only
                            // If a native click is available use it so we actually cause navigation
                            // otherwise just trigger a click event
                            if (this.element[0].click) {
                                this.element[0].click();
                            } else {
                                this.element.trigger("click");
                            }
                        }
                    }
                });
            }
        },

        _enhance: function() {
            if (!this.element.is("button")) {
                this.element.attr("role", "button");
            }

            if (this.options.icon) {
                this._updateIcon("icon", this.options.icon);
                this._updateTooltip();
            }
        },

        _updateTooltip: function() {
            this.title = this.element.attr("title");

            if (!this.options.showLabel && !this.title) {
                this.element.attr("title", this.options.label);
            }
        },

        _updateIcon: function(option, value) {
            var icon = option !== "iconPosition",
                position = icon ? this.options.iconPosition : value,
                displayBlock = position === "top" || position === "bottom";

            // Create icon
            if (!this.icon) {
                this.icon = $("<span>");

                this._addClass(this.icon, "ui-button-icon", "ui-icon");

                if (!this.options.showLabel) {
                    this._addClass("ui-button-icon-only");
                }
            } else if (icon) {

                // If we are updating the icon remove the old icon class
                this._removeClass(this.icon, null, this.options.icon);
            }

            // If we are updating the icon add the new icon class
            if (icon) {
                this._addClass(this.icon, null, value);
            }

            this._attachIcon(position);

            // If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
            // the iconSpace if there is one.
            if (displayBlock) {
                this._addClass(this.icon, null, "ui-widget-icon-block");
                if (this.iconSpace) {
                    this.iconSpace.remove();
                }
            } else {

                // Position is beginning or end so remove the ui-widget-icon-block class and add the
                // space if it does not exist
                if (!this.iconSpace) {
                    this.iconSpace = $("<span> </span>");
                    this._addClass(this.iconSpace, "ui-button-icon-space");
                }
                this._removeClass(this.icon, null, "ui-wiget-icon-block");
                this._attachIconSpace(position);
            }
        },

        _destroy: function() {
            this.element.removeAttr("role");

            if (this.icon) {
                this.icon.remove();
            }
            if (this.iconSpace) {
                this.iconSpace.remove();
            }
            if (!this.hasTitle) {
                this.element.removeAttr("title");
            }
        },

        _attachIconSpace: function(iconPosition) {
            this.icon[/^(?:end|bottom)/.test(iconPosition) ? "before" : "after"](this.iconSpace);
        },

        _attachIcon: function(iconPosition) {
            this.element[/^(?:end|bottom)/.test(iconPosition) ? "append" : "prepend"](this.icon);
        },

        _setOptions: function(options) {
            var newShowLabel = options.showLabel === undefined ?
                this.options.showLabel :
                options.showLabel,
                newIcon = options.icon === undefined ? this.options.icon : options.icon;

            if (!newShowLabel && !newIcon) {
                options.showLabel = true;
            }
            this._super(options);
        },

        _setOption: function(key, value) {
            if (key === "icon") {
                if (value) {
                    this._updateIcon(key, value);
                } else if (this.icon) {
                    this.icon.remove();
                    if (this.iconSpace) {
                        this.iconSpace.remove();
                    }
                }
            }

            if (key === "iconPosition") {
                this._updateIcon(key, value);
            }

            // Make sure we can't end up with a button that has neither text nor icon
            if (key === "showLabel") {
                this._toggleClass("ui-button-icon-only", null, !value);
                this._updateTooltip();
            }

            if (key === "label") {
                if (this.isInput) {
                    this.element.val(value);
                } else {

                    // If there is an icon, append it, else nothing then append the value
                    // this avoids removal of the icon when setting label text
                    this.element.html(value);
                    if (this.icon) {
                        this._attachIcon(this.options.iconPosition);
                        this._attachIconSpace(this.options.iconPosition);
                    }
                }
            }

            this._super(key, value);

            if (key === "disabled") {
                this._toggleClass(null, "ui-state-disabled", value);
                this.element[0].disabled = value;
                if (value) {
                    this.element.blur();
                }
            }
        },

        refresh: function() {

            // Make sure to only check disabled if its an element that supports this otherwise
            // check for the disabled class to determine state
            var isDisabled = this.element.is("input, button") ?
                this.element[0].disabled : this.element.hasClass("ui-button-disabled");

            if (isDisabled !== this.options.disabled) {
                this._setOptions({
                    disabled: isDisabled
                });
            }

            this._updateTooltip();
        }
    });

    // DEPRECATED
    if ($.uiBackCompat !== false) {

        // Text and Icons options
        $.widget("ui.button", $.ui.button, {
            options: {
                text: true,
                icons: {
                    primary: null,
                    secondary: null
                }
            },

            _create: function() {
                if (this.options.showLabel && !this.options.text) {
                    this.options.showLabel = this.options.text;
                }
                if (!this.options.showLabel && this.options.text) {
                    this.options.text = this.options.showLabel;
                }
                if (!this.options.icon && (this.options.icons.primary ||
                        this.options.icons.secondary)) {
                    if (this.options.icons.primary) {
                        this.options.icon = this.options.icons.primary;
                    } else {
                        this.options.icon = this.options.icons.secondary;
                        this.options.iconPosition = "end";
                    }
                } else if (this.options.icon) {
                    this.options.icons.primary = this.options.icon;
                }
                this._super();
            },

            _setOption: function(key, value) {
                if (key === "text") {
                    this._super("showLabel", value);
                    return;
                }
                if (key === "showLabel") {
                    this.options.text = value;
                }
                if (key === "icon") {
                    this.options.icons.primary = value;
                }
                if (key === "icons") {
                    if (value.primary) {
                        this._super("icon", value.primary);
                        this._super("iconPosition", "beginning");
                    } else if (value.secondary) {
                        this._super("icon", value.secondary);
                        this._super("iconPosition", "end");
                    }
                }
                this._superApply(arguments);
            }
        });

        $.fn.button = (function(orig) {
            return function() {
                if (!this.length || (this.length && this[0].tagName !== "INPUT") ||
                    (this.length && this[0].tagName === "INPUT" && (
                        this.attr("type") !== "checkbox" && this.attr("type") !== "radio"
                    ))) {
                    return orig.apply(this, arguments);
                }
                if (!$.ui.checkboxradio) {
                    $.error("Checkboxradio widget missing");
                }
                if (arguments.length === 0) {
                    return this.checkboxradio({
                        "icon": false
                    });
                }
                return this.checkboxradio.apply(this, arguments);
            };
        })($.fn.button);

        $.fn.buttonset = function() {
            if (!$.ui.controlgroup) {
                $.error("Controlgroup widget missing");
            }
            if (arguments[0] === "option" && arguments[1] === "items" && arguments[2]) {
                return this.controlgroup.apply(this, [arguments[0], "items.button", arguments[2]]);
            }
            if (arguments[0] === "option" && arguments[1] === "items") {
                return this.controlgroup.apply(this, [arguments[0], "items.button"]);
            }
            if (typeof arguments[0] === "object" && arguments[0].items) {
                arguments[0].items = {
                    button: arguments[0].items
                };
            }
            return this.controlgroup.apply(this, arguments);
        };
    }

    var widgetsButton = $.ui.button;


    // jscs:disable maximumLineLength
    /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
    /*!
     * jQuery UI Datepicker 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Datepicker
    //>>group: Widgets
    //>>description: Displays a calendar from an input or inline for selecting dates.
    //>>docs: http://api.jqueryui.com/datepicker/
    //>>demos: http://jqueryui.com/datepicker/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/datepicker.css
    //>>css.theme: ../../themes/base/theme.css



    $.extend($.ui, {
        datepicker: {
            version: "1.12.1"
        }
    });

    var datepicker_instActive;

    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {

            // Ignore z-index if position is set to a value where z-index is ignored by the browser
            // This makes behavior of this function consistent across browsers
            // WebKit always returns auto if the element is positioned
            position = elem.css("position");
            if (position === "absolute" || position === "relative" || position === "fixed") {

                // IE returns 0 when zIndex is not specified
                // other browsers return a string
                // we ignore the case of nested elements with an explicit value of 0
                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                value = parseInt(elem.css("zIndex"), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }

        return 0;
    }
    /* Date picker manager.
       Use the singleton instance of this class, $.datepicker, to interact with the date picker.
       Settings for (groups of) date pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */

    function Datepicker() {
        this._curInst = null; // The current instance in use
        this._keyEvent = false; // If the last event was a key event
        this._disabledInputs = []; // List of date picker inputs that have been disabled
        this._datepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
        this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
        this._appendClass = "ui-datepicker-append"; // The name of the append marker class
        this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
        this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
        this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
        this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
        this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
        this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[""] = { // Default regional settings
            closeText: "Done", // Display text for close link
            prevText: "Prev", // Display text for previous month link
            nextText: "Next", // Display text for next month link
            currentText: "Today", // Display text for current month link
            monthNames: ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"
            ], // Names of months for drop-down and formatting
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], // Column headings for days starting at Sunday
            weekHeader: "Wk", // Column header for week of the year
            dateFormat: "mm/dd/yy", // See format options on parseDate
            firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: false, // True if right-to-left language, false if left-to-right
            showMonthAfterYear: false, // True if the year select precedes month, false for month then year
            yearSuffix: "" // Additional text to append to the year in the month headers
        };
        this._defaults = { // Global defaults for all the date picker instances
            showOn: "focus", // "focus" for popup on focus,
            // "button" for trigger button, or "both" for either
            showAnim: "fadeIn", // Name of jQuery animation for popup
            showOptions: {}, // Options for enhanced animations
            defaultDate: null, // Used when field is blank: actual date,
            // +/-number for offset from today, null for today
            appendText: "", // Display text following the input box, e.g. showing the format
            buttonText: "...", // Text for trigger button
            buttonImage: "", // URL for trigger button image
            buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: false, // True to hide next/previous month links
            // if not applicable, false to just disable them
            navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
            gotoCurrent: false, // True if today link goes back to current selection instead
            changeMonth: false, // True if month can be selected directly, false if only prev/next
            changeYear: false, // True if year can be selected directly, false if only prev/next
            yearRange: "c-10:c+10", // Range of years to display in drop-down,
            // either relative to today's year (-nn:+nn), relative to currently displayed year
            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: false, // True to show dates in other months, false to leave blank
            selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
            showWeek: false, // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week, // How to calculate the week of the year,
            // takes a Date and returns the number of the week for it
            shortYearCutoff: "+10", // Short year values < this are in the current century,
            // > this are in the previous century,
            // string value starting with "+" for current year + value
            minDate: null, // The earliest selectable date, or null for no limit
            maxDate: null, // The latest selectable date, or null for no limit
            duration: "fast", // Duration of display/closure
            beforeShowDay: null, // Function that takes a date and returns an array with
            // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
            // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null, // Function that takes an input field and
            // returns a set of custom settings for the date picker
            onSelect: null, // Define a callback function when a date is selected
            onChangeMonthYear: null, // Define a callback function when the month or year is changed
            onClose: null, // Define a callback function when the datepicker is closed
            numberOfMonths: 1, // Number of months to show at a time
            showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1, // Number of months to step back/forward
            stepBigMonths: 12, // Number of months to step back/forward for the big links
            altField: "", // Selector for an alternate field to store selected dates into
            altFormat: "", // The date format to use for the alternate field
            constrainInput: true, // The input is constrained by the current date format
            showButtonPanel: false, // True to show button panel, false to not show it
            autoSize: false, // True to size the input for the date format, false to leave as is
            disabled: false // The initial disabled state
        };
        $.extend(this._defaults, this.regional[""]);
        this.regional.en = $.extend(true, {}, this.regional[""]);
        this.regional["en-US"] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }

    $.extend(Datepicker.prototype, {
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: "hasDatepicker",

        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,

        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function() {
            return this.dpDiv;
        },

        /* Override the default settings for all instances of the date picker.
         * @param  settings  object - the new settings to use as defaults (anonymous object)
         * @return the manager object
         */
        setDefaults: function(settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },

        /* Attach the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         * @param  settings  object - the new settings to use for this date picker instance (anonymous)
         */
        _attachDatepicker: function(target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = (nodeName === "div" || nodeName === "span");
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },

        /* Create a new instance object. */
        _newInst: function(target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
            return {
                id: id,
                input: target, // associated target
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0, // current selection
                drawMonth: 0,
                drawYear: 0, // month being drawn
                inline: inline, // is datepicker inline or not
                dpDiv: (!inline ? this.dpDiv : // presentation div
                    datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))
            };
        },

        /* Attach the date picker to an input field. */
        _connectDatepicker: function(target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).on("keydown", this._doKeyDown).
            on("keypress", this._doKeyPress).on("keyup", this._doKeyUp);
            this._autoSize(inst);
            $.data(target, "datepicker", inst);

            //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },

        /* Make attachments based on settings. */
        _attachments: function(input, inst) {
            var showOn, buttonText, buttonImage,
                appendText = this._get(inst, "appendText"),
                isRTL = this._get(inst, "isRTL");

            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                input[isRTL ? "before" : "after"](inst.append);
            }

            input.off("focus", this._showDatepicker);

            if (inst.trigger) {
                inst.trigger.remove();
            }

            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
                input.on("focus", this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");
                inst.trigger = $(this._get(inst, "buttonImageOnly") ?
                    $("<img/>").addClass(this._triggerClass).attr({
                        src: buttonImage,
                        alt: buttonText,
                        title: buttonText
                    }) :
                    $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                        src: buttonImage,
                        alt: buttonText,
                        title: buttonText
                    })));
                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.on("click", function() {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },

        /* Apply the maximum length for the date format. */
        _autoSize: function(inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i,
                    date = new Date(2009, 12 - 1, 20), // Ensure double digits
                    dateFormat = this._get(inst, "dateFormat");

                if (dateFormat.match(/[DM]/)) {
                    findMax = function(names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                        "monthNames" : "monthNamesShort"))));
                    date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                        "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },

        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, "datepicker", inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);

            //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }

            // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css("display", "block");
        },

        /* Pop-up the date picker in a "dialog" box.
         * @param  input element - ignored
         * @param  date	string or Date - the initial date to display
         * @param  onSelect  function - the function to call when a date is selected
         * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
         * @param  pos int[2] - coordinates for the dialog's position within the screen or
         *					event - with x/y coordinates or
         *					leave empty for default (screen centre)
         * @return the manager object
         */
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY,
                inst = this._dialogInst; // internal instance

            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $("<input type='text' id='" + id +
                    "' style='position: absolute; top: -100px; width: 0px;'/>");
                this._dialogInput.on("keydown", this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], "datepicker", inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
            this._dialogInput.val(date);

            this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = // should use actual width/height below
                    [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
            }

            // Move input on screen for focus, but hidden behind dialog
            this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], "datepicker", inst);
            return this;
        },

        /* Detach a datepicker from its control.
         * @param  target	element - the target input field or division or span
         */
        _destroyDatepicker: function(target) {
            var nodeName,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, "datepicker");
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).
                off("focus", this._showDatepicker).
                off("keydown", this._doKeyDown).
                off("keypress", this._doKeyPress).
                off("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }

            if (datepicker_instActive === inst) {
                datepicker_instActive = null;
            }
        },

        /* Enable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _enableDatepicker: function(target) {
            var nodeName, inline,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger.filter("button").
                each(function() {
                    this.disabled = false;
                }).end().
                filter("img").css({
                    opacity: "1.0",
                    cursor: ""
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                prop("disabled", false);
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) {
                    return (value === target ? null : value);
                }); // delete entry
        },

        /* Disable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _disableDatepicker: function(target) {
            var nodeName, inline,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger.filter("button").
                each(function() {
                    this.disabled = true;
                }).end().
                filter("img").css({
                    opacity: "0.5",
                    cursor: "default"
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                prop("disabled", true);
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) {
                    return (value === target ? null : value);
                }); // delete entry
            this._disabledInputs[this._disabledInputs.length] = target;
        },

        /* Is the first field in a jQuery collection disabled as a datepicker?
         * @param  target	element - the target input field or division or span
         * @return boolean - true if disabled, false if enabled
         */
        _isDisabledDatepicker: function(target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },

        /* Retrieve the instance data for the target control.
         * @param  target  element - the target input field or division or span
         * @return  object - the associated instance data
         * @throws  error if a jQuery problem getting data
         */
        _getInst: function(target) {
            try {
                return $.data(target, "datepicker");
            } catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },

        /* Update or retrieve the settings for a date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         * @param  name	object - the new settings to update or
         *				string - the name of the setting to change or retrieve,
         *				when retrieving also "all" for all instance settings or
         *				"defaults" for all global defaults
         * @param  value   any - the new value for the setting
         *				(omit if above is an object or to retrieve a value)
         */
        _optionDatepicker: function(target, name, value) {
            var settings, date, minDate, maxDate,
                inst = this._getInst(target);

            if (arguments.length === 2 && typeof name === "string") {
                return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
                    (inst ? (name === "all" ? $.extend({}, inst.settings) :
                        this._get(inst, name)) : null));
            }

            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }

            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }

                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                datepicker_extendRemove(inst.settings, settings);

                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },

        // Change method deprecated
        _changeDatepicker: function(target, name, value) {
            this._optionDatepicker(target, name, value);
        },

        /* Redraw the date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         */
        _refreshDatepicker: function(target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },

        /* Set the dates for a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  date	Date - the new date
         */
        _setDateDatepicker: function(target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },

        /* Get the date(s) for the first entry in a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  noDefault boolean - true if no default date is to be used
         * @return Date - the current date
         */
        _getDateDatepicker: function(target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return (inst ? this._getDate(inst) : null);
        },

        /* Handle keystrokes. */
        _doKeyDown: function(event) {
            var onSelect, dateStr, sel,
                inst = $.datepicker._getInst(event.target),
                handled = true,
                isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                    case 9:
                        $.datepicker._hideDatepicker();
                        handled = false;
                        break; // hide on tab out
                    case 13:
                        sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                            $.datepicker._currentClass + ")", inst.dpDiv);
                        if (sel[0]) {
                            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                        }

                        onSelect = $.datepicker._get(inst, "onSelect");
                        if (onSelect) {
                            dateStr = $.datepicker._formatDate(inst);

                            // Trigger custom callback
                            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                        } else {
                            $.datepicker._hideDatepicker();
                        }

                        return false; // don't submit the form
                    case 27:
                        $.datepicker._hideDatepicker();
                        break; // hide on escape
                    case 33:
                        $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                            -$.datepicker._get(inst, "stepBigMonths") :
                            -$.datepicker._get(inst, "stepMonths")), "M");
                        break; // previous month/year on page up/+ ctrl
                    case 34:
                        $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                            +$.datepicker._get(inst, "stepBigMonths") :
                            +$.datepicker._get(inst, "stepMonths")), "M");
                        break; // next month/year on page down/+ ctrl
                    case 35:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._clearDate(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // clear on ctrl or command +end
                    case 36:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._gotoToday(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // current on ctrl or command +home
                    case 37:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                        }
                        handled = event.ctrlKey || event.metaKey;

                        // -1 day on ctrl or command +left
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                -$.datepicker._get(inst, "stepBigMonths") :
                                -$.datepicker._get(inst, "stepMonths")), "M");
                        }

                        // next month/year on alt +left on Mac
                        break;
                    case 38:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, -7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // -1 week on ctrl or command +up
                    case 39:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                        }
                        handled = event.ctrlKey || event.metaKey;

                        // +1 day on ctrl or command +right
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                +$.datepicker._get(inst, "stepBigMonths") :
                                +$.datepicker._get(inst, "stepMonths")), "M");
                        }

                        // next month/year on alt +right
                        break;
                    case 40:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, +7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // +1 week on ctrl or command +down
                    default:
                        handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }

            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },

        /* Filter entered characters - based on date format. */
        _doKeyPress: function(event) {
            var chars, chr,
                inst = $.datepicker._getInst(event.target);

            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
            }
        },

        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function(event) {
            var date,
                inst = $.datepicker._getInst(event.target);

            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                        (inst.input ? inst.input.val() : null),
                        $.datepicker._getFormatConfig(inst));

                    if (date) { // only if valid
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {}
            }
            return true;
        },

        /* Pop-up the date picker for a given input field.
         * If false returned from beforeShow event handler do not show.
         * @param  input  element - the input field attached to the date picker or
         *					event - if triggered by focus
         */
        _showDatepicker: function(input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
                input = $("input", input.parentNode)[0];
            }

            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
                return;
            }

            var inst, beforeShow, beforeShowSettings, isFixed,
                offset, showAnim, duration;

            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }

            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);

            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);

            if ($.datepicker._inDialog) { // hide cursor
                input.value = "";
            }
            if (!$.datepicker._pos) { // position below input
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight; // add the height
            }

            isFixed = false;
            $(input).parents().each(function() {
                isFixed |= $(this).css("position") === "fixed";
                return !isFixed;
            });

            offset = {
                left: $.datepicker._pos[0],
                top: $.datepicker._pos[1]
            };
            $.datepicker._pos = null;

            //to avoid flashes on Firefox
            inst.dpDiv.empty();

            // determine sizing offscreen
            inst.dpDiv.css({
                position: "absolute",
                display: "block",
                top: "-1000px"
            });
            $.datepicker._updateDatepicker(inst);

            // fix width for dynamic number of date pickers
            // and adjust position before showing
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: ($.datepicker._inDialog && $.blockUI ?
                    "static" : (isFixed ? "fixed" : "absolute")),
                display: "none",
                left: offset.left + "px",
                top: offset.top + "px"
            });

            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;

                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }

                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.trigger("focus");
                }

                $.datepicker._curInst = inst;
            }
        },

        /* Generate the date picker content. */
        _updateDatepicker: function(inst) {
            this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
            datepicker_instActive = inst; // for delegate hover events
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);

            var origyearshtml,
                numMonths = this._getNumberOfMonths(inst),
                cols = numMonths[1],
                width = 17,
                activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");

            if (activeCell.length > 0) {
                datepicker_handleMouseover.apply(activeCell.get(0));
            }

            inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
            if (cols > 1) {
                inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
                "Class"]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
                "Class"]("ui-datepicker-rtl");

            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.trigger("focus");
            }

            // Deffered render of the years select (to avoid flashes on Firefox)
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function() {

                    //assure that inst.yearshtml didn't change.
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },

        // #6694 - don't focus the input if it's already focused
        // this breaks the change event in IE
        // Support: IE and jQuery <1.9
        _shouldFocusInput: function(inst) {
            return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },

        /* Check positioning to remain on screen. */
        _checkOffset: function(inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(),
                dpHeight = inst.dpDiv.outerHeight(),
                inputWidth = inst.input ? inst.input.outerWidth() : 0,
                inputHeight = inst.input ? inst.input.outerHeight() : 0,
                viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
                viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

            offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
            offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
            offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

            // Now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
                Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                Math.abs(dpHeight + inputHeight) : 0);

            return offset;
        },

        /* Find an object's position on the screen. */
        _findPos: function(obj) {
            var position,
                inst = this._getInst(obj),
                isRTL = this._get(inst, "isRTL");

            while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }

            position = $(obj).offset();
            return [position.left, position.top];
        },

        /* Hide the date picker from view.
         * @param  input  element - the input field attached to the date picker
         */
        _hideDatepicker: function(input) {
            var showAnim, duration, postProcess, onClose,
                inst = this._curInst;

            if (!inst || (input && inst !== $.data(input, "datepicker"))) {
                return;
            }

            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function() {
                    $.datepicker._tidyDialog(inst);
                };

                // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                } else {
                    inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
                        (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
                }

                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;

                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
                }

                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px"
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },

        /* Tidy up after a dialog display. */
        _tidyDialog: function(inst) {
            inst.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar");
        },

        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function(event) {
            if (!$.datepicker._curInst) {
                return;
            }

            var $target = $(event.target),
                inst = $.datepicker._getInst($target[0]);

            if ((($target[0].id !== $.datepicker._mainDivId &&
                    $target.parents("#" + $.datepicker._mainDivId).length === 0 &&
                    !$target.hasClass($.datepicker.markerClassName) &&
                    !$target.closest("." + $.datepicker._triggerClass).length &&
                    $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))) ||
                ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst)) {
                $.datepicker._hideDatepicker();
            }
        },

        /* Adjust one of the date sub-fields. */
        _adjustDate: function(id, offset, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset +
                (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
                period);
            this._updateDatepicker(inst);
        },

        /* Action for current link. */
        _gotoToday: function(id) {
            var date,
                target = $(id),
                inst = this._getInst(target[0]);

            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a new month/year. */
        _selectMonthYear: function(id, select, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            inst["selected" + (period === "M" ? "Month" : "Year")] =
                inst["draw" + (period === "M" ? "Month" : "Year")] =
                parseInt(select.options[select.selectedIndex].value, 10);

            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a day. */
        _selectDay: function(id, month, year, td) {
            var inst,
                target = $(id);

            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }

            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $("a", td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst,
                inst.currentDay, inst.currentMonth, inst.currentYear));
        },

        /* Erase the input field and hide the date picker. */
        _clearDate: function(id) {
            var target = $(id);
            this._selectDate(target, "");
        },

        /* Update the input field with the selected date. */
        _selectDate: function(id, dateStr) {
            var onSelect,
                target = $(id),
                inst = this._getInst(target[0]);

            dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);

            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]); // trigger custom callback
            } else if (inst.input) {
                inst.input.trigger("change"); // fire the change event
            }

            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof(inst.input[0]) !== "object") {
                    inst.input.trigger("focus"); // restore focus
                }
                this._lastInput = null;
            }
        },

        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function(inst) {
            var altFormat, date, dateStr,
                altField = this._get(inst, "altField");

            if (altField) { // update alternate field too
                altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).val(dateStr);
            }
        },

        /* Set as beforeShowDay function to prevent selection of weekends.
         * @param  date  Date - the date to customise
         * @return [boolean, string] - is this date selectable?, what is its CSS class?
         */
        noWeekends: function(date) {
            var day = date.getDay();
            return [(day > 0 && day < 6), ""];
        },

        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
         * @param  date  Date - the date to get the week for
         * @return  number - the number of the week within the year that contains this date
         */
        iso8601Week: function(date) {
            var time,
                checkDate = new Date(date.getTime());

            // Find Thursday of this week starting on Monday
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

            time = checkDate.getTime();
            checkDate.setMonth(0); // Compare with Jan 1
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        },

        /* Parse a string value into a date object.
         * See formatDate below for the possible formats.
         *
         * @param  format string - the expected format of the date
         * @param  value string - the date in the above format
         * @param  settings Object - attributes include:
         *					shortYearCutoff  number - the cutoff year for determining the century (optional)
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  Date - the extracted date value or null if value is blank
         */
        parseDate: function(format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }

            value = (typeof value === "object" ? value.toString() : value + "");
            if (value === "") {
                return null;
            }

            var iFormat, dim, extra,
                iValue = 0,
                shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                    new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
                dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                year = -1,
                month = -1,
                day = -1,
                doy = -1,
                literal = false,
                date,

                // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },

                // Extract a number from the string value
                getNumber = function(match) {
                    var isDoubled = lookAhead(match),
                        size = (match === "@" ? 14 : (match === "!" ? 20 :
                            (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                        minSize = (match === "y" ? size : 1),
                        digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
                        num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                },

                // Extract a name from the string value and convert to an index
                getName = function(match, shortNames, longNames) {
                    var index = -1,
                        names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                            return [
                                [k, v]
                            ];
                        }).sort(function(a, b) {
                            return -(a[1].length - b[1].length);
                        });

                    $.each(names, function(i, pair) {
                        var name = pair[1];
                        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                },

                // Confirm that a literal character matches the string value
                checkLiteral = function() {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                            day = getNumber("d");
                            break;
                        case "D":
                            getName("D", dayNamesShort, dayNames);
                            break;
                        case "o":
                            doy = getNumber("o");
                            break;
                        case "m":
                            month = getNumber("m");
                            break;
                        case "M":
                            month = getName("M", monthNamesShort, monthNames);
                            break;
                        case "y":
                            year = getNumber("y");
                            break;
                        case "@":
                            date = new Date(getNumber("@"));
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "!":
                            date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "'":
                            if (lookAhead("'")) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            checkLiteral();
                    }
                }
            }

            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }

            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                    (year <= shortYearCutoff ? 0 : -100);
            }

            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }

            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw "Invalid date"; // E.g. 31/02/00
            }
            return date;
        },

        /* Standard date formats. */
        ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y", // RFC 822
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd", // ISO 8601

        _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
            Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

        /* Format a date object into a string value.
         * The format can be combinations of the following:
         * d  - day of month (no leading zero)
         * dd - day of month (two digit)
         * o  - day of year (no leading zeros)
         * oo - day of year (three digit)
         * D  - day name short
         * DD - day name long
         * m  - month of year (no leading zero)
         * mm - month of year (two digit)
         * M  - month name short
         * MM - month name long
         * y  - year (two digit)
         * yy - year (four digit)
         * @ - Unix timestamp (ms since 01/01/1970)
         * ! - Windows ticks (100ns since 01/01/0001)
         * "..." - literal text
         * '' - single quote
         *
         * @param  format string - the desired format of the date
         * @param  date Date - the date value to format
         * @param  settings Object - attributes include:
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  string - the date in the above format
         */
        formatDate: function(format, date, settings) {
            if (!date) {
                return "";
            }

            var iFormat,
                dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,

                // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },

                // Format a number, with leading zero if necessary
                formatNumber = function(match, value, len) {
                    var num = "" + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = "0" + num;
                        }
                    }
                    return num;
                },

                // Format a name, short or long as requested
                formatName = function(match, value, shortNames, longNames) {
                    return (lookAhead(match) ? longNames[value] : shortNames[value]);
                },
                output = "",
                literal = false;

            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                            case "d":
                                output += formatNumber("d", date.getDate(), 2);
                                break;
                            case "D":
                                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                break;
                            case "o":
                                output += formatNumber("o",
                                    Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                                break;
                            case "m":
                                output += formatNumber("m", date.getMonth() + 1, 2);
                                break;
                            case "M":
                                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                break;
                            case "y":
                                output += (lookAhead("y") ? date.getFullYear() :
                                    (date.getFullYear() % 100 < 10 ? "0" : "") + date.getFullYear() % 100);
                                break;
                            case "@":
                                output += date.getTime();
                                break;
                            case "!":
                                output += date.getTime() * 10000 + this._ticksTo1970;
                                break;
                            case "'":
                                if (lookAhead("'")) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },

        /* Extract all possible characters from the date format. */
        _possibleChars: function(format) {
            var iFormat,
                chars = "",
                literal = false,

                // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                        case "m":
                        case "y":
                        case "@":
                            chars += "0123456789";
                            break;
                        case "D":
                        case "M":
                            return null; // Accept anything
                        case "'":
                            if (lookAhead("'")) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },

        /* Get a setting value, defaulting if necessary. */
        _get: function(inst, name) {
            return inst.settings[name] !== undefined ?
                inst.settings[name] : this._defaults[name];
        },

        /* Parse existing date and initialise date picker. */
        _setDateFromField: function(inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }

            var dateFormat = this._get(inst, "dateFormat"),
                dates = inst.lastVal = inst.input ? inst.input.val() : null,
                defaultDate = this._getDefaultDate(inst),
                date = defaultDate,
                settings = this._getFormatConfig(inst);

            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = (noDefault ? "" : dates);
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = (dates ? date.getDate() : 0);
            inst.currentMonth = (dates ? date.getMonth() : 0);
            inst.currentYear = (dates ? date.getFullYear() : 0);
            this._adjustInstDate(inst);
        },

        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function(inst) {
            return this._restrictMinMax(inst,
                this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },

        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function(inst, date, defaultDate) {
            var offsetNumeric = function(offset) {
                    var date = new Date();
                    date.setDate(date.getDate() + offset);
                    return date;
                },
                offsetString = function(offset) {
                    try {
                        return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                            offset, $.datepicker._getFormatConfig(inst));
                    } catch (e) {

                        // Ignore
                    }

                    var date = (offset.toLowerCase().match(/^c/) ?
                            $.datepicker._getDate(inst) : null) || new Date(),
                        year = date.getFullYear(),
                        month = date.getMonth(),
                        day = date.getDate(),
                        pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                        matches = pattern.exec(offset);

                    while (matches) {
                        switch (matches[2] || "d") {
                            case "d":
                            case "D":
                                day += parseInt(matches[1], 10);
                                break;
                            case "w":
                            case "W":
                                day += parseInt(matches[1], 10) * 7;
                                break;
                            case "m":
                            case "M":
                                month += parseInt(matches[1], 10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                            case "y":
                            case "Y":
                                year += parseInt(matches[1], 10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                },
                newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
                    (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

            newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },

        /* Handle switch to/from daylight saving.
         * Hours may be non-zero on daylight saving cut-over:
         * > 12 when midnight changeover, but then cannot generate
         * midnight datetime, so jump to 1AM, otherwise reset.
         * @param  date  (Date) the date to check
         * @return  (Date) the corrected date
         */
        _daylightSavingAdjust: function(date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },

        /* Set the date(s) directly. */
        _setDate: function(inst, date, noChange) {
            var clear = !date,
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },

        /* Retrieve the date(s) directly. */
        _getDate: function(inst) {
            var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
                this._daylightSavingAdjust(new Date(
                    inst.currentYear, inst.currentMonth, inst.currentDay)));
            return startDate;
        },

        /* Attach the onxxx handlers.  These are declared statically so
         * they work with static code transformers like Caja.
         */
        _attachHandlers: function(inst) {
            var stepMonths = this._get(inst, "stepMonths"),
                id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function() {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function() {
                        $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                        return false;
                    },
                    selectMonth: function() {
                        $.datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function() {
                        $.datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    }
                };
                $(this).on(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },

        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function(inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                tempDate = new Date(),
                today = this._daylightSavingAdjust(
                    new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
                isRTL = this._get(inst, "isRTL"),
                showButtonPanel = this._get(inst, "showButtonPanel"),
                hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
                numMonths = this._getNumberOfMonths(inst),
                showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                stepMonths = this._get(inst, "stepMonths"),
                isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
                currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                    new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                drawMonth = inst.drawMonth - showCurrentAtPos,
                drawYear = inst.drawYear;

            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                    maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
                maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;

            prevText = this._get(inst, "prevText");
            prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
                this._getFormatConfig(inst)));

            prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
                (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

            nextText = this._get(inst, "nextText");
            nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
                this._getFormatConfig(inst)));

            next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
                (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

            currentText = this._get(inst, "currentText");
            gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
            currentText = (!navigationAsDateFormat ? currentText :
                this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

            controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                this._get(inst, "closeText") + "</button>" : "");

            buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
                (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                    ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = (isNaN(firstDay) ? 0 : firstDay);

            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";

            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                                case 0:
                                    calender += " ui-datepicker-group-first";
                                    cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                    break;
                                case numMonths[1] - 1:
                                    calender += " ui-datepicker-group-last";
                                    cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                    break;
                                default:
                                    calender += " ui-datepicker-group-middle";
                                    cornerClass = "";
                                    break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                        (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
                        (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
                        this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                            row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                        "</div><table class='ui-datepicker-calendar'><thead>" +
                        "<tr>";
                    thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
                    for (dow = 0; dow < 7; dow++) { // days of the week
                        day = (dow + firstDay) % 7;
                        thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
                            "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                    numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                        calender += "<tr>";
                        tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                            this._get(inst, "calculateWeek")(printDate) + "</td>");
                        for (dow = 0; dow < 7; dow++) { // create date picker days
                            daySettings = (beforeShowDay ?
                                beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                            otherMonth = (printDate.getMonth() !== drawMonth);
                            unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                                (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                            tbody += "<td class='" +
                                ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                                (otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                                ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                                    (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?

                                    // or defaultDate is current printedDate and defaultDate is selectedDate
                                    " " + this._dayOverClass : "") + // highlight selected day
                                (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + // highlight unselectable days
                                (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                                    (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                                    (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                                ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                                (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                                (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                    (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                                        (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                                        (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                                        (otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                                        "' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                        ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },

        /* Generate the month and year header. */
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
            secondary, monthNames, monthNamesShort) {

            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                changeMonth = this._get(inst, "changeMonth"),
                changeYear = this._get(inst, "changeYear"),
                showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                html = "<div class='ui-datepicker-title'>",
                monthHtml = "";

            // Month selection
            if (secondary || !changeMonth) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
            } else {
                inMinYear = (minDate && minDate.getFullYear() === drawYear);
                inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += "<option value='" + month + "'" +
                            (month === drawMonth ? " selected='selected'" : "") +
                            ">" + monthNamesShort[month] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }

            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }

            // Year selection
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {

                    // determine range of years to display
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function(value) {
                        var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                            (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
                                parseInt(value, 10)));
                        return (isNaN(year) ? thisYear : year);
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                    endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for (; year <= endYear; year++) {
                        inst.yearshtml += "<option value='" + year + "'" +
                            (year === drawYear ? " selected='selected'" : "") +
                            ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";

                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }

            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
            }
            html += "</div>"; // Close datepicker_header
            return html;
        },

        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function(inst, offset, period) {
            var year = inst.selectedYear + (period === "Y" ? offset : 0),
                month = inst.selectedMonth + (period === "M" ? offset : 0),
                day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
                date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },

        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function(inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                newDate = (minDate && date < minDate ? minDate : date);
            return (maxDate && newDate > maxDate ? maxDate : newDate);
        },

        /* Notify change of month/year. */
        _notifyChange: function(inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply((inst.input ? inst.input[0] : null), [inst.selectedYear, inst.selectedMonth + 1, inst]);
            }
        },

        /* Determine the number of months to show. */
        _getNumberOfMonths: function(inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
        },

        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function(inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },

        /* Find the number of days in a given month. */
        _getDaysInMonth: function(year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },

        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay();
        },

        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst),
                date = this._daylightSavingAdjust(new Date(curYear,
                    curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },

        /* Is the given date in the accepted range? */
        _isInRange: function(inst, date) {
            var yearSplit, currentYear,
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                minYear = null,
                maxYear = null,
                years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }

            return ((!minDate || date.getTime() >= minDate.getTime()) &&
                (!maxDate || date.getTime() <= maxDate.getTime()) &&
                (!minYear || date.getFullYear() >= minYear) &&
                (!maxYear || date.getFullYear() <= maxYear));
        },

        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function(inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
                new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"),
                dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"),
                monthNames: this._get(inst, "monthNames")
            };
        },

        /* Format the given date for display. */
        _formatDate: function(inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = (day ? (typeof day === "object" ? day :
                    this._daylightSavingAdjust(new Date(year, month, day))) :
                this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    });

    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */
    function datepicker_bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.on("mouseout", selector, function() {
                $(this).removeClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).removeClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).removeClass("ui-datepicker-next-hover");
                }
            })
            .on("mouseover", selector, datepicker_handleMouseover);
    }

    function datepicker_handleMouseover() {
        if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
            $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
            $(this).addClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).addClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).addClass("ui-datepicker-next-hover");
            }
        }
    }

    /* jQuery extend now ignores nulls! */
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }

    /* Invoke the datepicker functionality.
       @param  options  string - a command, optionally followed by additional parameters or
    					Object - settings for attaching new datepicker functionality
       @return  jQuery object */
    $.fn.datepicker = function(options) {

        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if (!this.length) {
            return this;
        }

        /* Initialise the date picker. */
        if (!$.datepicker.initialized) {
            $(document).on("mousedown", $.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }

        /* Append datepicker main container to body if not exist. */
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }

        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
            return $.datepicker["_" + options + "Datepicker"].
            apply($.datepicker, [this[0]].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
            return $.datepicker["_" + options + "Datepicker"].
            apply($.datepicker, [this[0]].concat(otherArgs));
        }
        return this.each(function() {
            typeof options === "string" ?
                $.datepicker["_" + options + "Datepicker"].
            apply($.datepicker, [this].concat(otherArgs)):
                $.datepicker._attachDatepicker(this, options);
        });
    };

    $.datepicker = new Datepicker(); // singleton instance
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.12.1";

    var widgetsDatepicker = $.datepicker;




    // This file is deprecated
    var ie = $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

    /*!
     * jQuery UI Mouse 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Mouse
    //>>group: Widgets
    //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
    //>>docs: http://api.jqueryui.com/mouse/



    var mouseHandled = false;
    $(document).on("mouseup", function() {
        mouseHandled = false;
    });

    var widgetsMouse = $.widget("ui.mouse", {
        version: "1.12.1",
        options: {
            cancel: "input, textarea, button, select, option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;

            this.element
                .on("mousedown." + this.widgetName, function(event) {
                    return that._mouseDown(event);
                })
                .on("click." + this.widgetName, function(event) {
                    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            this.started = false;
        },

        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function() {
            this.element.off("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                this.document
                    .off("mousemove." + this.widgetName, this._mouseMoveDelegate)
                    .off("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },

        _mouseDown: function(event) {

            // don't let more than one widget handle mouseStart
            if (mouseHandled) {
                return;
            }

            this._mouseMoved = false;

            // We may have missed mouseup (out of window)
            (this._mouseStarted && this._mouseUp(event));

            this._mouseDownEvent = event;

            var that = this,
                btnIsLeft = (event.which === 1),

                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ?
                    $(event.target).closest(this.options.cancel).length : false);
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }

            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = (this._mouseStart(event) !== false);
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }

            // Click event may never have fired (Gecko & Opera)
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }

            // These delegates are required to keep context
            this._mouseMoveDelegate = function(event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function(event) {
                return that._mouseUp(event);
            };

            this.document
                .on("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .on("mouseup." + this.widgetName, this._mouseUpDelegate);

            event.preventDefault();

            mouseHandled = true;
            return true;
        },

        _mouseMove: function(event) {

            // Only check for mouseups outside the document if you've moved inside the document
            // at least once. This prevents the firing of mouseup in the case of IE<9, which will
            // fire a mousemove event if content is placed under the cursor. See #7778
            // Support: IE <9
            if (this._mouseMoved) {

                // IE mouseup check - mouseup happened when mouse was out of window
                if ($.ui.ie && (!document.documentMode || document.documentMode < 9) &&
                    !event.button) {
                    return this._mouseUp(event);

                    // Iframe mouseup check - mouseup occurred in another document
                } else if (!event.which) {

                    // Support: Safari <=8 - 9
                    // Safari sets which to 0 if you press any of the following keys
                    // during a drag (#14461)
                    if (event.originalEvent.altKey || event.originalEvent.ctrlKey ||
                        event.originalEvent.metaKey || event.originalEvent.shiftKey) {
                        this.ignoreMissingWhich = true;
                    } else if (!this.ignoreMissingWhich) {
                        return this._mouseUp(event);
                    }
                }
            }

            if (event.which || event.button) {
                this._mouseMoved = true;
            }

            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted =
                    (this._mouseStart(this._mouseDownEvent, event) !== false);
                (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
            }

            return !this._mouseStarted;
        },

        _mouseUp: function(event) {
            this.document
                .off("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .off("mouseup." + this.widgetName, this._mouseUpDelegate);

            if (this._mouseStarted) {
                this._mouseStarted = false;

                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }

                this._mouseStop(event);
            }

            if (this._mouseDelayTimer) {
                clearTimeout(this._mouseDelayTimer);
                delete this._mouseDelayTimer;
            }

            this.ignoreMissingWhich = false;
            mouseHandled = false;
            event.preventDefault();
        },

        _mouseDistanceMet: function(event) {
            return (Math.max(
                Math.abs(this._mouseDownEvent.pageX - event.pageX),
                Math.abs(this._mouseDownEvent.pageY - event.pageY)
            ) >= this.options.distance);
        },

        _mouseDelayMet: function( /* event */ ) {
            return this.mouseDelayMet;
        },

        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function( /* event */ ) {},
        _mouseDrag: function( /* event */ ) {},
        _mouseStop: function( /* event */ ) {},
        _mouseCapture: function( /* event */ ) {
            return true;
        }
    });




    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    var plugin = $.ui.plugin = {
        add: function(module, option, set) {
            var i,
                proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([option, set[i]]);
            }
        },
        call: function(instance, name, args, allowDisconnected) {
            var i,
                set = instance.plugins[name];

            if (!set) {
                return;
            }

            if (!allowDisconnected && (!instance.element[0].parentNode ||
                    instance.element[0].parentNode.nodeType === 11)) {
                return;
            }

            for (i = 0; i < set.length; i++) {
                if (instance.options[set[i][0]]) {
                    set[i][1].apply(instance.element, args);
                }
            }
        }
    };



    var safeBlur = $.ui.safeBlur = function(element) {

        // Support: IE9 - 10 only
        // If the <body> is blurred, IE will switch windows, see #9420
        if (element && element.nodeName.toLowerCase() !== "body") {
            $(element).trigger("blur");
        }
    };


    /*!
     * jQuery UI Draggable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Draggable
    //>>group: Interactions
    //>>description: Enables dragging functionality for any element.
    //>>docs: http://api.jqueryui.com/draggable/
    //>>demos: http://jqueryui.com/draggable/
    //>>css.structure: ../../themes/base/draggable.css



    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,

            // Callbacks
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {

            if (this.options.helper === "original") {
                this._setPositionRelative();
            }
            if (this.options.addClasses) {
                this._addClass("ui-draggable");
            }
            this._setHandleClassName();

            this._mouseInit();
        },

        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "handle") {
                this._removeHandleClassName();
                this._setHandleClassName();
            }
        },

        _destroy: function() {
            if ((this.helper || this.element).is(".ui-draggable-dragging")) {
                this.destroyOnClear = true;
                return;
            }
            this._removeHandleClassName();
            this._mouseDestroy();
        },

        _mouseCapture: function(event) {
            var o = this.options;

            // Among others, prevent a drag on a resizable-handle
            if (this.helper || o.disabled ||
                $(event.target).closest(".ui-resizable-handle").length > 0) {
                return false;
            }

            //Quit if we're not on a valid handle
            this.handle = this._getHandle(event);
            if (!this.handle) {
                return false;
            }

            this._blurActiveElement(event);

            this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);

            return true;

        },

        _blockFrames: function(selector) {
            this.iframeBlocks = this.document.find(selector).map(function() {
                var iframe = $(this);

                return $("<div>")
                    .css("position", "absolute")
                    .appendTo(iframe.parent())
                    .outerWidth(iframe.outerWidth())
                    .outerHeight(iframe.outerHeight())
                    .offset(iframe.offset())[0];
            });
        },

        _unblockFrames: function() {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },

        _blurActiveElement: function(event) {
            var activeElement = $.ui.safeActiveElement(this.document[0]),
                target = $(event.target);

            // Don't blur if the event occurred on an element that is within
            // the currently focused element
            // See #10527, #12472
            if (target.closest(activeElement).length) {
                return;
            }

            // Blur any element that currently has focus, see #4261
            $.ui.safeBlur(activeElement);
        },

        _mouseStart: function(event) {

            var o = this.options;

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            this._addClass(this.helper, "ui-draggable-dragging");

            //Cache the helper size
            this._cacheHelperProportions();

            //If ddmanager is used for droppables, set the global draggable
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Store the helper's css position
            this.cssPosition = this.helper.css("position");
            this.scrollParent = this.helper.scrollParent(true);
            this.offsetParent = this.helper.offsetParent();
            this.hasFixedAncestor = this.helper.parents().filter(function() {
                return $(this).css("position") === "fixed";
            }).length > 0;

            //The element's absolute position on the page minus margins
            this.positionAbs = this.element.offset();
            this._refreshOffsets(event);

            //Generate the original position
            this.originalPosition = this.position = this._generatePosition(event, false);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

            //Set a containment if given in the options
            this._setContainment();

            //Trigger event + callbacks
            if (this._trigger("start", event) === false) {
                this._clear();
                return false;
            }

            //Recache the helper size
            this._cacheHelperProportions();

            //Prepare the droppable offsets
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            // Execute the drag once - this causes the helper not to be visible before getting its
            // correct position
            this._mouseDrag(event, true);

            // If the ddmanager is used for droppables, inform the manager that dragging has started
            // (see #5003)
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStart(this, event);
            }

            return true;
        },

        _refreshOffsets: function(event) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: false,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            };

            this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            };
        },

        _mouseDrag: function(event, noPropagation) {

            // reset any necessary cached properties (see #5009)
            if (this.hasFixedAncestor) {
                this.offset.parent = this._getParentOffset();
            }

            //Compute the helpers position
            this.position = this._generatePosition(event, true);
            this.positionAbs = this._convertPositionTo("absolute");

            //Call plugins and callbacks and use the resulting position if something is returned
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp(new $.Event("mouseup", event));
                    return false;
                }
                this.position = ui.position;
            }

            this.helper[0].style.left = this.position.left + "px";
            this.helper[0].style.top = this.position.top + "px";

            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            return false;
        },

        _mouseStop: function(event) {

            //If we are using droppables, inform the manager about the drop
            var that = this,
                dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                dropped = $.ui.ddmanager.drop(this, event);
            }

            //if a drop comes from outside (a sortable)
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false;
            }

            if ((this.options.revert === "invalid" && !dropped) ||
                (this.options.revert === "valid" && dropped) ||
                this.options.revert === true || ($.isFunction(this.options.revert) &&
                    this.options.revert.call(this.element, dropped))
            ) {
                $(this.helper).animate(
                    this.originalPosition,
                    parseInt(this.options.revertDuration, 10),
                    function() {
                        if (that._trigger("stop", event) !== false) {
                            that._clear();
                        }
                    }
                );
            } else {
                if (this._trigger("stop", event) !== false) {
                    this._clear();
                }
            }

            return false;
        },

        _mouseUp: function(event) {
            this._unblockFrames();

            // If the ddmanager is used for droppables, inform the manager that dragging has stopped
            // (see #5003)
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStop(this, event);
            }

            // Only need to focus if the event occurred on the draggable itself, see #10527
            if (this.handleElement.is(event.target)) {

                // The interaction is over; whether or not the click resulted in a drag,
                // focus the element
                this.element.trigger("focus");
            }

            return $.ui.mouse.prototype._mouseUp.call(this, event);
        },

        cancel: function() {

            if (this.helper.is(".ui-draggable-dragging")) {
                this._mouseUp(new $.Event("mouseup", {
                    target: this.element[0]
                }));
            } else {
                this._clear();
            }

            return this;

        },

        _getHandle: function(event) {
            return this.options.handle ?
                !!$(event.target).closest(this.element.find(this.options.handle)).length :
                true;
        },

        _setHandleClassName: function() {
            this.handleElement = this.options.handle ?
                this.element.find(this.options.handle) : this.element;
            this._addClass(this.handleElement, "ui-draggable-handle");
        },

        _removeHandleClassName: function() {
            this._removeClass(this.handleElement, "ui-draggable-handle");
        },

        _createHelper: function(event) {

            var o = this.options,
                helperIsFunction = $.isFunction(o.helper),
                helper = helperIsFunction ?
                $(o.helper.apply(this.element[0], [event])) :
                (o.helper === "clone" ?
                    this.element.clone().removeAttr("id") :
                    this.element);

            if (!helper.parents("body").length) {
                helper.appendTo((o.appendTo === "parent" ?
                    this.element[0].parentNode :
                    o.appendTo));
            }

            // Http://bugs.jqueryui.com/ticket/9446
            // a helper function can return the original element
            // which wouldn't have been set to relative in _create
            if (helperIsFunction && helper[0] === this.element[0]) {
                this._setPositionRelative();
            }

            if (helper[0] !== this.element[0] &&
                !(/(fixed|absolute)/).test(helper.css("position"))) {
                helper.css("position", "absolute");
            }

            return helper;

        },

        _setPositionRelative: function() {
            if (!(/^(?:r|a|f)/).test(this.element.css("position"))) {
                this.element[0].style.position = "relative";
            }
        },

        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },

        _isRootNode: function(element) {
            return (/(html|body)/i).test(element.tagName) || element === this.document[0];
        },

        _getParentOffset: function() {

            //Get the offsetParent and cache its position
            var po = this.offsetParent.offset(),
                document = this.document[0];

            // This is a special case where we need to modify a offset calculated on start, since the
            // following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the
            // next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
            // the document, which means that the scroll is included in the initial calculation of the
            // offset of the parent, and never recalculated upon drag
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document &&
                $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            if (this._isRootNode(this.offsetParent[0])) {
                po = {
                    top: 0,
                    left: 0
                };
            }

            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };

        },

        _getRelativeOffset: function() {
            if (this.cssPosition !== "relative") {
                return {
                    top: 0,
                    left: 0
                };
            }

            var p = this.element.position(),
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);

            return {
                top: p.top - (parseInt(this.helper.css("top"), 10) || 0) +
                    (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
                left: p.left - (parseInt(this.helper.css("left"), 10) || 0) +
                    (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
            };

        },

        _cacheMargins: function() {
            this.margins = {
                left: (parseInt(this.element.css("marginLeft"), 10) || 0),
                top: (parseInt(this.element.css("marginTop"), 10) || 0),
                right: (parseInt(this.element.css("marginRight"), 10) || 0),
                bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
            };
        },

        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },

        _setContainment: function() {

            var isUserScrollable, c, ce,
                o = this.options,
                document = this.document[0];

            this.relativeContainer = null;

            if (!o.containment) {
                this.containment = null;
                return;
            }

            if (o.containment === "window") {
                this.containment = [
                    $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                    $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                    $(window).scrollLeft() + $(window).width() -
                    this.helperProportions.width - this.margins.left,
                    $(window).scrollTop() +
                    ($(window).height() || document.body.parentNode.scrollHeight) -
                    this.helperProportions.height - this.margins.top
                ];
                return;
            }

            if (o.containment === "document") {
                this.containment = [
                    0,
                    0,
                    $(document).width() - this.helperProportions.width - this.margins.left,
                    ($(document).height() || document.body.parentNode.scrollHeight) -
                    this.helperProportions.height - this.margins.top
                ];
                return;
            }

            if (o.containment.constructor === Array) {
                this.containment = o.containment;
                return;
            }

            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }

            c = $(o.containment);
            ce = c[0];

            if (!ce) {
                return;
            }

            isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));

            this.containment = [
                (parseInt(c.css("borderLeftWidth"), 10) || 0) +
                (parseInt(c.css("paddingLeft"), 10) || 0),
                (parseInt(c.css("borderTopWidth"), 10) || 0) +
                (parseInt(c.css("paddingTop"), 10) || 0),
                (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) -
                (parseInt(c.css("borderRightWidth"), 10) || 0) -
                (parseInt(c.css("paddingRight"), 10) || 0) -
                this.helperProportions.width -
                this.margins.left -
                this.margins.right,
                (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) -
                (parseInt(c.css("borderBottomWidth"), 10) || 0) -
                (parseInt(c.css("paddingBottom"), 10) || 0) -
                this.helperProportions.height -
                this.margins.top -
                this.margins.bottom
            ];
            this.relativeContainer = c;
        },

        _convertPositionTo: function(d, pos) {

            if (!pos) {
                pos = this.position;
            }

            var mod = d === "absolute" ? 1 : -1,
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);

            return {
                top: (

                    // The absolute mouse position
                    pos.top +

                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top * mod +

                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top * mod -
                    ((this.cssPosition === "fixed" ?
                        -this.offset.scroll.top :
                        (scrollIsRootNode ? 0 : this.offset.scroll.top)) * mod)
                ),
                left: (

                    // The absolute mouse position
                    pos.left +

                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left * mod +

                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left * mod -
                    ((this.cssPosition === "fixed" ?
                        -this.offset.scroll.left :
                        (scrollIsRootNode ? 0 : this.offset.scroll.left)) * mod)
                )
            };

        },

        _generatePosition: function(event, constrainPosition) {

            var containment, co, top, left,
                o = this.options,
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
                pageX = event.pageX,
                pageY = event.pageY;

            // Cache the scroll
            if (!scrollIsRootNode || !this.offset.scroll) {
                this.offset.scroll = {
                    top: this.scrollParent.scrollTop(),
                    left: this.scrollParent.scrollLeft()
                };
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            // If we are not dragging yet, we won't check for options
            if (constrainPosition) {
                if (this.containment) {
                    if (this.relativeContainer) {
                        co = this.relativeContainer.offset();
                        containment = [
                            this.containment[0] + co.left,
                            this.containment[1] + co.top,
                            this.containment[2] + co.left,
                            this.containment[3] + co.top
                        ];
                    } else {
                        containment = this.containment;
                    }

                    if (event.pageX - this.offset.click.left < containment[0]) {
                        pageX = containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < containment[1]) {
                        pageY = containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > containment[2]) {
                        pageX = containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > containment[3]) {
                        pageY = containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {

                    //Check for grid elements set to 0 to prevent divide by 0 error causing invalid
                    // argument errors in IE (see ticket #6950)
                    top = o.grid[1] ? this.originalPageY + Math.round((pageY -
                        this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                    pageY = containment ? ((top - this.offset.click.top >= containment[1] ||
                            top - this.offset.click.top > containment[3]) ?
                        top :
                        ((top - this.offset.click.top >= containment[1]) ?
                            top - o.grid[1] : top + o.grid[1])) : top;

                    left = o.grid[0] ? this.originalPageX +
                        Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] :
                        this.originalPageX;
                    pageX = containment ? ((left - this.offset.click.left >= containment[0] ||
                            left - this.offset.click.left > containment[2]) ?
                        left :
                        ((left - this.offset.click.left >= containment[0]) ?
                            left - o.grid[0] : left + o.grid[0])) : left;
                }

                if (o.axis === "y") {
                    pageX = this.originalPageX;
                }

                if (o.axis === "x") {
                    pageY = this.originalPageY;
                }
            }

            return {
                top: (

                    // The absolute mouse position
                    pageY -

                    // Click offset (relative to the element)
                    this.offset.click.top -

                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top -

                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top +
                    (this.cssPosition === "fixed" ?
                        -this.offset.scroll.top :
                        (scrollIsRootNode ? 0 : this.offset.scroll.top))
                ),
                left: (

                    // The absolute mouse position
                    pageX -

                    // Click offset (relative to the element)
                    this.offset.click.left -

                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left -

                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left +
                    (this.cssPosition === "fixed" ?
                        -this.offset.scroll.left :
                        (scrollIsRootNode ? 0 : this.offset.scroll.left))
                )
            };

        },

        _clear: function() {
            this._removeClass(this.helper, "ui-draggable-dragging");
            if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
            if (this.destroyOnClear) {
                this.destroy();
            }
        },

        // From now on bulk stuff - mainly helpers

        _trigger: function(type, event, ui) {
            ui = ui || this._uiHash();
            $.ui.plugin.call(this, type, [event, ui, this], true);

            // Absolute position and offset (see #6884 ) have to be recalculated after plugins
            if (/^(drag|start|stop)/.test(type)) {
                this.positionAbs = this._convertPositionTo("absolute");
                ui.offset = this.positionAbs;
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui);
        },

        plugins: {},

        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }

    });

    $.ui.plugin.add("draggable", "connectToSortable", {
        start: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });

            draggable.sortables = [];
            $(draggable.options.connectToSortable).each(function() {
                var sortable = $(this).sortable("instance");

                if (sortable && !sortable.options.disabled) {
                    draggable.sortables.push(sortable);

                    // RefreshPositions is called at drag start to refresh the containerCache
                    // which is used in drag. This ensures it's initialized and synchronized
                    // with any changes that might have happened on the page since initialization.
                    sortable.refreshPositions();
                    sortable._trigger("activate", event, uiSortable);
                }
            });
        },
        stop: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });

            draggable.cancelHelperRemoval = false;

            $.each(draggable.sortables, function() {
                var sortable = this;

                if (sortable.isOver) {
                    sortable.isOver = 0;

                    // Allow this sortable to handle removing the helper
                    draggable.cancelHelperRemoval = true;
                    sortable.cancelHelperRemoval = false;

                    // Use _storedCSS To restore properties in the sortable,
                    // as this also handles revert (#9675) since the draggable
                    // may have modified them in unexpected ways (#8809)
                    sortable._storedCSS = {
                        position: sortable.placeholder.css("position"),
                        top: sortable.placeholder.css("top"),
                        left: sortable.placeholder.css("left")
                    };

                    sortable._mouseStop(event);

                    // Once drag has ended, the sortable should return to using
                    // its original helper, not the shared helper from draggable
                    sortable.options.helper = sortable.options._helper;
                } else {

                    // Prevent this Sortable from removing the helper.
                    // However, don't set the draggable to remove the helper
                    // either as another connected Sortable may yet handle the removal.
                    sortable.cancelHelperRemoval = true;

                    sortable._trigger("deactivate", event, uiSortable);
                }
            });
        },
        drag: function(event, ui, draggable) {
            $.each(draggable.sortables, function() {
                var innermostIntersecting = false,
                    sortable = this;

                // Copy over variables that sortable's _intersectsWith uses
                sortable.positionAbs = draggable.positionAbs;
                sortable.helperProportions = draggable.helperProportions;
                sortable.offset.click = draggable.offset.click;

                if (sortable._intersectsWith(sortable.containerCache)) {
                    innermostIntersecting = true;

                    $.each(draggable.sortables, function() {

                        // Copy over variables that sortable's _intersectsWith uses
                        this.positionAbs = draggable.positionAbs;
                        this.helperProportions = draggable.helperProportions;
                        this.offset.click = draggable.offset.click;

                        if (this !== sortable &&
                            this._intersectsWith(this.containerCache) &&
                            $.contains(sortable.element[0], this.element[0])) {
                            innermostIntersecting = false;
                        }

                        return innermostIntersecting;
                    });
                }

                if (innermostIntersecting) {

                    // If it intersects, we use a little isOver variable and set it once,
                    // so that the move-in stuff gets fired only once.
                    if (!sortable.isOver) {
                        sortable.isOver = 1;

                        // Store draggable's parent in case we need to reappend to it later.
                        draggable._parent = ui.helper.parent();

                        sortable.currentItem = ui.helper
                            .appendTo(sortable.element)
                            .data("ui-sortable-item", true);

                        // Store helper option to later restore it
                        sortable.options._helper = sortable.options.helper;

                        sortable.options.helper = function() {
                            return ui.helper[0];
                        };

                        // Fire the start events of the sortable with our passed browser event,
                        // and our own helper (so it doesn't create a new one)
                        event.target = sortable.currentItem[0];
                        sortable._mouseCapture(event, true);
                        sortable._mouseStart(event, true, true);

                        // Because the browser event is way off the new appended portlet,
                        // modify necessary variables to reflect the changes
                        sortable.offset.click.top = draggable.offset.click.top;
                        sortable.offset.click.left = draggable.offset.click.left;
                        sortable.offset.parent.left -= draggable.offset.parent.left -
                            sortable.offset.parent.left;
                        sortable.offset.parent.top -= draggable.offset.parent.top -
                            sortable.offset.parent.top;

                        draggable._trigger("toSortable", event);

                        // Inform draggable that the helper is in a valid drop zone,
                        // used solely in the revert option to handle "valid/invalid".
                        draggable.dropped = sortable.element;

                        // Need to refreshPositions of all sortables in the case that
                        // adding to one sortable changes the location of the other sortables (#9675)
                        $.each(draggable.sortables, function() {
                            this.refreshPositions();
                        });

                        // Hack so receive/update callbacks work (mostly)
                        draggable.currentItem = draggable.element;
                        sortable.fromOutside = draggable;
                    }

                    if (sortable.currentItem) {
                        sortable._mouseDrag(event);

                        // Copy the sortable's position because the draggable's can potentially reflect
                        // a relative position, while sortable is always absolute, which the dragged
                        // element has now become. (#8809)
                        ui.position = sortable.position;
                    }
                } else {

                    // If it doesn't intersect with the sortable, and it intersected before,
                    // we fake the drag stop of the sortable, but make sure it doesn't remove
                    // the helper by using cancelHelperRemoval.
                    if (sortable.isOver) {

                        sortable.isOver = 0;
                        sortable.cancelHelperRemoval = true;

                        // Calling sortable's mouseStop would trigger a revert,
                        // so revert must be temporarily false until after mouseStop is called.
                        sortable.options._revert = sortable.options.revert;
                        sortable.options.revert = false;

                        sortable._trigger("out", event, sortable._uiHash(sortable));
                        sortable._mouseStop(event, true);

                        // Restore sortable behaviors that were modfied
                        // when the draggable entered the sortable area (#9481)
                        sortable.options.revert = sortable.options._revert;
                        sortable.options.helper = sortable.options._helper;

                        if (sortable.placeholder) {
                            sortable.placeholder.remove();
                        }

                        // Restore and recalculate the draggable's offset considering the sortable
                        // may have modified them in unexpected ways. (#8809, #10669)
                        ui.helper.appendTo(draggable._parent);
                        draggable._refreshOffsets(event);
                        ui.position = draggable._generatePosition(event, true);

                        draggable._trigger("fromSortable", event);

                        // Inform draggable that the helper is no longer in a valid drop zone
                        draggable.dropped = false;

                        // Need to refreshPositions of all sortables just in case removing
                        // from one sortable changes the location of other sortables (#9675)
                        $.each(draggable.sortables, function() {
                            this.refreshPositions();
                        });
                    }
                }
            });
        }
    });

    $.ui.plugin.add("draggable", "cursor", {
        start: function(event, ui, instance) {
            var t = $("body"),
                o = instance.options;

            if (t.css("cursor")) {
                o._cursor = t.css("cursor");
            }
            t.css("cursor", o.cursor);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._cursor) {
                $("body").css("cursor", o._cursor);
            }
        }
    });

    $.ui.plugin.add("draggable", "opacity", {
        start: function(event, ui, instance) {
            var t = $(ui.helper),
                o = instance.options;
            if (t.css("opacity")) {
                o._opacity = t.css("opacity");
            }
            t.css("opacity", o.opacity);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._opacity) {
                $(ui.helper).css("opacity", o._opacity);
            }
        }
    });

    $.ui.plugin.add("draggable", "scroll", {
        start: function(event, ui, i) {
            if (!i.scrollParentNotHidden) {
                i.scrollParentNotHidden = i.helper.scrollParent(false);
            }

            if (i.scrollParentNotHidden[0] !== i.document[0] &&
                i.scrollParentNotHidden[0].tagName !== "HTML") {
                i.overflowOffset = i.scrollParentNotHidden.offset();
            }
        },
        drag: function(event, ui, i) {

            var o = i.options,
                scrolled = false,
                scrollParent = i.scrollParentNotHidden[0],
                document = i.document[0];

            if (scrollParent !== document && scrollParent.tagName !== "HTML") {
                if (!o.axis || o.axis !== "x") {
                    if ((i.overflowOffset.top + scrollParent.offsetHeight) - event.pageY <
                        o.scrollSensitivity) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                    } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if ((i.overflowOffset.left + scrollParent.offsetWidth) - event.pageX <
                        o.scrollSensitivity) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
                    }
                }

            } else {

                if (!o.axis || o.axis !== "x") {
                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) <
                        o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft(
                            $(document).scrollLeft() - o.scrollSpeed
                        );
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) <
                        o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft(
                            $(document).scrollLeft() + o.scrollSpeed
                        );
                    }
                }

            }

            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(i, event);
            }

        }
    });

    $.ui.plugin.add("draggable", "snap", {
        start: function(event, ui, i) {

            var o = i.options;

            i.snapElements = [];

            $(o.snap.constructor !== String ? (o.snap.items || ":data(ui-draggable)") : o.snap)
                .each(function() {
                    var $t = $(this),
                        $o = $t.offset();
                    if (this !== i.element[0]) {
                        i.snapElements.push({
                            item: this,
                            width: $t.outerWidth(),
                            height: $t.outerHeight(),
                            top: $o.top,
                            left: $o.left
                        });
                    }
                });

        },
        drag: function(event, ui, inst) {

            var ts, bs, ls, rs, l, r, t, b, i, first,
                o = inst.options,
                d = o.snapTolerance,
                x1 = ui.offset.left,
                x2 = x1 + inst.helperProportions.width,
                y1 = ui.offset.top,
                y2 = y1 + inst.helperProportions.height;

            for (i = inst.snapElements.length - 1; i >= 0; i--) {

                l = inst.snapElements[i].left - inst.margins.left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top - inst.margins.top;
                b = t + inst.snapElements[i].height;

                if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||
                    !$.contains(inst.snapElements[i].item.ownerDocument,
                        inst.snapElements[i].item)) {
                    if (inst.snapElements[i].snapping) {
                        (inst.options.snap.release &&
                            inst.options.snap.release.call(
                                inst.element,
                                event,
                                $.extend(inst._uiHash(), {
                                    snapItem: inst.snapElements[i].item
                                })
                            ));
                    }
                    inst.snapElements[i].snapping = false;
                    continue;
                }

                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t - inst.helperProportions.height,
                            left: 0
                        }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b,
                            left: 0
                        }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l - inst.helperProportions.width
                        }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r
                        }).left;
                    }
                }

                first = (ts || bs || ls || rs);

                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t,
                            left: 0
                        }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b - inst.helperProportions.height,
                            left: 0
                        }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l
                        }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r - inst.helperProportions.width
                        }).left;
                    }
                }

                if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                    (inst.options.snap.snap &&
                        inst.options.snap.snap.call(
                            inst.element,
                            event,
                            $.extend(inst._uiHash(), {
                                snapItem: inst.snapElements[i].item
                            })));
                }
                inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

            }

        }
    });

    $.ui.plugin.add("draggable", "stack", {
        start: function(event, ui, instance) {
            var min,
                o = instance.options,
                group = $.makeArray($(o.stack)).sort(function(a, b) {
                    return (parseInt($(a).css("zIndex"), 10) || 0) -
                        (parseInt($(b).css("zIndex"), 10) || 0);
                });

            if (!group.length) {
                return;
            }

            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function(i) {
                $(this).css("zIndex", min + i);
            });
            this.css("zIndex", (min + group.length));
        }
    });

    $.ui.plugin.add("draggable", "zIndex", {
        start: function(event, ui, instance) {
            var t = $(ui.helper),
                o = instance.options;

            if (t.css("zIndex")) {
                o._zIndex = t.css("zIndex");
            }
            t.css("zIndex", o.zIndex);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;

            if (o._zIndex) {
                $(ui.helper).css("zIndex", o._zIndex);
            }
        }
    });

    var widgetsDraggable = $.ui.draggable;


    /*!
     * jQuery UI Resizable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Resizable
    //>>group: Interactions
    //>>description: Enables resize functionality for any element.
    //>>docs: http://api.jqueryui.com/resizable/
    //>>demos: http://jqueryui.com/resizable/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/resizable.css
    //>>css.theme: ../../themes/base/theme.css



    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            classes: {
                "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
            },
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,

            // See #7960
            zIndex: 90,

            // Callbacks
            resize: null,
            start: null,
            stop: null
        },

        _num: function(value) {
            return parseFloat(value) || 0;
        },

        _isNumber: function(value) {
            return !isNaN(parseFloat(value));
        },

        _hasScroll: function(el, a) {

            if ($(el).css("overflow") === "hidden") {
                return false;
            }

            var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
                has = false;

            if (el[scroll] > 0) {
                return true;
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            el[scroll] = 1;
            has = (el[scroll] > 0);
            el[scroll] = 0;
            return has;
        },

        _create: function() {

            var margins,
                o = this.options,
                that = this;
            this._addClass("ui-resizable");

            $.extend(this, {
                _aspectRatio: !!(o.aspectRatio),
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            });

            // Wrap the element if it cannot hold child nodes
            if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {

                this.element.wrap(
                    $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                        position: this.element.css("position"),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css("top"),
                        left: this.element.css("left")
                    })
                );

                this.element = this.element.parent().data(
                    "ui-resizable", this.element.resizable("instance")
                );

                this.elementIsWrapper = true;

                margins = {
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom"),
                    marginLeft: this.originalElement.css("marginLeft")
                };

                this.element.css(margins);
                this.originalElement.css("margin", 0);

                // support: Safari
                // Prevent Safari textarea resize
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");

                this._proportionallyResizeElements.push(this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                }));

                // Support: IE9
                // avoid IE jump (hard set the margin)
                this.originalElement.css(margins);

                this._proportionallyResize();
            }

            this._setupHandles();

            if (o.autoHide) {
                $(this.element)
                    .on("mouseenter", function() {
                        if (o.disabled) {
                            return;
                        }
                        that._removeClass("ui-resizable-autohide");
                        that._handles.show();
                    })
                    .on("mouseleave", function() {
                        if (o.disabled) {
                            return;
                        }
                        if (!that.resizing) {
                            that._addClass("ui-resizable-autohide");
                            that._handles.hide();
                        }
                    });
            }

            this._mouseInit();
        },

        _destroy: function() {

            this._mouseDestroy();

            var wrapper,
                _destroy = function(exp) {
                    $(exp)
                        .removeData("resizable")
                        .removeData("ui-resizable")
                        .off(".resizable")
                        .find(".ui-resizable-handle")
                        .remove();
                };

            // TODO: Unwrap at same DOM position
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter(wrapper);
                wrapper.remove();
            }

            this.originalElement.css("resize", this.originalResizeStyle);
            _destroy(this.originalElement);

            return this;
        },

        _setOption: function(key, value) {
            this._super(key, value);

            switch (key) {
                case "handles":
                    this._removeHandles();
                    this._setupHandles();
                    break;
                default:
                    break;
            }
        },

        _setupHandles: function() {
            var o = this.options,
                handle, i, n, hname, axis, that = this;
            this.handles = o.handles ||
                (!$(".ui-resizable-handle", this.element).length ?
                    "e,s,se" : {
                        n: ".ui-resizable-n",
                        e: ".ui-resizable-e",
                        s: ".ui-resizable-s",
                        w: ".ui-resizable-w",
                        se: ".ui-resizable-se",
                        sw: ".ui-resizable-sw",
                        ne: ".ui-resizable-ne",
                        nw: ".ui-resizable-nw"
                    });

            this._handles = $();
            if (this.handles.constructor === String) {

                if (this.handles === "all") {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }

                n = this.handles.split(",");
                this.handles = {};

                for (i = 0; i < n.length; i++) {

                    handle = $.trim(n[i]);
                    hname = "ui-resizable-" + handle;
                    axis = $("<div>");
                    this._addClass(axis, "ui-resizable-handle " + hname);

                    axis.css({
                        zIndex: o.zIndex
                    });

                    this.handles[handle] = ".ui-resizable-" + handle;
                    this.element.append(axis);
                }

            }

            this._renderAxis = function(target) {

                var i, axis, padPos, padWrapper;

                target = target || this.element;

                for (i in this.handles) {

                    if (this.handles[i].constructor === String) {
                        this.handles[i] = this.element.children(this.handles[i]).first().show();
                    } else if (this.handles[i].jquery || this.handles[i].nodeType) {
                        this.handles[i] = $(this.handles[i]);
                        this._on(this.handles[i], {
                            "mousedown": that._mouseDown
                        });
                    }

                    if (this.elementIsWrapper &&
                        this.originalElement[0]
                        .nodeName
                        .match(/^(textarea|input|select|button)$/i)) {
                        axis = $(this.handles[i], this.element);

                        padWrapper = /sw|ne|nw|se|n|s/.test(i) ?
                            axis.outerHeight() :
                            axis.outerWidth();

                        padPos = ["padding",
                            /ne|nw|n/.test(i) ? "Top" :
                            /se|sw|s/.test(i) ? "Bottom" :
                            /^e$/.test(i) ? "Right" : "Left"
                        ].join("");

                        target.css(padPos, padWrapper);

                        this._proportionallyResize();
                    }

                    this._handles = this._handles.add(this.handles[i]);
                }
            };

            // TODO: make renderAxis a prototype function
            this._renderAxis(this.element);

            this._handles = this._handles.add(this.element.find(".ui-resizable-handle"));
            this._handles.disableSelection();

            this._handles.on("mouseover", function() {
                if (!that.resizing) {
                    if (this.className) {
                        axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    }
                    that.axis = axis && axis[1] ? axis[1] : "se";
                }
            });

            if (o.autoHide) {
                this._handles.hide();
                this._addClass("ui-resizable-autohide");
            }
        },

        _removeHandles: function() {
            this._handles.remove();
        },

        _mouseCapture: function(event) {
            var i, handle,
                capture = false;

            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (handle === event.target || $.contains(handle, event.target)) {
                    capture = true;
                }
            }

            return !this.options.disabled && capture;
        },

        _mouseStart: function(event) {

            var curleft, curtop, cursor,
                o = this.options,
                el = this.element;

            this.resizing = true;

            this._renderProxy();

            curleft = this._num(this.helper.css("left"));
            curtop = this._num(this.helper.css("top"));

            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0;
            }

            this.offset = this.helper.offset();
            this.position = {
                left: curleft,
                top: curtop
            };

            this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                width: el.width(),
                height: el.height()
            };

            this.originalSize = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            };

            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            };

            this.originalPosition = {
                left: curleft,
                top: curtop
            };
            this.originalMousePosition = {
                left: event.pageX,
                top: event.pageY
            };

            this.aspectRatio = (typeof o.aspectRatio === "number") ?
                o.aspectRatio :
                ((this.originalSize.width / this.originalSize.height) || 1);

            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

            this._addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true;
        },

        _mouseDrag: function(event) {

            var data, props,
                smp = this.originalMousePosition,
                a = this.axis,
                dx = (event.pageX - smp.left) || 0,
                dy = (event.pageY - smp.top) || 0,
                trigger = this._change[a];

            this._updatePrevProperties();

            if (!trigger) {
                return false;
            }

            data = trigger.apply(this, [event, dx, dy]);

            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) {
                data = this._updateRatio(data, event);
            }

            data = this._respectSize(data, event);

            this._updateCache(data);

            this._propagate("resize", event);

            props = this._applyChanges();

            if (!this._helper && this._proportionallyResizeElements.length) {
                this._proportionallyResize();
            }

            if (!$.isEmptyObject(props)) {
                this._updatePrevProperties();
                this._trigger("resize", event, this.ui());
                this._applyChanges();
            }

            return false;
        },

        _mouseStop: function(event) {

            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top,
                o = this.options,
                that = this;

            if (this._helper) {

                pr = this._proportionallyResizeElements;
                ista = pr.length && (/textarea/i).test(pr[0].nodeName);
                soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;

                s = {
                    width: (that.helper.width() - soffsetw),
                    height: (that.helper.height() - soffseth)
                };
                left = (parseFloat(that.element.css("left")) +
                    (that.position.left - that.originalPosition.left)) || null;
                top = (parseFloat(that.element.css("top")) +
                    (that.position.top - that.originalPosition.top)) || null;

                if (!o.animate) {
                    this.element.css($.extend(s, {
                        top: top,
                        left: left
                    }));
                }

                that.helper.height(that.size.height);
                that.helper.width(that.size.width);

                if (this._helper && !o.animate) {
                    this._proportionallyResize();
                }
            }

            $("body").css("cursor", "auto");

            this._removeClass("ui-resizable-resizing");

            this._propagate("stop", event);

            if (this._helper) {
                this.helper.remove();
            }

            return false;

        },

        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            };
            this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },

        _applyChanges: function() {
            var props = {};

            if (this.position.top !== this.prevPosition.top) {
                props.top = this.position.top + "px";
            }
            if (this.position.left !== this.prevPosition.left) {
                props.left = this.position.left + "px";
            }
            if (this.size.width !== this.prevSize.width) {
                props.width = this.size.width + "px";
            }
            if (this.size.height !== this.prevSize.height) {
                props.height = this.size.height + "px";
            }

            this.helper.css(props);

            return props;
        },

        _updateVirtualBoundaries: function(forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
                o = this.options;

            b = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
            };

            if (this._aspectRatio || forceAspectRatio) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;

                if (pMinWidth > b.minWidth) {
                    b.minWidth = pMinWidth;
                }
                if (pMinHeight > b.minHeight) {
                    b.minHeight = pMinHeight;
                }
                if (pMaxWidth < b.maxWidth) {
                    b.maxWidth = pMaxWidth;
                }
                if (pMaxHeight < b.maxHeight) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },

        _updateCache: function(data) {
            this.offset = this.helper.offset();
            if (this._isNumber(data.left)) {
                this.position.left = data.left;
            }
            if (this._isNumber(data.top)) {
                this.position.top = data.top;
            }
            if (this._isNumber(data.height)) {
                this.size.height = data.height;
            }
            if (this._isNumber(data.width)) {
                this.size.width = data.width;
            }
        },

        _updateRatio: function(data) {

            var cpos = this.position,
                csize = this.size,
                a = this.axis;

            if (this._isNumber(data.height)) {
                data.width = (data.height * this.aspectRatio);
            } else if (this._isNumber(data.width)) {
                data.height = (data.width / this.aspectRatio);
            }

            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null;
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width);
            }

            return data;
        },

        _respectSize: function(data) {

            var o = this._vBoundaries,
                a = this.axis,
                ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
                ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
                isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
                isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
                dw = this.originalPosition.left + this.originalSize.width,
                dh = this.originalPosition.top + this.originalSize.height,
                cw = /sw|nw|w/.test(a),
                ch = /nw|ne|n/.test(a);
            if (isminw) {
                data.width = o.minWidth;
            }
            if (isminh) {
                data.height = o.minHeight;
            }
            if (ismaxw) {
                data.width = o.maxWidth;
            }
            if (ismaxh) {
                data.height = o.maxHeight;
            }

            if (isminw && cw) {
                data.left = dw - o.minWidth;
            }
            if (ismaxw && cw) {
                data.left = dw - o.maxWidth;
            }
            if (isminh && ch) {
                data.top = dh - o.minHeight;
            }
            if (ismaxh && ch) {
                data.top = dh - o.maxHeight;
            }

            // Fixing jump error on top/left - bug #2330
            if (!data.width && !data.height && !data.left && data.top) {
                data.top = null;
            } else if (!data.width && !data.height && !data.top && data.left) {
                data.left = null;
            }

            return data;
        },

        _getPaddingPlusBorderDimensions: function(element) {
            var i = 0,
                widths = [],
                borders = [
                    element.css("borderTopWidth"),
                    element.css("borderRightWidth"),
                    element.css("borderBottomWidth"),
                    element.css("borderLeftWidth")
                ],
                paddings = [
                    element.css("paddingTop"),
                    element.css("paddingRight"),
                    element.css("paddingBottom"),
                    element.css("paddingLeft")
                ];

            for (; i < 4; i++) {
                widths[i] = (parseFloat(borders[i]) || 0);
                widths[i] += (parseFloat(paddings[i]) || 0);
            }

            return {
                height: widths[0] + widths[2],
                width: widths[1] + widths[3]
            };
        },

        _proportionallyResize: function() {

            if (!this._proportionallyResizeElements.length) {
                return;
            }

            var prel,
                i = 0,
                element = this.helper || this.element;

            for (; i < this._proportionallyResizeElements.length; i++) {

                prel = this._proportionallyResizeElements[i];

                // TODO: Seems like a bug to cache this.outerDimensions
                // considering that we are in a loop.
                if (!this.outerDimensions) {
                    this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
                }

                prel.css({
                    height: (element.height() - this.outerDimensions.height) || 0,
                    width: (element.width() - this.outerDimensions.width) || 0
                });

            }

        },

        _renderProxy: function() {

            var el = this.element,
                o = this.options;
            this.elementOffset = el.offset();

            if (this._helper) {

                this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

                this._addClass(this.helper, this._helper);
                this.helper.css({
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex //TODO: Don't modify option
                });

                this.helper
                    .appendTo("body")
                    .disableSelection();

            } else {
                this.helper = this.element;
            }

        },

        _change: {
            e: function(event, dx) {
                return {
                    width: this.originalSize.width + dx
                };
            },
            w: function(event, dx) {
                var cs = this.originalSize,
                    sp = this.originalPosition;
                return {
                    left: sp.left + dx,
                    width: cs.width - dx
                };
            },
            n: function(event, dx, dy) {
                var cs = this.originalSize,
                    sp = this.originalPosition;
                return {
                    top: sp.top + dy,
                    height: cs.height - dy
                };
            },
            s: function(event, dx, dy) {
                return {
                    height: this.originalSize.height + dy
                };
            },
            se: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments),
                    this._change.e.apply(this, [event, dx, dy]));
            },
            sw: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments),
                    this._change.w.apply(this, [event, dx, dy]));
            },
            ne: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments),
                    this._change.e.apply(this, [event, dx, dy]));
            },
            nw: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments),
                    this._change.w.apply(this, [event, dx, dy]));
            }
        },

        _propagate: function(n, event) {
            $.ui.plugin.call(this, n, [event, this.ui()]);
            (n !== "resize" && this._trigger(n, event, this.ui()));
        },

        plugins: {},

        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }

    });

    /*
     * Resizable Extensions
     */

    $.ui.plugin.add("resizable", "animate", {

        stop: function(event) {
            var that = $(this).resizable("instance"),
                o = that.options,
                pr = that._proportionallyResizeElements,
                ista = pr.length && (/textarea/i).test(pr[0].nodeName),
                soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
                soffsetw = ista ? 0 : that.sizeDiff.width,
                style = {
                    width: (that.size.width - soffsetw),
                    height: (that.size.height - soffseth)
                },
                left = (parseFloat(that.element.css("left")) +
                    (that.position.left - that.originalPosition.left)) || null,
                top = (parseFloat(that.element.css("top")) +
                    (that.position.top - that.originalPosition.top)) || null;

            that.element.animate(
                $.extend(style, top && left ? {
                    top: top,
                    left: left
                } : {}), {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function() {

                        var data = {
                            width: parseFloat(that.element.css("width")),
                            height: parseFloat(that.element.css("height")),
                            top: parseFloat(that.element.css("top")),
                            left: parseFloat(that.element.css("left"))
                        };

                        if (pr && pr.length) {
                            $(pr[0]).css({
                                width: data.width,
                                height: data.height
                            });
                        }

                        // Propagating resize, and updating values for each animation step
                        that._updateCache(data);
                        that._propagate("resize", event);

                    }
                }
            );
        }

    });

    $.ui.plugin.add("resizable", "containment", {

        start: function() {
            var element, p, co, ch, cw, width, height,
                that = $(this).resizable("instance"),
                o = that.options,
                el = that.element,
                oc = o.containment,
                ce = (oc instanceof $) ?
                oc.get(0) :
                (/parent/.test(oc)) ? el.parent().get(0) : oc;

            if (!ce) {
                return;
            }

            that.containerElement = $(ce);

            if (/document/.test(oc) || oc === document) {
                that.containerOffset = {
                    left: 0,
                    top: 0
                };
                that.containerPosition = {
                    left: 0,
                    top: 0
                };

                that.parentData = {
                    element: $(document),
                    left: 0,
                    top: 0,
                    width: $(document).width(),
                    height: $(document).height() || document.body.parentNode.scrollHeight
                };
            } else {
                element = $(ce);
                p = [];
                $(["Top", "Right", "Left", "Bottom"]).each(function(i, name) {
                    p[i] = that._num(element.css("padding" + name));
                });

                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: (element.innerHeight() - p[3]),
                    width: (element.innerWidth() - p[1])
                };

                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = (that._hasScroll(ce, "left") ? ce.scrollWidth : cw);
                height = (that._hasScroll(ce) ? ce.scrollHeight : ch);

                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                };
            }
        },

        resize: function(event) {
            var woset, hoset, isParent, isOffsetRelative,
                that = $(this).resizable("instance"),
                o = that.options,
                co = that.containerOffset,
                cp = that.position,
                pRatio = that._aspectRatio || event.shiftKey,
                cop = {
                    top: 0,
                    left: 0
                },
                ce = that.containerElement,
                continueResize = true;

            if (ce[0] !== document && (/static/).test(ce.css("position"))) {
                cop = co;
            }

            if (cp.left < (that._helper ? co.left : 0)) {
                that.size.width = that.size.width +
                    (that._helper ?
                        (that.position.left - co.left) :
                        (that.position.left - cop.left));

                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
                that.position.left = o.helper ? co.left : 0;
            }

            if (cp.top < (that._helper ? co.top : 0)) {
                that.size.height = that.size.height +
                    (that._helper ?
                        (that.position.top - co.top) :
                        that.position.top);

                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
                that.position.top = that._helper ? co.top : 0;
            }

            isParent = that.containerElement.get(0) === that.element.parent().get(0);
            isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

            if (isParent && isOffsetRelative) {
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top;
            } else {
                that.offset.left = that.element.offset().left;
                that.offset.top = that.element.offset().top;
            }

            woset = Math.abs(that.sizeDiff.width +
                (that._helper ?
                    that.offset.left - cop.left :
                    (that.offset.left - co.left)));

            hoset = Math.abs(that.sizeDiff.height +
                (that._helper ?
                    that.offset.top - cop.top :
                    (that.offset.top - co.top)));

            if (woset + that.size.width >= that.parentData.width) {
                that.size.width = that.parentData.width - woset;
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
            }

            if (hoset + that.size.height >= that.parentData.height) {
                that.size.height = that.parentData.height - hoset;
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
            }

            if (!continueResize) {
                that.position.left = that.prevPosition.left;
                that.position.top = that.prevPosition.top;
                that.size.width = that.prevSize.width;
                that.size.height = that.prevSize.height;
            }
        },

        stop: function() {
            var that = $(this).resizable("instance"),
                o = that.options,
                co = that.containerOffset,
                cop = that.containerPosition,
                ce = that.containerElement,
                helper = $(that.helper),
                ho = helper.offset(),
                w = helper.outerWidth() - that.sizeDiff.width,
                h = helper.outerHeight() - that.sizeDiff.height;

            if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }

            if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
        }
    });

    $.ui.plugin.add("resizable", "alsoResize", {

        start: function() {
            var that = $(this).resizable("instance"),
                o = that.options;

            $(o.alsoResize).each(function() {
                var el = $(this);
                el.data("ui-resizable-alsoresize", {
                    width: parseFloat(el.width()),
                    height: parseFloat(el.height()),
                    left: parseFloat(el.css("left")),
                    top: parseFloat(el.css("top"))
                });
            });
        },

        resize: function(event, ui) {
            var that = $(this).resizable("instance"),
                o = that.options,
                os = that.originalSize,
                op = that.originalPosition,
                delta = {
                    height: (that.size.height - os.height) || 0,
                    width: (that.size.width - os.width) || 0,
                    top: (that.position.top - op.top) || 0,
                    left: (that.position.left - op.left) || 0
                };

            $(o.alsoResize).each(function() {
                var el = $(this),
                    start = $(this).data("ui-resizable-alsoresize"),
                    style = {},
                    css = el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

                $.each(css, function(i, prop) {
                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                    if (sum && sum >= 0) {
                        style[prop] = sum || null;
                    }
                });

                el.css(style);
            });
        },

        stop: function() {
            $(this).removeData("ui-resizable-alsoresize");
        }
    });

    $.ui.plugin.add("resizable", "ghost", {

        start: function() {

            var that = $(this).resizable("instance"),
                cs = that.size;

            that.ghost = that.originalElement.clone();
            that.ghost.css({
                opacity: 0.25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0
            });

            that._addClass(that.ghost, "ui-resizable-ghost");

            // DEPRECATED
            // TODO: remove after 1.12
            if ($.uiBackCompat !== false && typeof that.options.ghost === "string") {

                // Ghost option
                that.ghost.addClass(this.options.ghost);
            }

            that.ghost.appendTo(that.helper);

        },

        resize: function() {
            var that = $(this).resizable("instance");
            if (that.ghost) {
                that.ghost.css({
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width
                });
            }
        },

        stop: function() {
            var that = $(this).resizable("instance");
            if (that.ghost && that.helper) {
                that.helper.get(0).removeChild(that.ghost.get(0));
            }
        }

    });

    $.ui.plugin.add("resizable", "grid", {

        resize: function() {
            var outerDimensions,
                that = $(this).resizable("instance"),
                o = that.options,
                cs = that.size,
                os = that.originalSize,
                op = that.originalPosition,
                a = that.axis,
                grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
                gridX = (grid[0] || 1),
                gridY = (grid[1] || 1),
                ox = Math.round((cs.width - os.width) / gridX) * gridX,
                oy = Math.round((cs.height - os.height) / gridY) * gridY,
                newWidth = os.width + ox,
                newHeight = os.height + oy,
                isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
                isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
                isMinWidth = o.minWidth && (o.minWidth > newWidth),
                isMinHeight = o.minHeight && (o.minHeight > newHeight);

            o.grid = grid;

            if (isMinWidth) {
                newWidth += gridX;
            }
            if (isMinHeight) {
                newHeight += gridY;
            }
            if (isMaxWidth) {
                newWidth -= gridX;
            }
            if (isMaxHeight) {
                newHeight -= gridY;
            }

            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                    outerDimensions = that._getPaddingPlusBorderDimensions(this);
                }

                if (newHeight - gridY > 0) {
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else {
                    newHeight = gridY - outerDimensions.height;
                    that.size.height = newHeight;
                    that.position.top = op.top + os.height - newHeight;
                }
                if (newWidth - gridX > 0) {
                    that.size.width = newWidth;
                    that.position.left = op.left - ox;
                } else {
                    newWidth = gridX - outerDimensions.width;
                    that.size.width = newWidth;
                    that.position.left = op.left + os.width - newWidth;
                }
            }
        }

    });

    var widgetsResizable = $.ui.resizable;


    /*!
     * jQuery UI Dialog 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Dialog
    //>>group: Widgets
    //>>description: Displays customizable dialog windows.
    //>>docs: http://api.jqueryui.com/dialog/
    //>>demos: http://jqueryui.com/dialog/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/dialog.css
    //>>css.theme: ../../themes/base/theme.css



    $.widget("ui.dialog", {
        version: "1.12.1",
        options: {
            appendTo: "body",
            autoOpen: true,
            buttons: [],
            classes: {
                "ui-dialog": "ui-corner-all",
                "ui-dialog-titlebar": "ui-corner-all"
            },
            closeOnEscape: true,
            closeText: "Close",
            draggable: true,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",

                // Ensure the titlebar is always visible
                using: function(pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    if (topOffset < 0) {
                        $(this).css("top", pos.top - topOffset);
                    }
                }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,

            // Callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },

        sizeRelatedOptions: {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
        },

        resizableRelatedOptions: {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
        },

        _create: function() {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            };
            this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            };
            this.originalTitle = this.element.attr("title");
            if (this.options.title == null && this.originalTitle != null) {
                this.options.title = this.originalTitle;
            }

            // Dialogs can't be disabled
            if (this.options.disabled) {
                this.options.disabled = false;
            }

            this._createWrapper();

            this.element
                .show()
                .removeAttr("title")
                .appendTo(this.uiDialog);

            this._addClass("ui-dialog-content", "ui-widget-content");

            this._createTitlebar();
            this._createButtonPane();

            if (this.options.draggable && $.fn.draggable) {
                this._makeDraggable();
            }
            if (this.options.resizable && $.fn.resizable) {
                this._makeResizable();
            }

            this._isOpen = false;

            this._trackFocus();
        },

        _init: function() {
            if (this.options.autoOpen) {
                this.open();
            }
        },

        _appendTo: function() {
            var element = this.options.appendTo;
            if (element && (element.jquery || element.nodeType)) {
                return $(element);
            }
            return this.document.find(element || "body").eq(0);
        },

        _destroy: function() {
            var next,
                originalPosition = this.originalPosition;

            this._untrackInstance();
            this._destroyOverlay();

            this.element
                .removeUniqueId()
                .css(this.originalCss)

                // Without detaching first, the following becomes really slow
                .detach();

            this.uiDialog.remove();

            if (this.originalTitle) {
                this.element.attr("title", this.originalTitle);
            }

            next = originalPosition.parent.children().eq(originalPosition.index);

            // Don't try to place the dialog next to itself (#8613)
            if (next.length && next[0] !== this.element[0]) {
                next.before(this.element);
            } else {
                originalPosition.parent.append(this.element);
            }
        },

        widget: function() {
            return this.uiDialog;
        },

        disable: $.noop,
        enable: $.noop,

        close: function(event) {
            var that = this;

            if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                return;
            }

            this._isOpen = false;
            this._focusedElement = null;
            this._destroyOverlay();
            this._untrackInstance();

            if (!this.opener.filter(":focusable").trigger("focus").length) {

                // Hiding a focused element doesn't trigger blur in WebKit
                // so in case we have nothing to focus on, explicitly blur the active element
                // https://bugs.webkit.org/show_bug.cgi?id=47182
                $.ui.safeBlur($.ui.safeActiveElement(this.document[0]));
            }

            this._hide(this.uiDialog, this.options.hide, function() {
                that._trigger("close", event);
            });
        },

        isOpen: function() {
            return this._isOpen;
        },

        moveToTop: function() {
            this._moveToTop();
        },

        _moveToTop: function(event, silent) {
            var moved = false,
                zIndices = this.uiDialog.siblings(".ui-front:visible").map(function() {
                    return +$(this).css("z-index");
                }).get(),
                zIndexMax = Math.max.apply(null, zIndices);

            if (zIndexMax >= +this.uiDialog.css("z-index")) {
                this.uiDialog.css("z-index", zIndexMax + 1);
                moved = true;
            }

            if (moved && !silent) {
                this._trigger("focus", event);
            }
            return moved;
        },

        open: function() {
            var that = this;
            if (this._isOpen) {
                if (this._moveToTop()) {
                    this._focusTabbable();
                }
                return;
            }

            this._isOpen = true;
            this.opener = $($.ui.safeActiveElement(this.document[0]));

            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop(null, true);

            // Ensure the overlay is moved to the top with the dialog, but only when
            // opening. The overlay shouldn't move after the dialog is open so that
            // modeless dialogs opened after the modal dialog stack properly.
            if (this.overlay) {
                this.overlay.css("z-index", this.uiDialog.css("z-index") - 1);
            }

            this._show(this.uiDialog, this.options.show, function() {
                that._focusTabbable();
                that._trigger("focus");
            });

            // Track the dialog immediately upon openening in case a focus event
            // somehow occurs outside of the dialog before an element inside the
            // dialog is focused (#10152)
            this._makeFocusTarget();

            this._trigger("open");
        },

        _focusTabbable: function() {

            // Set focus to the first match:
            // 1. An element that was focused previously
            // 2. First element inside the dialog matching [autofocus]
            // 3. Tabbable element inside the content element
            // 4. Tabbable element inside the buttonpane
            // 5. The close button
            // 6. The dialog itself
            var hasFocus = this._focusedElement;
            if (!hasFocus) {
                hasFocus = this.element.find("[autofocus]");
            }
            if (!hasFocus.length) {
                hasFocus = this.element.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogButtonPane.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialog;
            }
            hasFocus.eq(0).trigger("focus");
        },

        _keepFocus: function(event) {
            function checkFocus() {
                var activeElement = $.ui.safeActiveElement(this.document[0]),
                    isActive = this.uiDialog[0] === activeElement ||
                    $.contains(this.uiDialog[0], activeElement);
                if (!isActive) {
                    this._focusTabbable();
                }
            }
            event.preventDefault();
            checkFocus.call(this);

            // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(checkFocus);
        },

        _createWrapper: function() {
            this.uiDialog = $("<div>")
                .hide()
                .attr({

                    // Setting tabIndex makes the div focusable
                    tabIndex: -1,
                    role: "dialog"
                })
                .appendTo(this._appendTo());

            this._addClass(this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front");
            this._on(this.uiDialog, {
                keydown: function(event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                        event.keyCode === $.ui.keyCode.ESCAPE) {
                        event.preventDefault();
                        this.close(event);
                        return;
                    }

                    // Prevent tabbing out of dialogs
                    if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
                        return;
                    }
                    var tabbables = this.uiDialog.find(":tabbable"),
                        first = tabbables.filter(":first"),
                        last = tabbables.filter(":last");

                    if ((event.target === last[0] || event.target === this.uiDialog[0]) &&
                        !event.shiftKey) {
                        this._delay(function() {
                            first.trigger("focus");
                        });
                        event.preventDefault();
                    } else if ((event.target === first[0] ||
                            event.target === this.uiDialog[0]) && event.shiftKey) {
                        this._delay(function() {
                            last.trigger("focus");
                        });
                        event.preventDefault();
                    }
                },
                mousedown: function(event) {
                    if (this._moveToTop(event)) {
                        this._focusTabbable();
                    }
                }
            });

            // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            if (!this.element.find("[aria-describedby]").length) {
                this.uiDialog.attr({
                    "aria-describedby": this.element.uniqueId().attr("id")
                });
            }
        },

        _createTitlebar: function() {
            var uiDialogTitle;

            this.uiDialogTitlebar = $("<div>");
            this._addClass(this.uiDialogTitlebar,
                "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix");
            this._on(this.uiDialogTitlebar, {
                mousedown: function(event) {

                    // Don't prevent click on close button (#8838)
                    // Focusing a dialog that is partially scrolled out of view
                    // causes the browser to scroll it into view, preventing the click event
                    if (!$(event.target).closest(".ui-dialog-titlebar-close")) {

                        // Dialog isn't getting focus when dragging (#8063)
                        this.uiDialog.trigger("focus");
                    }
                }
            });

            // Support: IE
            // Use type="button" to prevent enter keypresses in textboxes from closing the
            // dialog in IE (#9312)
            this.uiDialogTitlebarClose = $("<button type='button'></button>")
                .button({
                    label: $("<a>").text(this.options.closeText).html(),
                    icon: "ui-icon-closethick",
                    showLabel: false
                })
                .appendTo(this.uiDialogTitlebar);

            this._addClass(this.uiDialogTitlebarClose, "ui-dialog-titlebar-close");
            this._on(this.uiDialogTitlebarClose, {
                click: function(event) {
                    event.preventDefault();
                    this.close(event);
                }
            });

            uiDialogTitle = $("<span>").uniqueId().prependTo(this.uiDialogTitlebar);
            this._addClass(uiDialogTitle, "ui-dialog-title");
            this._title(uiDialogTitle);

            this.uiDialogTitlebar.prependTo(this.uiDialog);

            this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id")
            });
        },

        _title: function(title) {
            if (this.options.title) {
                title.text(this.options.title);
            } else {
                title.html("&#160;");
            }
        },

        _createButtonPane: function() {
            this.uiDialogButtonPane = $("<div>");
            this._addClass(this.uiDialogButtonPane, "ui-dialog-buttonpane",
                "ui-widget-content ui-helper-clearfix");

            this.uiButtonSet = $("<div>")
                .appendTo(this.uiDialogButtonPane);
            this._addClass(this.uiButtonSet, "ui-dialog-buttonset");

            this._createButtons();
        },

        _createButtons: function() {
            var that = this,
                buttons = this.options.buttons;

            // If we already have a button pane, remove it
            this.uiDialogButtonPane.remove();
            this.uiButtonSet.empty();

            if ($.isEmptyObject(buttons) || ($.isArray(buttons) && !buttons.length)) {
                this._removeClass(this.uiDialog, "ui-dialog-buttons");
                return;
            }

            $.each(buttons, function(name, props) {
                var click, buttonOptions;
                props = $.isFunction(props) ? {
                        click: props,
                        text: name
                    } :
                    props;

                // Default to a non-submitting button
                props = $.extend({
                    type: "button"
                }, props);

                // Change the context for the click callback to be the main element
                click = props.click;
                buttonOptions = {
                    icon: props.icon,
                    iconPosition: props.iconPosition,
                    showLabel: props.showLabel,

                    // Deprecated options
                    icons: props.icons,
                    text: props.text
                };

                delete props.click;
                delete props.icon;
                delete props.iconPosition;
                delete props.showLabel;

                // Deprecated options
                delete props.icons;
                if (typeof props.text === "boolean") {
                    delete props.text;
                }

                $("<button></button>", props)
                    .button(buttonOptions)
                    .appendTo(that.uiButtonSet)
                    .on("click", function() {
                        click.apply(that.element[0], arguments);
                    });
            });
            this._addClass(this.uiDialog, "ui-dialog-buttons");
            this.uiDialogButtonPane.appendTo(this.uiDialog);
        },

        _makeDraggable: function() {
            var that = this,
                options = this.options;

            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }

            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function(event, ui) {
                    that._addClass($(this), "ui-dialog-dragging");
                    that._blockFrames();
                    that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function(event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    var left = ui.offset.left - that.document.scrollLeft(),
                        top = ui.offset.top - that.document.scrollTop();

                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " +
                            "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    that._removeClass($(this), "ui-dialog-dragging");
                    that._unblockFrames();
                    that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },

        _makeResizable: function() {
            var that = this,
                options = this.options,
                handles = options.resizable,

                // .ui-resizable has position: relative defined in the stylesheet
                // but dialogs have to use absolute or fixed positioning
                position = this.uiDialog.css("position"),
                resizeHandles = typeof handles === "string" ?
                handles :
                "n,e,s,w,se,sw,ne,nw";

            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }

            this.uiDialog.resizable({
                    cancel: ".ui-dialog-content",
                    containment: "document",
                    alsoResize: this.element,
                    maxWidth: options.maxWidth,
                    maxHeight: options.maxHeight,
                    minWidth: options.minWidth,
                    minHeight: this._minHeight(),
                    handles: resizeHandles,
                    start: function(event, ui) {
                        that._addClass($(this), "ui-dialog-resizing");
                        that._blockFrames();
                        that._trigger("resizeStart", event, filteredUi(ui));
                    },
                    resize: function(event, ui) {
                        that._trigger("resize", event, filteredUi(ui));
                    },
                    stop: function(event, ui) {
                        var offset = that.uiDialog.offset(),
                            left = offset.left - that.document.scrollLeft(),
                            top = offset.top - that.document.scrollTop();

                        options.height = that.uiDialog.height();
                        options.width = that.uiDialog.width();
                        options.position = {
                            my: "left top",
                            at: "left" + (left >= 0 ? "+" : "") + left + " " +
                                "top" + (top >= 0 ? "+" : "") + top,
                            of: that.window
                        };
                        that._removeClass($(this), "ui-dialog-resizing");
                        that._unblockFrames();
                        that._trigger("resizeStop", event, filteredUi(ui));
                    }
                })
                .css("position", position);
        },

        _trackFocus: function() {
            this._on(this.widget(), {
                focusin: function(event) {
                    this._makeFocusTarget();
                    this._focusedElement = $(event.target);
                }
            });
        },

        _makeFocusTarget: function() {
            this._untrackInstance();
            this._trackingInstances().unshift(this);
        },

        _untrackInstance: function() {
            var instances = this._trackingInstances(),
                exists = $.inArray(this, instances);
            if (exists !== -1) {
                instances.splice(exists, 1);
            }
        },

        _trackingInstances: function() {
            var instances = this.document.data("ui-dialog-instances");
            if (!instances) {
                instances = [];
                this.document.data("ui-dialog-instances", instances);
            }
            return instances;
        },

        _minHeight: function() {
            var options = this.options;

            return options.height === "auto" ?
                options.minHeight :
                Math.min(options.minHeight, options.height);
        },

        _position: function() {

            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is(":visible");
            if (!isVisible) {
                this.uiDialog.show();
            }
            this.uiDialog.position(this.options.position);
            if (!isVisible) {
                this.uiDialog.hide();
            }
        },

        _setOptions: function(options) {
            var that = this,
                resize = false,
                resizableOptions = {};

            $.each(options, function(key, value) {
                that._setOption(key, value);

                if (key in that.sizeRelatedOptions) {
                    resize = true;
                }
                if (key in that.resizableRelatedOptions) {
                    resizableOptions[key] = value;
                }
            });

            if (resize) {
                this._size();
                this._position();
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", resizableOptions);
            }
        },

        _setOption: function(key, value) {
            var isDraggable, isResizable,
                uiDialog = this.uiDialog;

            if (key === "disabled") {
                return;
            }

            this._super(key, value);

            if (key === "appendTo") {
                this.uiDialog.appendTo(this._appendTo());
            }

            if (key === "buttons") {
                this._createButtons();
            }

            if (key === "closeText") {
                this.uiDialogTitlebarClose.button({

                    // Ensure that we always pass a string
                    label: $("<a>").text("" + this.options.closeText).html()
                });
            }

            if (key === "draggable") {
                isDraggable = uiDialog.is(":data(ui-draggable)");
                if (isDraggable && !value) {
                    uiDialog.draggable("destroy");
                }

                if (!isDraggable && value) {
                    this._makeDraggable();
                }
            }

            if (key === "position") {
                this._position();
            }

            if (key === "resizable") {

                // currently resizable, becoming non-resizable
                isResizable = uiDialog.is(":data(ui-resizable)");
                if (isResizable && !value) {
                    uiDialog.resizable("destroy");
                }

                // Currently resizable, changing handles
                if (isResizable && typeof value === "string") {
                    uiDialog.resizable("option", "handles", value);
                }

                // Currently non-resizable, becoming resizable
                if (!isResizable && value !== false) {
                    this._makeResizable();
                }
            }

            if (key === "title") {
                this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
            }
        },

        _size: function() {

            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight, minContentHeight, maxContentHeight,
                options = this.options;

            // Reset content sizing
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            });

            if (options.minWidth > options.width) {
                options.width = options.minWidth;
            }

            // Reset wrapper sizing
            // determine the height of all the non-content elements
            nonContentHeight = this.uiDialog.css({
                    height: "auto",
                    width: options.width
                })
                .outerHeight();
            minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
            maxContentHeight = typeof options.maxHeight === "number" ?
                Math.max(0, options.maxHeight - nonContentHeight) :
                "none";

            if (options.height === "auto") {
                this.element.css({
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto"
                });
            } else {
                this.element.height(Math.max(0, options.height - nonContentHeight));
            }

            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", "minHeight", this._minHeight());
            }
        },

        _blockFrames: function() {
            this.iframeBlocks = this.document.find("iframe").map(function() {
                var iframe = $(this);

                return $("<div>")
                    .css({
                        position: "absolute",
                        width: iframe.outerWidth(),
                        height: iframe.outerHeight()
                    })
                    .appendTo(iframe.parent())
                    .offset(iframe.offset())[0];
            });
        },

        _unblockFrames: function() {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },

        _allowInteraction: function(event) {
            if ($(event.target).closest(".ui-dialog").length) {
                return true;
            }

            // TODO: Remove hack when datepicker implements
            // the .ui-front logic (#8989)
            return !!$(event.target).closest(".ui-datepicker").length;
        },

        _createOverlay: function() {
            if (!this.options.modal) {
                return;
            }

            // We use a delay in case the overlay is created from an
            // event that we're going to be cancelling (#2804)
            var isOpening = true;
            this._delay(function() {
                isOpening = false;
            });

            if (!this.document.data("ui-dialog-overlays")) {

                // Prevent use of anchors and inputs
                // Using _on() for an event handler shared across many instances is
                // safe because the dialogs stack and must be closed in reverse order
                this._on(this.document, {
                    focusin: function(event) {
                        if (isOpening) {
                            return;
                        }

                        if (!this._allowInteraction(event)) {
                            event.preventDefault();
                            this._trackingInstances()[0]._focusTabbable();
                        }
                    }
                });
            }

            this.overlay = $("<div>")
                .appendTo(this._appendTo());

            this._addClass(this.overlay, null, "ui-widget-overlay ui-front");
            this._on(this.overlay, {
                mousedown: "_keepFocus"
            });
            this.document.data("ui-dialog-overlays",
                (this.document.data("ui-dialog-overlays") || 0) + 1);
        },

        _destroyOverlay: function() {
            if (!this.options.modal) {
                return;
            }

            if (this.overlay) {
                var overlays = this.document.data("ui-dialog-overlays") - 1;

                if (!overlays) {
                    this._off(this.document, "focusin");
                    this.document.removeData("ui-dialog-overlays");
                } else {
                    this.document.data("ui-dialog-overlays", overlays);
                }

                this.overlay.remove();
                this.overlay = null;
            }
        }
    });

    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {

        // Backcompat for dialogClass option
        $.widget("ui.dialog", $.ui.dialog, {
            options: {
                dialogClass: ""
            },
            _createWrapper: function() {
                this._super();
                this.uiDialog.addClass(this.options.dialogClass);
            },
            _setOption: function(key, value) {
                if (key === "dialogClass") {
                    this.uiDialog
                        .removeClass(this.options.dialogClass)
                        .addClass(value);
                }
                this._superApply(arguments);
            }
        });
    }

    var widgetsDialog = $.ui.dialog;


    /*!
     * jQuery UI Droppable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Droppable
    //>>group: Interactions
    //>>description: Enables drop targets for draggable elements.
    //>>docs: http://api.jqueryui.com/droppable/
    //>>demos: http://jqueryui.com/droppable/



    $.widget("ui.droppable", {
        version: "1.12.1",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            addClasses: true,
            greedy: false,
            scope: "default",
            tolerance: "intersect",

            // Callbacks
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {

            var proportions,
                o = this.options,
                accept = o.accept;

            this.isover = false;
            this.isout = true;

            this.accept = $.isFunction(accept) ? accept : function(d) {
                return d.is(accept);
            };

            this.proportions = function( /* valueToWrite */ ) {
                if (arguments.length) {

                    // Store the droppable's proportions
                    proportions = arguments[0];
                } else {

                    // Retrieve or derive the droppable's proportions
                    return proportions ?
                        proportions :
                        proportions = {
                            width: this.element[0].offsetWidth,
                            height: this.element[0].offsetHeight
                        };
                }
            };

            this._addToManager(o.scope);

            o.addClasses && this._addClass("ui-droppable");

        },

        _addToManager: function(scope) {

            // Add the reference and positions to the manager
            $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
            $.ui.ddmanager.droppables[scope].push(this);
        },

        _splice: function(drop) {
            var i = 0;
            for (; i < drop.length; i++) {
                if (drop[i] === this) {
                    drop.splice(i, 1);
                }
            }
        },

        _destroy: function() {
            var drop = $.ui.ddmanager.droppables[this.options.scope];

            this._splice(drop);
        },

        _setOption: function(key, value) {

            if (key === "accept") {
                this.accept = $.isFunction(value) ? value : function(d) {
                    return d.is(value);
                };
            } else if (key === "scope") {
                var drop = $.ui.ddmanager.droppables[this.options.scope];

                this._splice(drop);
                this._addToManager(value);
            }

            this._super(key, value);
        },

        _activate: function(event) {
            var draggable = $.ui.ddmanager.current;

            this._addActiveClass();
            if (draggable) {
                this._trigger("activate", event, this.ui(draggable));
            }
        },

        _deactivate: function(event) {
            var draggable = $.ui.ddmanager.current;

            this._removeActiveClass();
            if (draggable) {
                this._trigger("deactivate", event, this.ui(draggable));
            }
        },

        _over: function(event) {

            var draggable = $.ui.ddmanager.current;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem ||
                    draggable.element)[0] === this.element[0]) {
                return;
            }

            if (this.accept.call(this.element[0], (draggable.currentItem ||
                    draggable.element))) {
                this._addHoverClass();
                this._trigger("over", event, this.ui(draggable));
            }

        },

        _out: function(event) {

            var draggable = $.ui.ddmanager.current;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem ||
                    draggable.element)[0] === this.element[0]) {
                return;
            }

            if (this.accept.call(this.element[0], (draggable.currentItem ||
                    draggable.element))) {
                this._removeHoverClass();
                this._trigger("out", event, this.ui(draggable));
            }

        },

        _drop: function(event, custom) {

            var draggable = custom || $.ui.ddmanager.current,
                childrenIntersection = false;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem ||
                    draggable.element)[0] === this.element[0]) {
                return false;
            }

            this.element
                .find(":data(ui-droppable)")
                .not(".ui-draggable-dragging")
                .each(function() {
                    var inst = $(this).droppable("instance");
                    if (
                        inst.options.greedy &&
                        !inst.options.disabled &&
                        inst.options.scope === draggable.options.scope &&
                        inst.accept.call(
                            inst.element[0], (draggable.currentItem || draggable.element)
                        ) &&
                        intersect(
                            draggable,
                            $.extend(inst, {
                                offset: inst.element.offset()
                            }),
                            inst.options.tolerance, event
                        )
                    ) {
                        childrenIntersection = true;
                        return false;
                    }
                });
            if (childrenIntersection) {
                return false;
            }

            if (this.accept.call(this.element[0],
                    (draggable.currentItem || draggable.element))) {
                this._removeActiveClass();
                this._removeHoverClass();

                this._trigger("drop", event, this.ui(draggable));
                return this.element;
            }

            return false;

        },

        ui: function(c) {
            return {
                draggable: (c.currentItem || c.element),
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        },

        // Extension points just to make backcompat sane and avoid duplicating logic
        // TODO: Remove in 1.13 along with call to it below
        _addHoverClass: function() {
            this._addClass("ui-droppable-hover");
        },

        _removeHoverClass: function() {
            this._removeClass("ui-droppable-hover");
        },

        _addActiveClass: function() {
            this._addClass("ui-droppable-active");
        },

        _removeActiveClass: function() {
            this._removeClass("ui-droppable-active");
        }
    });

    var intersect = $.ui.intersect = (function() {
        function isOverAxis(x, reference, size) {
            return (x >= reference) && (x < (reference + size));
        }

        return function(draggable, droppable, toleranceMode, event) {

            if (!droppable.offset) {
                return false;
            }

            var x1 = (draggable.positionAbs ||
                    draggable.position.absolute).left + draggable.margins.left,
                y1 = (draggable.positionAbs ||
                    draggable.position.absolute).top + draggable.margins.top,
                x2 = x1 + draggable.helperProportions.width,
                y2 = y1 + draggable.helperProportions.height,
                l = droppable.offset.left,
                t = droppable.offset.top,
                r = l + droppable.proportions().width,
                b = t + droppable.proportions().height;

            switch (toleranceMode) {
                case "fit":
                    return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
                case "intersect":
                    return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
                        x2 - (draggable.helperProportions.width / 2) < r && // Left Half
                        t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
                        y2 - (draggable.helperProportions.height / 2) < b); // Top Half
                case "pointer":
                    return isOverAxis(event.pageY, t, droppable.proportions().height) &&
                        isOverAxis(event.pageX, l, droppable.proportions().width);
                case "touch":
                    return (
                        (y1 >= t && y1 <= b) || // Top edge touching
                        (y2 >= t && y2 <= b) || // Bottom edge touching
                        (y1 < t && y2 > b) // Surrounded vertically
                    ) && (
                        (x1 >= l && x1 <= r) || // Left edge touching
                        (x2 >= l && x2 <= r) || // Right edge touching
                        (x1 < l && x2 > r) // Surrounded horizontally
                    );
                default:
                    return false;
            }
        };
    })();

    /*
    	This manager tracks offsets of draggables and droppables
    */
    $.ui.ddmanager = {
        current: null,
        droppables: {
            "default": []
        },
        prepareOffsets: function(t, event) {

            var i, j,
                m = $.ui.ddmanager.droppables[t.options.scope] || [],
                type = event ? event.type : null, // workaround for #2317
                list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();

            droppablesLoop: for (i = 0; i < m.length; i++) {

                // No disabled and non-accepted
                if (m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],
                        (t.currentItem || t.element)))) {
                    continue;
                }

                // Filter out elements in the current dragged item
                for (j = 0; j < list.length; j++) {
                    if (list[j] === m[i].element[0]) {
                        m[i].proportions().height = 0;
                        continue droppablesLoop;
                    }
                }

                m[i].visible = m[i].element.css("display") !== "none";
                if (!m[i].visible) {
                    continue;
                }

                // Activate the droppable if used directly from draggables
                if (type === "mousedown") {
                    m[i]._activate.call(m[i], event);
                }

                m[i].offset = m[i].element.offset();
                m[i].proportions({
                    width: m[i].element[0].offsetWidth,
                    height: m[i].element[0].offsetHeight
                });

            }

        },
        drop: function(draggable, event) {

            var dropped = false;

            // Create a copy of the droppables in case the list changes during the drop (#9116)
            $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {

                if (!this.options) {
                    return;
                }
                if (!this.options.disabled && this.visible &&
                    intersect(draggable, this, this.options.tolerance, event)) {
                    dropped = this._drop.call(this, event) || dropped;
                }

                if (!this.options.disabled && this.visible && this.accept.call(this.element[0],
                        (draggable.currentItem || draggable.element))) {
                    this.isout = true;
                    this.isover = false;
                    this._deactivate.call(this, event);
                }

            });
            return dropped;

        },
        dragStart: function(draggable, event) {

            // Listen for scrolling so that if the dragging causes scrolling the position of the
            // droppables can be recalculated (see #5003)
            draggable.element.parentsUntil("body").on("scroll.droppable", function() {
                if (!draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
            });
        },
        drag: function(draggable, event) {

            // If you have a highly dynamic page, you might try this option. It renders positions
            // every time you move the mouse.
            if (draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }

            // Run through all droppables and check their positions based on specific tolerance options
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

                if (this.options.disabled || this.greedyChild || !this.visible) {
                    return;
                }

                var parentInstance, scope, parent,
                    intersects = intersect(draggable, this, this.options.tolerance, event),
                    c = !intersects && this.isover ?
                    "isout" :
                    (intersects && !this.isover ? "isover" : null);
                if (!c) {
                    return;
                }

                if (this.options.greedy) {

                    // find droppable parents with same scope
                    scope = this.options.scope;
                    parent = this.element.parents(":data(ui-droppable)").filter(function() {
                        return $(this).droppable("instance").options.scope === scope;
                    });

                    if (parent.length) {
                        parentInstance = $(parent[0]).droppable("instance");
                        parentInstance.greedyChild = (c === "isover");
                    }
                }

                // We just moved into a greedy child
                if (parentInstance && c === "isover") {
                    parentInstance.isover = false;
                    parentInstance.isout = true;
                    parentInstance._out.call(parentInstance, event);
                }

                this[c] = true;
                this[c === "isout" ? "isover" : "isout"] = false;
                this[c === "isover" ? "_over" : "_out"].call(this, event);

                // We just moved out of a greedy child
                if (parentInstance && c === "isout") {
                    parentInstance.isout = false;
                    parentInstance.isover = true;
                    parentInstance._over.call(parentInstance, event);
                }
            });

        },
        dragStop: function(draggable, event) {
            draggable.element.parentsUntil("body").off("scroll.droppable");

            // Call prepareOffsets one final time since IE does not fire return scroll events when
            // overflow was caused by drag (see #5003)
            if (!draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
        }
    };

    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {

        // Backcompat for activeClass and hoverClass options
        $.widget("ui.droppable", $.ui.droppable, {
            options: {
                hoverClass: false,
                activeClass: false
            },
            _addActiveClass: function() {
                this._super();
                if (this.options.activeClass) {
                    this.element.addClass(this.options.activeClass);
                }
            },
            _removeActiveClass: function() {
                this._super();
                if (this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
            },
            _addHoverClass: function() {
                this._super();
                if (this.options.hoverClass) {
                    this.element.addClass(this.options.hoverClass);
                }
            },
            _removeHoverClass: function() {
                this._super();
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
            }
        });
    }

    var widgetsDroppable = $.ui.droppable;


    /*!
     * jQuery UI Progressbar 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Progressbar
    //>>group: Widgets
    // jscs:disable maximumLineLength
    //>>description: Displays a status indicator for loading state, standard percentage, and other progress indicators.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/progressbar/
    //>>demos: http://jqueryui.com/progressbar/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/progressbar.css
    //>>css.theme: ../../themes/base/theme.css



    var widgetsProgressbar = $.widget("ui.progressbar", {
        version: "1.12.1",
        options: {
            classes: {
                "ui-progressbar": "ui-corner-all",
                "ui-progressbar-value": "ui-corner-left",
                "ui-progressbar-complete": "ui-corner-right"
            },
            max: 100,
            value: 0,

            change: null,
            complete: null
        },

        min: 0,

        _create: function() {

            // Constrain initial value
            this.oldValue = this.options.value = this._constrainedValue();

            this.element.attr({

                // Only set static values; aria-valuenow and aria-valuemax are
                // set inside _refreshValue()
                role: "progressbar",
                "aria-valuemin": this.min
            });
            this._addClass("ui-progressbar", "ui-widget ui-widget-content");

            this.valueDiv = $("<div>").appendTo(this.element);
            this._addClass(this.valueDiv, "ui-progressbar-value", "ui-widget-header");
            this._refreshValue();
        },

        _destroy: function() {
            this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow");

            this.valueDiv.remove();
        },

        value: function(newValue) {
            if (newValue === undefined) {
                return this.options.value;
            }

            this.options.value = this._constrainedValue(newValue);
            this._refreshValue();
        },

        _constrainedValue: function(newValue) {
            if (newValue === undefined) {
                newValue = this.options.value;
            }

            this.indeterminate = newValue === false;

            // Sanitize value
            if (typeof newValue !== "number") {
                newValue = 0;
            }

            return this.indeterminate ? false :
                Math.min(this.options.max, Math.max(this.min, newValue));
        },

        _setOptions: function(options) {

            // Ensure "value" option is set after other values (like max)
            var value = options.value;
            delete options.value;

            this._super(options);

            this.options.value = this._constrainedValue(value);
            this._refreshValue();
        },

        _setOption: function(key, value) {
            if (key === "max") {

                // Don't allow a max less than min
                value = Math.max(this.min, value);
            }
            this._super(key, value);
        },

        _setOptionDisabled: function(value) {
            this._super(value);

            this.element.attr("aria-disabled", value);
            this._toggleClass(null, "ui-state-disabled", !!value);
        },

        _percentage: function() {
            return this.indeterminate ?
                100 :
                100 * (this.options.value - this.min) / (this.options.max - this.min);
        },

        _refreshValue: function() {
            var value = this.options.value,
                percentage = this._percentage();

            this.valueDiv
                .toggle(this.indeterminate || value > this.min)
                .width(percentage.toFixed(0) + "%");

            this
                ._toggleClass(this.valueDiv, "ui-progressbar-complete", null,
                    value === this.options.max)
                ._toggleClass("ui-progressbar-indeterminate", null, this.indeterminate);

            if (this.indeterminate) {
                this.element.removeAttr("aria-valuenow");
                if (!this.overlayDiv) {
                    this.overlayDiv = $("<div>").appendTo(this.valueDiv);
                    this._addClass(this.overlayDiv, "ui-progressbar-overlay");
                }
            } else {
                this.element.attr({
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value
                });
                if (this.overlayDiv) {
                    this.overlayDiv.remove();
                    this.overlayDiv = null;
                }
            }

            if (this.oldValue !== value) {
                this.oldValue = value;
                this._trigger("change");
            }
            if (value === this.options.max) {
                this._trigger("complete");
            }
        }
    });


    /*!
     * jQuery UI Selectable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Selectable
    //>>group: Interactions
    //>>description: Allows groups of elements to be selected with the mouse.
    //>>docs: http://api.jqueryui.com/selectable/
    //>>demos: http://jqueryui.com/selectable/
    //>>css.structure: ../../themes/base/selectable.css



    var widgetsSelectable = $.widget("ui.selectable", $.ui.mouse, {
        version: "1.12.1",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",

            // Callbacks
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var that = this;

            this._addClass("ui-selectable");

            this.dragged = false;

            // Cache selectee children based on filter
            this.refresh = function() {
                that.elementPos = $(that.element[0]).offset();
                that.selectees = $(that.options.filter, that.element[0]);
                that._addClass(that.selectees, "ui-selectee");
                that.selectees.each(function() {
                    var $this = $(this),
                        selecteeOffset = $this.offset(),
                        pos = {
                            left: selecteeOffset.left - that.elementPos.left,
                            top: selecteeOffset.top - that.elementPos.top
                        };
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting")
                    });
                });
            };
            this.refresh();

            this._mouseInit();

            this.helper = $("<div>");
            this._addClass(this.helper, "ui-selectable-helper");
        },

        _destroy: function() {
            this.selectees.removeData("selectable-item");
            this._mouseDestroy();
        },

        _mouseStart: function(event) {
            var that = this,
                options = this.options;

            this.opos = [event.pageX, event.pageY];
            this.elementPos = $(this.element[0]).offset();

            if (this.options.disabled) {
                return;
            }

            this.selectees = $(options.filter, this.element[0]);

            this._trigger("start", event);

            $(options.appendTo).append(this.helper);

            // position helper (lasso)
            this.helper.css({
                "left": event.pageX,
                "top": event.pageY,
                "width": 0,
                "height": 0
            });

            if (options.autoRefresh) {
                this.refresh();
            }

            this.selectees.filter(".ui-selected").each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = true;
                if (!event.metaKey && !event.ctrlKey) {
                    that._removeClass(selectee.$element, "ui-selected");
                    selectee.selected = false;
                    that._addClass(selectee.$element, "ui-unselecting");
                    selectee.unselecting = true;

                    // selectable UNSELECTING callback
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    });
                }
            });

            $(event.target).parents().addBack().each(function() {
                var doSelect,
                    selectee = $.data(this, "selectable-item");
                if (selectee) {
                    doSelect = (!event.metaKey && !event.ctrlKey) ||
                        !selectee.$element.hasClass("ui-selected");
                    that._removeClass(selectee.$element, doSelect ? "ui-unselecting" : "ui-selected")
                        ._addClass(selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting");
                    selectee.unselecting = !doSelect;
                    selectee.selecting = doSelect;
                    selectee.selected = doSelect;

                    // selectable (UN)SELECTING callback
                    if (doSelect) {
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    } else {
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                    return false;
                }
            });

        },

        _mouseDrag: function(event) {

            this.dragged = true;

            if (this.options.disabled) {
                return;
            }

            var tmp,
                that = this,
                options = this.options,
                x1 = this.opos[0],
                y1 = this.opos[1],
                x2 = event.pageX,
                y2 = event.pageY;

            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            this.helper.css({
                left: x1,
                top: y1,
                width: x2 - x1,
                height: y2 - y1
            });

            this.selectees.each(function() {
                var selectee = $.data(this, "selectable-item"),
                    hit = false,
                    offset = {};

                //prevent helper from being selected if appendTo: selectable
                if (!selectee || selectee.element === that.element[0]) {
                    return;
                }

                offset.left = selectee.left + that.elementPos.left;
                offset.right = selectee.right + that.elementPos.left;
                offset.top = selectee.top + that.elementPos.top;
                offset.bottom = selectee.bottom + that.elementPos.top;

                if (options.tolerance === "touch") {
                    hit = (!(offset.left > x2 || offset.right < x1 || offset.top > y2 ||
                        offset.bottom < y1));
                } else if (options.tolerance === "fit") {
                    hit = (offset.left > x1 && offset.right < x2 && offset.top > y1 &&
                        offset.bottom < y2);
                }

                if (hit) {

                    // SELECT
                    if (selectee.selected) {
                        that._removeClass(selectee.$element, "ui-selected");
                        selectee.selected = false;
                    }
                    if (selectee.unselecting) {
                        that._removeClass(selectee.$element, "ui-unselecting");
                        selectee.unselecting = false;
                    }
                    if (!selectee.selecting) {
                        that._addClass(selectee.$element, "ui-selecting");
                        selectee.selecting = true;

                        // selectable SELECTING callback
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    }
                } else {

                    // UNSELECT
                    if (selectee.selecting) {
                        if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                            that._removeClass(selectee.$element, "ui-selecting");
                            selectee.selecting = false;
                            that._addClass(selectee.$element, "ui-selected");
                            selectee.selected = true;
                        } else {
                            that._removeClass(selectee.$element, "ui-selecting");
                            selectee.selecting = false;
                            if (selectee.startselected) {
                                that._addClass(selectee.$element, "ui-unselecting");
                                selectee.unselecting = true;
                            }

                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                    if (selectee.selected) {
                        if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                            that._removeClass(selectee.$element, "ui-selected");
                            selectee.selected = false;

                            that._addClass(selectee.$element, "ui-unselecting");
                            selectee.unselecting = true;

                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                }
            });

            return false;
        },

        _mouseStop: function(event) {
            var that = this;

            this.dragged = false;

            $(".ui-unselecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                that._removeClass(selectee.$element, "ui-unselecting");
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger("unselected", event, {
                    unselected: selectee.element
                });
            });
            $(".ui-selecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                that._removeClass(selectee.$element, "ui-selecting")
                    ._addClass(selectee.$element, "ui-selected");
                selectee.selecting = false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger("selected", event, {
                    selected: selectee.element
                });
            });
            this._trigger("stop", event);

            this.helper.remove();

            return false;
        }

    });


    /*!
     * jQuery UI Selectmenu 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Selectmenu
    //>>group: Widgets
    // jscs:disable maximumLineLength
    //>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select.
    // jscs:enable maximumLineLength
    //>>docs: http://api.jqueryui.com/selectmenu/
    //>>demos: http://jqueryui.com/selectmenu/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css
    //>>css.theme: ../../themes/base/theme.css



    var widgetsSelectmenu = $.widget("ui.selectmenu", [$.ui.formResetMixin, {
        version: "1.12.1",
        defaultElement: "<select>",
        options: {
            appendTo: null,
            classes: {
                "ui-selectmenu-button-open": "ui-corner-top",
                "ui-selectmenu-button-closed": "ui-corner-all"
            },
            disabled: null,
            icons: {
                button: "ui-icon-triangle-1-s"
            },
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            width: false,

            // Callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            select: null
        },

        _create: function() {
            var selectmenuId = this.element.uniqueId().attr("id");
            this.ids = {
                element: selectmenuId,
                button: selectmenuId + "-button",
                menu: selectmenuId + "-menu"
            };

            this._drawButton();
            this._drawMenu();
            this._bindFormResetHandler();

            this._rendered = false;
            this.menuItems = $();
        },

        _drawButton: function() {
            var icon,
                that = this,
                item = this._parseOption(
                    this.element.find("option:selected"),
                    this.element[0].selectedIndex
                );

            // Associate existing label with the new button
            this.labels = this.element.labels().attr("for", this.ids.button);
            this._on(this.labels, {
                click: function(event) {
                    this.button.focus();
                    event.preventDefault();
                }
            });

            // Hide original select element
            this.element.hide();

            // Create button
            this.button = $("<span>", {
                    tabindex: this.options.disabled ? -1 : 0,
                    id: this.ids.button,
                    role: "combobox",
                    "aria-expanded": "false",
                    "aria-autocomplete": "list",
                    "aria-owns": this.ids.menu,
                    "aria-haspopup": "true",
                    title: this.element.attr("title")
                })
                .insertAfter(this.element);

            this._addClass(this.button, "ui-selectmenu-button ui-selectmenu-button-closed",
                "ui-button ui-widget");

            icon = $("<span>").appendTo(this.button);
            this._addClass(icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button);
            this.buttonItem = this._renderButtonItem(item)
                .appendTo(this.button);

            if (this.options.width !== false) {
                this._resizeButton();
            }

            this._on(this.button, this._buttonEvents);
            this.button.one("focusin", function() {

                // Delay rendering the menu items until the button receives focus.
                // The menu may have already been rendered via a programmatic open.
                if (!that._rendered) {
                    that._refreshMenu();
                }
            });
        },

        _drawMenu: function() {
            var that = this;

            // Create menu
            this.menu = $("<ul>", {
                "aria-hidden": "true",
                "aria-labelledby": this.ids.button,
                id: this.ids.menu
            });

            // Wrap menu
            this.menuWrap = $("<div>").append(this.menu);
            this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front");
            this.menuWrap.appendTo(this._appendTo());

            // Initialize menu widget
            this.menuInstance = this.menu
                .menu({
                    classes: {
                        "ui-menu": "ui-corner-bottom"
                    },
                    role: "listbox",
                    select: function(event, ui) {
                        event.preventDefault();

                        // Support: IE8
                        // If the item was selected via a click, the text selection
                        // will be destroyed in IE
                        that._setSelection();

                        that._select(ui.item.data("ui-selectmenu-item"), event);
                    },
                    focus: function(event, ui) {
                        var item = ui.item.data("ui-selectmenu-item");

                        // Prevent inital focus from firing and check if its a newly focused item
                        if (that.focusIndex != null && item.index !== that.focusIndex) {
                            that._trigger("focus", event, {
                                item: item
                            });
                            if (!that.isOpen) {
                                that._select(item, event);
                            }
                        }
                        that.focusIndex = item.index;

                        that.button.attr("aria-activedescendant",
                            that.menuItems.eq(item.index).attr("id"));
                    }
                })
                .menu("instance");

            // Don't close the menu on mouseleave
            this.menuInstance._off(this.menu, "mouseleave");

            // Cancel the menu's collapseAll on document click
            this.menuInstance._closeOnDocumentClick = function() {
                return false;
            };

            // Selects often contain empty items, but never contain dividers
            this.menuInstance._isDivider = function() {
                return false;
            };
        },

        refresh: function() {
            this._refreshMenu();
            this.buttonItem.replaceWith(
                this.buttonItem = this._renderButtonItem(

                    // Fall back to an empty object in case there are no options
                    this._getSelectedItem().data("ui-selectmenu-item") || {}
                )
            );
            if (this.options.width === null) {
                this._resizeButton();
            }
        },

        _refreshMenu: function() {
            var item,
                options = this.element.find("option");

            this.menu.empty();

            this._parseOptions(options);
            this._renderMenu(this.menu, this.items);

            this.menuInstance.refresh();
            this.menuItems = this.menu.find("li")
                .not(".ui-selectmenu-optgroup")
                .find(".ui-menu-item-wrapper");

            this._rendered = true;

            if (!options.length) {
                return;
            }

            item = this._getSelectedItem();

            // Update the menu to have the correct item focused
            this.menuInstance.focus(null, item);
            this._setAria(item.data("ui-selectmenu-item"));

            // Set disabled state
            this._setOption("disabled", this.element.prop("disabled"));
        },

        open: function(event) {
            if (this.options.disabled) {
                return;
            }

            // If this is the first time the menu is being opened, render the items
            if (!this._rendered) {
                this._refreshMenu();
            } else {

                // Menu clears focus on close, reset focus to selected item
                this._removeClass(this.menu.find(".ui-state-active"), null, "ui-state-active");
                this.menuInstance.focus(null, this._getSelectedItem());
            }

            // If there are no options, don't open the menu
            if (!this.menuItems.length) {
                return;
            }

            this.isOpen = true;
            this._toggleAttr();
            this._resizeMenu();
            this._position();

            this._on(this.document, this._documentClick);

            this._trigger("open", event);
        },

        _position: function() {
            this.menuWrap.position($.extend({ of: this.button
            }, this.options.position));
        },

        close: function(event) {
            if (!this.isOpen) {
                return;
            }

            this.isOpen = false;
            this._toggleAttr();

            this.range = null;
            this._off(this.document);

            this._trigger("close", event);
        },

        widget: function() {
            return this.button;
        },

        menuWidget: function() {
            return this.menu;
        },

        _renderButtonItem: function(item) {
            var buttonItem = $("<span>");

            this._setText(buttonItem, item.label);
            this._addClass(buttonItem, "ui-selectmenu-text");

            return buttonItem;
        },

        _renderMenu: function(ul, items) {
            var that = this,
                currentOptgroup = "";

            $.each(items, function(index, item) {
                var li;

                if (item.optgroup !== currentOptgroup) {
                    li = $("<li>", {
                        text: item.optgroup
                    });
                    that._addClass(li, "ui-selectmenu-optgroup", "ui-menu-divider" +
                        (item.element.parent("optgroup").prop("disabled") ?
                            " ui-state-disabled" :
                            ""));

                    li.appendTo(ul);

                    currentOptgroup = item.optgroup;
                }

                that._renderItemData(ul, item);
            });
        },

        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-selectmenu-item", item);
        },

        _renderItem: function(ul, item) {
            var li = $("<li>"),
                wrapper = $("<div>", {
                    title: item.element.attr("title")
                });

            if (item.disabled) {
                this._addClass(li, null, "ui-state-disabled");
            }
            this._setText(wrapper, item.label);

            return li.append(wrapper).appendTo(ul);
        },

        _setText: function(element, value) {
            if (value) {
                element.text(value);
            } else {
                element.html("&#160;");
            }
        },

        _move: function(direction, event) {
            var item, next,
                filter = ".ui-menu-item";

            if (this.isOpen) {
                item = this.menuItems.eq(this.focusIndex).parent("li");
            } else {
                item = this.menuItems.eq(this.element[0].selectedIndex).parent("li");
                filter += ":not(.ui-state-disabled)";
            }

            if (direction === "first" || direction === "last") {
                next = item[direction === "first" ? "prevAll" : "nextAll"](filter).eq(-1);
            } else {
                next = item[direction + "All"](filter).eq(0);
            }

            if (next.length) {
                this.menuInstance.focus(event, next);
            }
        },

        _getSelectedItem: function() {
            return this.menuItems.eq(this.element[0].selectedIndex).parent("li");
        },

        _toggle: function(event) {
            this[this.isOpen ? "close" : "open"](event);
        },

        _setSelection: function() {
            var selection;

            if (!this.range) {
                return;
            }

            if (window.getSelection) {
                selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(this.range);

                // Support: IE8
            } else {
                this.range.select();
            }

            // Support: IE
            // Setting the text selection kills the button focus in IE, but
            // restoring the focus doesn't kill the selection.
            this.button.focus();
        },

        _documentClick: {
            mousedown: function(event) {
                if (!this.isOpen) {
                    return;
                }

                if (!$(event.target).closest(".ui-selectmenu-menu, #" +
                        $.ui.escapeSelector(this.ids.button)).length) {
                    this.close(event);
                }
            }
        },

        _buttonEvents: {

            // Prevent text selection from being reset when interacting with the selectmenu (#10144)
            mousedown: function() {
                var selection;

                if (window.getSelection) {
                    selection = window.getSelection();
                    if (selection.rangeCount) {
                        this.range = selection.getRangeAt(0);
                    }

                    // Support: IE8
                } else {
                    this.range = document.selection.createRange();
                }
            },

            click: function(event) {
                this._setSelection();
                this._toggle(event);
            },

            keydown: function(event) {
                var preventDefault = true;
                switch (event.keyCode) {
                    case $.ui.keyCode.TAB:
                    case $.ui.keyCode.ESCAPE:
                        this.close(event);
                        preventDefault = false;
                        break;
                    case $.ui.keyCode.ENTER:
                        if (this.isOpen) {
                            this._selectFocusedItem(event);
                        }
                        break;
                    case $.ui.keyCode.UP:
                        if (event.altKey) {
                            this._toggle(event);
                        } else {
                            this._move("prev", event);
                        }
                        break;
                    case $.ui.keyCode.DOWN:
                        if (event.altKey) {
                            this._toggle(event);
                        } else {
                            this._move("next", event);
                        }
                        break;
                    case $.ui.keyCode.SPACE:
                        if (this.isOpen) {
                            this._selectFocusedItem(event);
                        } else {
                            this._toggle(event);
                        }
                        break;
                    case $.ui.keyCode.LEFT:
                        this._move("prev", event);
                        break;
                    case $.ui.keyCode.RIGHT:
                        this._move("next", event);
                        break;
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.PAGE_UP:
                        this._move("first", event);
                        break;
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_DOWN:
                        this._move("last", event);
                        break;
                    default:
                        this.menu.trigger(event);
                        preventDefault = false;
                }

                if (preventDefault) {
                    event.preventDefault();
                }
            }
        },

        _selectFocusedItem: function(event) {
            var item = this.menuItems.eq(this.focusIndex).parent("li");
            if (!item.hasClass("ui-state-disabled")) {
                this._select(item.data("ui-selectmenu-item"), event);
            }
        },

        _select: function(item, event) {
            var oldIndex = this.element[0].selectedIndex;

            // Change native select element
            this.element[0].selectedIndex = item.index;
            this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(item));
            this._setAria(item);
            this._trigger("select", event, {
                item: item
            });

            if (item.index !== oldIndex) {
                this._trigger("change", event, {
                    item: item
                });
            }

            this.close(event);
        },

        _setAria: function(item) {
            var id = this.menuItems.eq(item.index).attr("id");

            this.button.attr({
                "aria-labelledby": id,
                "aria-activedescendant": id
            });
            this.menu.attr("aria-activedescendant", id);
        },

        _setOption: function(key, value) {
            if (key === "icons") {
                var icon = this.button.find("span.ui-icon");
                this._removeClass(icon, null, this.options.icons.button)
                    ._addClass(icon, null, value.button);
            }

            this._super(key, value);

            if (key === "appendTo") {
                this.menuWrap.appendTo(this._appendTo());
            }

            if (key === "width") {
                this._resizeButton();
            }
        },

        _setOptionDisabled: function(value) {
            this._super(value);

            this.menuInstance.option("disabled", value);
            this.button.attr("aria-disabled", value);
            this._toggleClass(this.button, null, "ui-state-disabled", value);

            this.element.prop("disabled", value);
            if (value) {
                this.button.attr("tabindex", -1);
                this.close();
            } else {
                this.button.attr("tabindex", 0);
            }
        },

        _appendTo: function() {
            var element = this.options.appendTo;

            if (element) {
                element = element.jquery || element.nodeType ?
                    $(element) :
                    this.document.find(element).eq(0);
            }

            if (!element || !element[0]) {
                element = this.element.closest(".ui-front, dialog");
            }

            if (!element.length) {
                element = this.document[0].body;
            }

            return element;
        },

        _toggleAttr: function() {
            this.button.attr("aria-expanded", this.isOpen);

            // We can't use two _toggleClass() calls here, because we need to make sure
            // we always remove classes first and add them second, otherwise if both classes have the
            // same theme class, it will be removed after we add it.
            this._removeClass(this.button, "ui-selectmenu-button-" +
                    (this.isOpen ? "closed" : "open"))
                ._addClass(this.button, "ui-selectmenu-button-" +
                    (this.isOpen ? "open" : "closed"))
                ._toggleClass(this.menuWrap, "ui-selectmenu-open", null, this.isOpen);

            this.menu.attr("aria-hidden", !this.isOpen);
        },

        _resizeButton: function() {
            var width = this.options.width;

            // For `width: false`, just remove inline style and stop
            if (width === false) {
                this.button.css("width", "");
                return;
            }

            // For `width: null`, match the width of the original element
            if (width === null) {
                width = this.element.show().outerWidth();
                this.element.hide();
            }

            this.button.outerWidth(width);
        },

        _resizeMenu: function() {
            this.menu.outerWidth(Math.max(
                this.button.outerWidth(),

                // Support: IE10
                // IE10 wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping
                this.menu.width("").outerWidth() + 1
            ));
        },

        _getCreateOptions: function() {
            var options = this._super();

            options.disabled = this.element.prop("disabled");

            return options;
        },

        _parseOptions: function(options) {
            var that = this,
                data = [];
            options.each(function(index, item) {
                data.push(that._parseOption($(item), index));
            });
            this.items = data;
        },

        _parseOption: function(option, index) {
            var optgroup = option.parent("optgroup");

            return {
                element: option,
                index: index,
                value: option.val(),
                label: option.text(),
                optgroup: optgroup.attr("label") || "",
                disabled: optgroup.prop("disabled") || option.prop("disabled")
            };
        },

        _destroy: function() {
            this._unbindFormResetHandler();
            this.menuWrap.remove();
            this.button.remove();
            this.element.show();
            this.element.removeUniqueId();
            this.labels.attr("for", this.ids.element);
        }
    }]);


    /*!
     * jQuery UI Slider 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Slider
    //>>group: Widgets
    //>>description: Displays a flexible slider with ranges and accessibility via keyboard.
    //>>docs: http://api.jqueryui.com/slider/
    //>>demos: http://jqueryui.com/slider/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/slider.css
    //>>css.theme: ../../themes/base/theme.css



    var widgetsSlider = $.widget("ui.slider", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "slide",

        options: {
            animate: false,
            classes: {
                "ui-slider": "ui-corner-all",
                "ui-slider-handle": "ui-corner-all",

                // Note: ui-widget-header isn't the most fittingly semantic framework class for this
                // element, but worked best visually with a variety of themes
                "ui-slider-range": "ui-corner-all ui-widget-header"
            },
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,

            // Callbacks
            change: null,
            slide: null,
            start: null,
            stop: null
        },

        // Number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        numPages: 5,

        _create: function() {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();
            this._calculateNewMax();

            this._addClass("ui-slider ui-slider-" + this.orientation,
                "ui-widget ui-widget-content");

            this._refresh();

            this._animateOff = false;
        },

        _refresh: function() {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },

        _createHandles: function() {
            var i, handleCount,
                options = this.options,
                existingHandles = this.element.find(".ui-slider-handle"),
                handle = "<span tabindex='0'></span>",
                handles = [];

            handleCount = (options.values && options.values.length) || 1;

            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }

            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }

            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

            this._addClass(this.handles, "ui-slider-handle", "ui-state-default");

            this.handle = this.handles.eq(0);

            this.handles.each(function(i) {
                $(this)
                    .data("ui-slider-handle-index", i)
                    .attr("tabIndex", 0);
            });
        },

        _createRange: function() {
            var options = this.options;

            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [this._valueMin(), this._valueMin()];
                    } else if (options.values.length && options.values.length !== 2) {
                        options.values = [options.values[0], options.values[0]];
                    } else if ($.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }

                if (!this.range || !this.range.length) {
                    this.range = $("<div>")
                        .appendTo(this.element);

                    this._addClass(this.range, "ui-slider-range");
                } else {
                    this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max");

                    // Handle range switching from true to min/max
                    this.range.css({
                        "left": "",
                        "bottom": ""
                    });
                }
                if (options.range === "min" || options.range === "max") {
                    this._addClass(this.range, "ui-slider-range-" + options.range);
                }
            } else {
                if (this.range) {
                    this.range.remove();
                }
                this.range = null;
            }
        },

        _setupEvents: function() {
            this._off(this.handles);
            this._on(this.handles, this._handleEvents);
            this._hoverable(this.handles);
            this._focusable(this.handles);
        },

        _destroy: function() {
            this.handles.remove();
            if (this.range) {
                this.range.remove();
            }

            this._mouseDestroy();
        },

        _mouseCapture: function(event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                that = this,
                o = this.options;

            if (o.disabled) {
                return false;
            }

            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();

            position = {
                x: event.pageX,
                y: event.pageY
            };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if ((distance > thisDistance) ||
                    (distance === thisDistance &&
                        (i === that._lastChangedValue || that.values(i) === o.min))) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });

            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;

            this._handleIndex = index;

            this._addClass(closestHandle, null, "ui-state-active");
            closestHandle.trigger("focus");

            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - (closestHandle.width() / 2),
                top: event.pageY - offset.top -
                    (closestHandle.height() / 2) -
                    (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) -
                    (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) +
                    (parseInt(closestHandle.css("marginTop"), 10) || 0)
            };

            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },

        _mouseStart: function() {
            return true;
        },

        _mouseDrag: function(event) {
            var position = {
                    x: event.pageX,
                    y: event.pageY
                },
                normValue = this._normValueFromMouse(position);

            this._slide(event, this._handleIndex, normValue);

            return false;
        },

        _mouseStop: function(event) {
            this._removeClass(this.handles, null, "ui-state-active");
            this._mouseSliding = false;

            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);

            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;

            return false;
        },

        _detectOrientation: function() {
            this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
        },

        _normValueFromMouse: function(position) {
            var pixelTotal,
                pixelMouse,
                percentMouse,
                valueTotal,
                valueMouse;

            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left -
                    (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top -
                    (this._clickOffset ? this._clickOffset.top : 0);
            }

            percentMouse = (pixelMouse / pixelTotal);
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }

            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;

            return this._trimAlignValue(valueMouse);
        },

        _uiHash: function(index, value, values) {
            var uiHash = {
                handle: this.handles[index],
                handleIndex: index,
                value: value !== undefined ? value : this.value()
            };

            if (this._hasMultipleValues()) {
                uiHash.value = value !== undefined ? value : this.values(index);
                uiHash.values = values || this.values();
            }

            return uiHash;
        },

        _hasMultipleValues: function() {
            return this.options.values && this.options.values.length;
        },

        _start: function(event, index) {
            return this._trigger("start", event, this._uiHash(index));
        },

        _slide: function(event, index, newVal) {
            var allowed, otherVal,
                currentValue = this.value(),
                newValues = this.values();

            if (this._hasMultipleValues()) {
                otherVal = this.values(index ? 0 : 1);
                currentValue = this.values(index);

                if (this.options.values.length === 2 && this.options.range === true) {
                    newVal = index === 0 ? Math.min(otherVal, newVal) : Math.max(otherVal, newVal);
                }

                newValues[index] = newVal;
            }

            if (newVal === currentValue) {
                return;
            }

            allowed = this._trigger("slide", event, this._uiHash(index, newVal, newValues));

            // A slide can be canceled by returning false from the slide callback
            if (allowed === false) {
                return;
            }

            if (this._hasMultipleValues()) {
                this.values(index, newVal);
            } else {
                this.value(newVal);
            }
        },

        _stop: function(event, index) {
            this._trigger("stop", event, this._uiHash(index));
        },

        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {

                //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index;
                this._trigger("change", event, this._uiHash(index));
            }
        },

        value: function(newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }

            return this._value();
        },

        values: function(index, newValue) {
            var vals,
                newValues,
                i;

            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }

            if (arguments.length) {
                if ($.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this._hasMultipleValues()) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },

        _setOption: function(key, value) {
            var i,
                valsLength = 0;

            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(this.options.values.length - 1);
                    this.options.values = null;
                }
            }

            if ($.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }

            this._super(key, value);

            switch (key) {
                case "orientation":
                    this._detectOrientation();
                    this._removeClass("ui-slider-horizontal ui-slider-vertical")
                        ._addClass("ui-slider-" + this.orientation);
                    this._refreshValue();
                    if (this.options.range) {
                        this._refreshRange(value);
                    }

                    // Reset positioning from previous orientation
                    this.handles.css(value === "horizontal" ? "bottom" : "left", "");
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();

                    // Start from the last handle to prevent unreachable handles (#9046)
                    for (i = valsLength - 1; i >= 0; i--) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;
                case "step":
                case "min":
                case "max":
                    this._animateOff = true;
                    this._calculateNewMax();
                    this._refreshValue();
                    this._animateOff = false;
                    break;
                case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
            }
        },

        _setOptionDisabled: function(value) {
            this._super(value);

            this._toggleClass(null, "ui-state-disabled", !!value);
        },

        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function() {
            var val = this.options.value;
            val = this._trimAlignValue(val);

            return val;
        },

        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function(index) {
            var val,
                vals,
                i;

            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);

                return val;
            } else if (this._hasMultipleValues()) {

                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }

                return vals;
            } else {
                return [];
            }
        },

        // Returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = (this.options.step > 0) ? this.options.step : 1,
                valModStep = (val - this._valueMin()) % step,
                alignValue = val - valModStep;

            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += (valModStep > 0) ? step : (-step);
            }

            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat(alignValue.toFixed(5));
        },

        _calculateNewMax: function() {
            var max = this.options.max,
                min = this._valueMin(),
                step = this.options.step,
                aboveMin = Math.round((max - min) / step) * step;
            max = aboveMin + min;
            if (max > this.options.max) {

                //If max is not divisible by step, rounding off may increase its value
                max -= step;
            }
            this.max = parseFloat(max.toFixed(this._precision()));
        },

        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },

        _precisionOf: function(num) {
            var str = num.toString(),
                decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },

        _valueMin: function() {
            return this.options.min;
        },

        _valueMax: function() {
            return this.max;
        },

        _refreshRange: function(orientation) {
            if (orientation === "vertical") {
                this.range.css({
                    "width": "",
                    "left": ""
                });
            }
            if (orientation === "horizontal") {
                this.range.css({
                    "height": "",
                    "bottom": ""
                });
            }
        },

        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax,
                oRange = this.options.range,
                o = this.options,
                that = this,
                animate = (!this._animateOff) ? o.animate : false,
                _set = {};

            if (this._hasMultipleValues()) {
                this.handles.each(function(i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() -
                        that._valueMin()) * 100;
                    _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    left: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    width: (valPercent - lastValPercent) + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        } else {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    bottom: (valPercent) + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    height: (valPercent - lastValPercent) + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = (valueMax !== valueMin) ?
                    (value - valueMin) / (valueMax - valueMin) * 100 :
                    0;
                _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        width: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        width: (100 - valPercent) + "%"
                    }, o.animate);
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        height: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        height: (100 - valPercent) + "%"
                    }, o.animate);
                }
            }
        },

        _handleEvents: {
            keydown: function(event) {
                var allowed, curVal, newVal, step,
                    index = $(event.target).data("ui-slider-handle-index");

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if (!this._keySliding) {
                            this._keySliding = true;
                            this._addClass($(event.target), null, "ui-state-active");
                            allowed = this._start(event, index);
                            if (allowed === false) {
                                return;
                            }
                        }
                        break;
                }

                step = this.options.step;
                if (this._hasMultipleValues()) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(
                            curVal + ((this._valueMax() - this._valueMin()) / this.numPages)
                        );
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(
                            curVal - ((this._valueMax() - this._valueMin()) / this.numPages));
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal + step);
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal - step);
                        break;
                }

                this._slide(event, index, newVal);
            },
            keyup: function(event) {
                var index = $(event.target).data("ui-slider-handle-index");

                if (this._keySliding) {
                    this._keySliding = false;
                    this._stop(event, index);
                    this._change(event, index);
                    this._removeClass($(event.target), null, "ui-state-active");
                }
            }
        }
    });


    /*!
     * jQuery UI Sortable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Sortable
    //>>group: Interactions
    //>>description: Enables items in a list to be sorted using the mouse.
    //>>docs: http://api.jqueryui.com/sortable/
    //>>demos: http://jqueryui.com/sortable/
    //>>css.structure: ../../themes/base/sortable.css



    var widgetsSortable = $.widget("ui.sortable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1000,

            // Callbacks
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },

        _isOverAxis: function(x, reference, size) {
            return (x >= reference) && (x < (reference + size));
        },

        _isFloating: function(item) {
            return (/left|right/).test(item.css("float")) ||
                (/inline|table-cell/).test(item.css("display"));
        },

        _create: function() {
            this.containerCache = {};
            this._addClass("ui-sortable");

            //Get the items
            this.refresh();

            //Let's determine the parent's offset
            this.offset = this.element.offset();

            //Initialize mouse events for interaction
            this._mouseInit();

            this._setHandleClassName();

            //We're ready to go
            this.ready = true;

        },

        _setOption: function(key, value) {
            this._super(key, value);

            if (key === "handle") {
                this._setHandleClassName();
            }
        },

        _setHandleClassName: function() {
            var that = this;
            this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle");
            $.each(this.items, function() {
                that._addClass(
                    this.instance.options.handle ?
                    this.item.find(this.instance.options.handle) :
                    this.item,
                    "ui-sortable-handle"
                );
            });
        },

        _destroy: function() {
            this._mouseDestroy();

            for (var i = this.items.length - 1; i >= 0; i--) {
                this.items[i].item.removeData(this.widgetName + "-item");
            }

            return this;
        },

        _mouseCapture: function(event, overrideHandle) {
            var currentItem = null,
                validHandle = false,
                that = this;

            if (this.reverting) {
                return false;
            }

            if (this.options.disabled || this.options.type === "static") {
                return false;
            }

            //We have to refresh the items data once first
            this._refreshItems(event);

            //Find out if the clicked node (or one of its parents) is a actual item in this.items
            $(event.target).parents().each(function() {
                if ($.data(this, that.widgetName + "-item") === that) {
                    currentItem = $(this);
                    return false;
                }
            });
            if ($.data(event.target, that.widgetName + "-item") === that) {
                currentItem = $(event.target);
            }

            if (!currentItem) {
                return false;
            }
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem).find("*").addBack().each(function() {
                    if (this === event.target) {
                        validHandle = true;
                    }
                });
                if (!validHandle) {
                    return false;
                }
            }

            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;

        },

        _mouseStart: function(event, overrideHandle, noActivation) {

            var i, body,
                o = this.options;

            this.currentContainer = this;

            //We only need to call refreshPositions, because the refreshItems call has been moved to
            // mouseCapture
            this.refreshPositions();

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            //Cache the helper size
            this._cacheHelperProportions();

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Get the next scrolling parent
            this.scrollParent = this.helper.scrollParent();

            //The element's absolute position on the page minus margins
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };

            $.extend(this.offset, {
                click: { //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),

                // This is a relative to absolute position minus the actual position calculation -
                // only used for relative positioned helper
                relative: this._getRelativeOffset()
            });

            // Only after we got the offset, we can change the helper's position to absolute
            // TODO: Still need to figure out a way to make relative sorting possible
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");

            //Generate the original position
            this.originalPosition = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

            //Cache the former DOM position
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            };

            // If the helper is not the original, hide the original so it's not playing any role during
            // the drag, won't cause anything bad this way
            if (this.helper[0] !== this.currentItem[0]) {
                this.currentItem.hide();
            }

            //Create the placeholder
            this._createPlaceholder();

            //Set a containment if given in the options
            if (o.containment) {
                this._setContainment();
            }

            if (o.cursor && o.cursor !== "auto") { // cursor option
                body = this.document.find("body");

                // Support: IE
                this.storedCursor = body.css("cursor");
                body.css("cursor", o.cursor);

                this.storedStylesheet =
                    $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
            }

            if (o.opacity) { // opacity option
                if (this.helper.css("opacity")) {
                    this._storedOpacity = this.helper.css("opacity");
                }
                this.helper.css("opacity", o.opacity);
            }

            if (o.zIndex) { // zIndex option
                if (this.helper.css("zIndex")) {
                    this._storedZIndex = this.helper.css("zIndex");
                }
                this.helper.css("zIndex", o.zIndex);
            }

            //Prepare scrolling
            if (this.scrollParent[0] !== this.document[0] &&
                this.scrollParent[0].tagName !== "HTML") {
                this.overflowOffset = this.scrollParent.offset();
            }

            //Call callbacks
            this._trigger("start", event, this._uiHash());

            //Recache the helper size
            if (!this._preserveHelperProportions) {
                this._cacheHelperProportions();
            }

            //Post "activate" events to possible containers
            if (!noActivation) {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("activate", event, this._uiHash(this));
                }
            }

            //Prepare possible droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            this.dragging = true;

            this._addClass(this.helper, "ui-sortable-helper");

            // Execute the drag once - this causes the helper not to be visiblebefore getting its
            // correct position
            this._mouseDrag(event);
            return true;

        },

        _mouseDrag: function(event) {
            var i, item, itemElement, intersection,
                o = this.options,
                scrolled = false;

            //Compute the helpers position
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");

            if (!this.lastPositionAbs) {
                this.lastPositionAbs = this.positionAbs;
            }

            //Do scrolling
            if (this.options.scroll) {
                if (this.scrollParent[0] !== this.document[0] &&
                    this.scrollParent[0].tagName !== "HTML") {

                    if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) -
                        event.pageY < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop =
                            scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop =
                            scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                    }

                    if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) -
                        event.pageX < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled =
                            this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled =
                            this.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }

                } else {

                    if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
                    } else if (this.window.height() - (event.pageY - this.document.scrollTop()) <
                        o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
                    }

                    if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(
                            this.document.scrollLeft() - o.scrollSpeed
                        );
                    } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) <
                        o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(
                            this.document.scrollLeft() + o.scrollSpeed
                        );
                    }

                }

                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
            }

            //Regenerate the absolute position used for position checks
            this.positionAbs = this._convertPositionTo("absolute");

            //Set the helper position
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }

            //Rearrange
            for (i = this.items.length - 1; i >= 0; i--) {

                //Cache variables and intersection, continue if no intersection
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) {
                    continue;
                }

                // Only put the placeholder inside the current Container, skip all
                // items from other containers. This works because when moving
                // an item from one container to another the
                // currentContainer is switched before the placeholder is moved.
                //
                // Without this, moving items in "sub-sortables" can cause
                // the placeholder to jitter between the outer and inner container.
                if (item.instance !== this.currentContainer) {
                    continue;
                }

                // Cannot intersect with itself
                // no useless actions that have been done before
                // no action if the item moved is the parent of the item checked
                if (itemElement !== this.currentItem[0] &&
                    this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
                    !$.contains(this.placeholder[0], itemElement) &&
                    (this.options.type === "semi-dynamic" ?
                        !$.contains(this.element[0], itemElement) :
                        true
                    )
                ) {

                    this.direction = intersection === 1 ? "down" : "up";

                    if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                        this._rearrange(event, item);
                    } else {
                        break;
                    }

                    this._trigger("change", event, this._uiHash());
                    break;
                }
            }

            //Post events to containers
            this._contactContainers(event);

            //Interconnect with droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            //Call callbacks
            this._trigger("sort", event, this._uiHash());

            this.lastPositionAbs = this.positionAbs;
            return false;

        },

        _mouseStop: function(event, noPropagation) {

            if (!event) {
                return;
            }

            //If we are using droppables, inform the manager about the drop
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                $.ui.ddmanager.drop(this, event);
            }

            if (this.options.revert) {
                var that = this,
                    cur = this.placeholder.offset(),
                    axis = this.options.axis,
                    animation = {};

                if (!axis || axis === "x") {
                    animation.left = cur.left - this.offset.parent.left - this.margins.left +
                        (this.offsetParent[0] === this.document[0].body ?
                            0 :
                            this.offsetParent[0].scrollLeft
                        );
                }
                if (!axis || axis === "y") {
                    animation.top = cur.top - this.offset.parent.top - this.margins.top +
                        (this.offsetParent[0] === this.document[0].body ?
                            0 :
                            this.offsetParent[0].scrollTop
                        );
                }
                this.reverting = true;
                $(this.helper).animate(
                    animation,
                    parseInt(this.options.revert, 10) || 500,
                    function() {
                        that._clear(event);
                    }
                );
            } else {
                this._clear(event, noPropagation);
            }

            return false;

        },

        cancel: function() {

            if (this.dragging) {

                this._mouseUp(new $.Event("mouseup", {
                    target: null
                }));

                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS);
                    this._removeClass(this.currentItem, "ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }

                //Post deactivating events to containers
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", null, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }

            }

            if (this.placeholder) {

                //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
                // it unbinds ALL events from the original node!
                if (this.placeholder[0].parentNode) {
                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                }
                if (this.options.helper !== "original" && this.helper &&
                    this.helper[0].parentNode) {
                    this.helper.remove();
                }

                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                });

                if (this.domPosition.prev) {
                    $(this.domPosition.prev).after(this.currentItem);
                } else {
                    $(this.domPosition.parent).prepend(this.currentItem);
                }
            }

            return this;

        },

        serialize: function(o) {

            var items = this._getItemsAsjQuery(o && o.connected),
                str = [];
            o = o || {};

            $(items).each(function() {
                var res = ($(o.item || this).attr(o.attribute || "id") || "")
                    .match(o.expression || (/(.+)[\-=_](.+)/));
                if (res) {
                    str.push(
                        (o.key || res[1] + "[]") +
                        "=" + (o.key && o.expression ? res[1] : res[2]));
                }
            });

            if (!str.length && o.key) {
                str.push(o.key + "=");
            }

            return str.join("&");

        },

        toArray: function(o) {

            var items = this._getItemsAsjQuery(o && o.connected),
                ret = [];

            o = o || {};

            items.each(function() {
                ret.push($(o.item || this).attr(o.attribute || "id") || "");
            });
            return ret;

        },

        /* Be careful with the following core functions */
        _intersectsWith: function(item) {

            var x1 = this.positionAbs.left,
                x2 = x1 + this.helperProportions.width,
                y1 = this.positionAbs.top,
                y2 = y1 + this.helperProportions.height,
                l = item.left,
                r = l + item.width,
                t = item.top,
                b = t + item.height,
                dyClick = this.offset.click.top,
                dxClick = this.offset.click.left,
                isOverElementHeight = (this.options.axis === "x") || ((y1 + dyClick) > t &&
                    (y1 + dyClick) < b),
                isOverElementWidth = (this.options.axis === "y") || ((x1 + dxClick) > l &&
                    (x1 + dxClick) < r),
                isOverElement = isOverElementHeight && isOverElementWidth;

            if (this.options.tolerance === "pointer" ||
                this.options.forcePointerForContainers ||
                (this.options.tolerance !== "pointer" &&
                    this.helperProportions[this.floating ? "width" : "height"] >
                    item[this.floating ? "width" : "height"])
            ) {
                return isOverElement;
            } else {

                return (l < x1 + (this.helperProportions.width / 2) && // Right Half
                    x2 - (this.helperProportions.width / 2) < r && // Left Half
                    t < y1 + (this.helperProportions.height / 2) && // Bottom Half
                    y2 - (this.helperProportions.height / 2) < b); // Top Half

            }
        },

        _intersectsWithPointer: function(item) {
            var verticalDirection, horizontalDirection,
                isOverElementHeight = (this.options.axis === "x") ||
                this._isOverAxis(
                    this.positionAbs.top + this.offset.click.top, item.top, item.height),
                isOverElementWidth = (this.options.axis === "y") ||
                this._isOverAxis(
                    this.positionAbs.left + this.offset.click.left, item.left, item.width),
                isOverElement = isOverElementHeight && isOverElementWidth;

            if (!isOverElement) {
                return false;
            }

            verticalDirection = this._getDragVerticalDirection();
            horizontalDirection = this._getDragHorizontalDirection();

            return this.floating ?
                ((horizontalDirection === "right" || verticalDirection === "down") ? 2 : 1) :
                (verticalDirection && (verticalDirection === "down" ? 2 : 1));

        },

        _intersectsWithSides: function(item) {

            var isOverBottomHalf = this._isOverAxis(this.positionAbs.top +
                    this.offset.click.top, item.top + (item.height / 2), item.height),
                isOverRightHalf = this._isOverAxis(this.positionAbs.left +
                    this.offset.click.left, item.left + (item.width / 2), item.width),
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();

            if (this.floating && horizontalDirection) {
                return ((horizontalDirection === "right" && isOverRightHalf) ||
                    (horizontalDirection === "left" && !isOverRightHalf));
            } else {
                return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) ||
                    (verticalDirection === "up" && !isOverBottomHalf));
            }

        },

        _getDragVerticalDirection: function() {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up");
        },

        _getDragHorizontalDirection: function() {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left");
        },

        refresh: function(event) {
            this._refreshItems(event);
            this._setHandleClassName();
            this.refreshPositions();
            return this;
        },

        _connectWith: function() {
            var options = this.options;
            return options.connectWith.constructor === String ? [options.connectWith] :
                options.connectWith;
        },

        _getItemsAsjQuery: function(connected) {

            var i, j, cur, inst,
                items = [],
                queries = [],
                connectWith = this._connectWith();

            if (connectWith && connected) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ?
                                inst.options.items.call(inst.element) :
                                $(inst.options.items, inst.element)
                                .not(".ui-sortable-helper")
                                .not(".ui-sortable-placeholder"), inst
                            ]);
                        }
                    }
                }
            }

            queries.push([$.isFunction(this.options.items) ?
                this.options.items
                .call(this.element, null, {
                    options: this.options,
                    item: this.currentItem
                }) :
                $(this.options.items, this.element)
                .not(".ui-sortable-helper")
                .not(".ui-sortable-placeholder"), this
            ]);

            function addItems() {
                items.push(this);
            }
            for (i = queries.length - 1; i >= 0; i--) {
                queries[i][0].each(addItems);
            }

            return $(items);

        },

        _removeCurrentsFromItems: function() {

            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

            this.items = $.grep(this.items, function(item) {
                for (var j = 0; j < list.length; j++) {
                    if (list[j] === item.item[0]) {
                        return false;
                    }
                }
                return true;
            });

        },

        _refreshItems: function(event) {

            this.items = [];
            this.containers = [this];

            var i, j, cur, inst, targetData, _queries, item, queriesLength,
                items = this.items,
                queries = [
                    [$.isFunction(this.options.items) ?
                        this.options.items.call(this.element[0], event, {
                            item: this.currentItem
                        }) :
                        $(this.options.items, this.element), this
                    ]
                ],
                connectWith = this._connectWith();

            //Shouldn't be run the first time through due to massive slow-down
            if (connectWith && this.ready) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ?
                                inst.options.items
                                .call(inst.element[0], event, {
                                    item: this.currentItem
                                }) :
                                $(inst.options.items, inst.element), inst
                            ]);
                            this.containers.push(inst);
                        }
                    }
                }
            }

            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];

                for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                    item = $(_queries[j]);

                    // Data for target checking (mouse manager)
                    item.data(this.widgetName + "-item", targetData);

                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    });
                }
            }

        },

        refreshPositions: function(fast) {

            // Determine whether items are being displayed horizontally
            this.floating = this.items.length ?
                this.options.axis === "x" || this._isFloating(this.items[0].item) :
                false;

            //This has to be redone because due to the item being moved out/into the offsetParent,
            // the offsetParent's position will change
            if (this.offsetParent && this.helper) {
                this.offset.parent = this._getParentOffset();
            }

            var i, item, t, p;

            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];

                //We ignore calculating positions of all connected containers when we're not over them
                if (item.instance !== this.currentContainer && this.currentContainer &&
                    item.item[0] !== this.currentItem[0]) {
                    continue;
                }

                t = this.options.toleranceElement ?
                    $(this.options.toleranceElement, item.item) :
                    item.item;

                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }

                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }

            if (this.options.custom && this.options.custom.refreshContainers) {
                this.options.custom.refreshContainers.call(this);
            } else {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width =
                        this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height =
                        this.containers[i].element.outerHeight();
                }
            }

            return this;
        },

        _createPlaceholder: function(that) {
            that = that || this;
            var className,
                o = that.options;

            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                o.placeholder = {
                    element: function() {

                        var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                            element = $("<" + nodeName + ">", that.document[0]);

                        that._addClass(element, "ui-sortable-placeholder",
                                className || that.currentItem[0].className)
                            ._removeClass(element, "ui-sortable-helper");

                        if (nodeName === "tbody") {
                            that._createTrPlaceholder(
                                that.currentItem.find("tr").eq(0),
                                $("<tr>", that.document[0]).appendTo(element)
                            );
                        } else if (nodeName === "tr") {
                            that._createTrPlaceholder(that.currentItem, element);
                        } else if (nodeName === "img") {
                            element.attr("src", that.currentItem.attr("src"));
                        }

                        if (!className) {
                            element.css("visibility", "hidden");
                        }

                        return element;
                    },
                    update: function(container, p) {

                        // 1. If a className is set as 'placeholder option, we don't force sizes -
                        // the class is responsible for that
                        // 2. The option 'forcePlaceholderSize can be enabled to force it even if a
                        // class name is specified
                        if (className && !o.forcePlaceholderSize) {
                            return;
                        }

                        //If the element doesn't have a actual height by itself (without styles coming
                        // from a stylesheet), it receives the inline height from the dragged item
                        if (!p.height()) {
                            p.height(
                                that.currentItem.innerHeight() -
                                parseInt(that.currentItem.css("paddingTop") || 0, 10) -
                                parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                        }
                        if (!p.width()) {
                            p.width(
                                that.currentItem.innerWidth() -
                                parseInt(that.currentItem.css("paddingLeft") || 0, 10) -
                                parseInt(that.currentItem.css("paddingRight") || 0, 10));
                        }
                    }
                };
            }

            //Create the placeholder
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

            //Append it after the actual current item
            that.currentItem.after(that.placeholder);

            //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
            o.placeholder.update(that, that.placeholder);

        },

        _createTrPlaceholder: function(sourceTr, targetTr) {
            var that = this;

            sourceTr.children().each(function() {
                $("<td>&#160;</td>", that.document[0])
                    .attr("colspan", $(this).attr("colspan") || 1)
                    .appendTo(targetTr);
            });
        },

        _contactContainers: function(event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,
                floating, axis,
                innermostContainer = null,
                innermostIndex = null;

            // Get innermost container that intersects with item
            for (i = this.containers.length - 1; i >= 0; i--) {

                // Never consider a container that's located within the item itself
                if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                    continue;
                }

                if (this._intersectsWith(this.containers[i].containerCache)) {

                    // If we've already found a container and it's more "inner" than this, then continue
                    if (innermostContainer &&
                        $.contains(
                            this.containers[i].element[0],
                            innermostContainer.element[0])) {
                        continue;
                    }

                    innermostContainer = this.containers[i];
                    innermostIndex = i;

                } else {

                    // container doesn't intersect. trigger "out" event if necessary
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", event, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }

            }

            // If no intersecting containers found, return
            if (!innermostContainer) {
                return;
            }

            // Move the item into the container if it's not there already
            if (this.containers.length === 1) {
                if (!this.containers[innermostIndex].containerCache.over) {
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            } else {

                // When entering a new container, we will find the item with the least distance and
                // append our item near it
                dist = 10000;
                itemWithLeastDistance = null;
                floating = innermostContainer.floating || this._isFloating(this.currentItem);
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                axis = floating ? "pageX" : "pageY";

                for (j = this.items.length - 1; j >= 0; j--) {
                    if (!$.contains(
                            this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                        continue;
                    }
                    if (this.items[j].item[0] === this.currentItem[0]) {
                        continue;
                    }

                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
                        nearBottom = true;
                    }

                    if (Math.abs(event[axis] - cur) < dist) {
                        dist = Math.abs(event[axis] - cur);
                        itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }

                //Check if dropOnEmpty is enabled
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                    return;
                }

                if (this.currentContainer === this.containers[innermostIndex]) {
                    if (!this.currentContainer.containerCache.over) {
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash());
                        this.currentContainer.containerCache.over = 1;
                    }
                    return;
                }

                itemWithLeastDistance ?
                    this._rearrange(event, itemWithLeastDistance, null, true) :
                    this._rearrange(event, null, this.containers[innermostIndex].element, true);
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                this.currentContainer = this.containers[innermostIndex];

                //Update the placeholder
                this.options.placeholder.update(this.currentContainer, this.placeholder);

                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            }

        },

        _createHelper: function(event) {

            var o = this.options,
                helper = $.isFunction(o.helper) ?
                $(o.helper.apply(this.element[0], [event, this.currentItem])) :
                (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

            //Add the helper to the DOM if that didn't happen already
            if (!helper.parents("body").length) {
                $(o.appendTo !== "parent" ?
                    o.appendTo :
                    this.currentItem[0].parentNode)[0].appendChild(helper[0]);
            }

            if (helper[0] === this.currentItem[0]) {
                this._storedCSS = {
                    width: this.currentItem[0].style.width,
                    height: this.currentItem[0].style.height,
                    position: this.currentItem.css("position"),
                    top: this.currentItem.css("top"),
                    left: this.currentItem.css("left")
                };
            }

            if (!helper[0].style.width || o.forceHelperSize) {
                helper.width(this.currentItem.width());
            }
            if (!helper[0].style.height || o.forceHelperSize) {
                helper.height(this.currentItem.height());
            }

            return helper;

        },

        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },

        _getParentOffset: function() {

            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();

            // This is a special case where we need to modify a offset calculated on start, since the
            // following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the
            // next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
            // the document, which means that the scroll is included in the initial calculation of the
            // offset of the parent, and never recalculated upon drag
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] &&
                $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            // This needs to be actually done for all browsers, since pageX/pageY includes this
            // information with an ugly IE fix
            if (this.offsetParent[0] === this.document[0].body ||
                (this.offsetParent[0].tagName &&
                    this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                po = {
                    top: 0,
                    left: 0
                };
            }

            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };

        },

        _getRelativeOffset: function() {

            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) +
                        this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) +
                        this.scrollParent.scrollLeft()
                };
            } else {
                return {
                    top: 0,
                    left: 0
                };
            }

        },

        _cacheMargins: function() {
            this.margins = {
                left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0),
                top: (parseInt(this.currentItem.css("marginTop"), 10) || 0)
            };
        },

        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },

        _setContainment: function() {

            var ce, co, over,
                o = this.options;
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [
                    0 - this.offset.relative.left - this.offset.parent.left,
                    0 - this.offset.relative.top - this.offset.parent.top,
                    o.containment === "document" ?
                    this.document.width() :
                    this.window.width() - this.helperProportions.width - this.margins.left,
                    (o.containment === "document" ?
                        (this.document.height() || document.body.parentNode.scrollHeight) :
                        this.window.height() || this.document[0].body.parentNode.scrollHeight
                    ) - this.helperProportions.height - this.margins.top
                ];
            }

            if (!(/^(document|window|parent)$/).test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = ($(ce).css("overflow") !== "hidden");

                this.containment = [
                    co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) +
                    (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left,
                    co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) +
                    (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top,
                    co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) -
                    (parseInt($(ce).css("borderLeftWidth"), 10) || 0) -
                    (parseInt($(ce).css("paddingRight"), 10) || 0) -
                    this.helperProportions.width - this.margins.left,
                    co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) -
                    (parseInt($(ce).css("borderTopWidth"), 10) || 0) -
                    (parseInt($(ce).css("paddingBottom"), 10) || 0) -
                    this.helperProportions.height - this.margins.top
                ];
            }

        },

        _convertPositionTo: function(d, pos) {

            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1,
                scroll = this.cssPosition === "absolute" &&
                !(this.scrollParent[0] !== this.document[0] &&
                    $.contains(this.scrollParent[0], this.offsetParent[0])) ?
                this.offsetParent :
                this.scrollParent,
                scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            return {
                top: (

                    // The absolute mouse position
                    pos.top +

                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top * mod +

                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top * mod -
                    ((this.cssPosition === "fixed" ?
                        -this.scrollParent.scrollTop() :
                        (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)
                ),
                left: (

                    // The absolute mouse position
                    pos.left +

                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left * mod +

                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left * mod -
                    ((this.cssPosition === "fixed" ?
                        -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :
                        scroll.scrollLeft()) * mod)
                )
            };

        },

        _generatePosition: function(event) {

            var top, left,
                o = this.options,
                pageX = event.pageX,
                pageY = event.pageY,
                scroll = this.cssPosition === "absolute" &&
                !(this.scrollParent[0] !== this.document[0] &&
                    $.contains(this.scrollParent[0], this.offsetParent[0])) ?
                this.offsetParent :
                this.scrollParent,
                scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            // This is another very weird special case that only happens for relative elements:
            // 1. If the css position is relative
            // 2. and the scroll parent is the document or similar to the offset parent
            // we have to refresh the relative offset during the scroll so there are no jumps
            if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] &&
                    this.scrollParent[0] !== this.offsetParent[0])) {
                this.offset.relative = this._getRelativeOffset();
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            if (this.originalPosition) { //If we are not dragging yet, we won't check for options

                if (this.containment) {
                    if (event.pageX - this.offset.click.left < this.containment[0]) {
                        pageX = this.containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < this.containment[1]) {
                        pageY = this.containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > this.containment[2]) {
                        pageX = this.containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > this.containment[3]) {
                        pageY = this.containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    top = this.originalPageY + Math.round((pageY - this.originalPageY) /
                        o.grid[1]) * o.grid[1];
                    pageY = this.containment ?
                        ((top - this.offset.click.top >= this.containment[1] &&
                                top - this.offset.click.top <= this.containment[3]) ?
                            top :
                            ((top - this.offset.click.top >= this.containment[1]) ?
                                top - o.grid[1] : top + o.grid[1])) :
                        top;

                    left = this.originalPageX + Math.round((pageX - this.originalPageX) /
                        o.grid[0]) * o.grid[0];
                    pageX = this.containment ?
                        ((left - this.offset.click.left >= this.containment[0] &&
                                left - this.offset.click.left <= this.containment[2]) ?
                            left :
                            ((left - this.offset.click.left >= this.containment[0]) ?
                                left - o.grid[0] : left + o.grid[0])) :
                        left;
                }

            }

            return {
                top: (

                    // The absolute mouse position
                    pageY -

                    // Click offset (relative to the element)
                    this.offset.click.top -

                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top -

                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top +
                    ((this.cssPosition === "fixed" ?
                        -this.scrollParent.scrollTop() :
                        (scrollIsRootNode ? 0 : scroll.scrollTop())))
                ),
                left: (

                    // The absolute mouse position
                    pageX -

                    // Click offset (relative to the element)
                    this.offset.click.left -

                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left -

                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left +
                    ((this.cssPosition === "fixed" ?
                        -this.scrollParent.scrollLeft() :
                        scrollIsRootNode ? 0 : scroll.scrollLeft()))
                )
            };

        },

        _rearrange: function(event, i, a, hardRefresh) {

            a ? a[0].appendChild(this.placeholder[0]) :
                i.item[0].parentNode.insertBefore(this.placeholder[0],
                    (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

            //Various things done here to improve the performance:
            // 1. we create a setTimeout, that calls refreshPositions
            // 2. on the instance, we have a counter variable, that get's higher after every append
            // 3. on the local scope, we copy the counter variable, and check in the timeout,
            // if it's still the same
            // 4. this lets only the last addition to the timeout stack through
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;

            this._delay(function() {
                if (counter === this.counter) {

                    //Precompute after each DOM insertion, NOT on mousemove
                    this.refreshPositions(!hardRefresh);
                }
            });

        },

        _clear: function(event, noPropagation) {

            this.reverting = false;

            // We delay all events that have to be triggered to after the point where the placeholder
            // has been removed and everything else normalized again
            var i,
                delayedTriggers = [];

            // We first have to update the dom position of the actual currentItem
            // Note: don't do it if the current item is already removed (by a user), or it gets
            // reappended (see #4088)
            if (!this._noFinalSort && this.currentItem.parent().length) {
                this.placeholder.before(this.currentItem);
            }
            this._noFinalSort = null;

            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) {
                    if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                        this._storedCSS[i] = "";
                    }
                }
                this.currentItem.css(this._storedCSS);
                this._removeClass(this.currentItem, "ui-sortable-helper");
            } else {
                this.currentItem.show();
            }

            if (this.fromOutside && !noPropagation) {
                delayedTriggers.push(function(event) {
                    this._trigger("receive", event, this._uiHash(this.fromOutside));
                });
            }
            if ((this.fromOutside ||
                    this.domPosition.prev !==
                    this.currentItem.prev().not(".ui-sortable-helper")[0] ||
                    this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {

                // Trigger update callback if the DOM position has changed
                delayedTriggers.push(function(event) {
                    this._trigger("update", event, this._uiHash());
                });
            }

            // Check if the items Container has Changed and trigger appropriate
            // events.
            if (this !== this.currentContainer) {
                if (!noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("remove", event, this._uiHash());
                    });
                    delayedTriggers.push((function(c) {
                        return function(event) {
                            c._trigger("receive", event, this._uiHash(this));
                        };
                    }).call(this, this.currentContainer));
                    delayedTriggers.push((function(c) {
                        return function(event) {
                            c._trigger("update", event, this._uiHash(this));
                        };
                    }).call(this, this.currentContainer));
                }
            }

            //Post events to containers
            function delayEvent(type, instance, container) {
                return function(event) {
                    container._trigger(type, event, instance._uiHash(instance));
                };
            }
            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) {
                    delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
                }
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push(delayEvent("out", this, this.containers[i]));
                    this.containers[i].containerCache.over = 0;
                }
            }

            //Do what was originally in plugins
            if (this.storedCursor) {
                this.document.find("body").css("cursor", this.storedCursor);
                this.storedStylesheet.remove();
            }
            if (this._storedOpacity) {
                this.helper.css("opacity", this._storedOpacity);
            }
            if (this._storedZIndex) {
                this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
            }

            this.dragging = false;

            if (!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
            }

            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
            // it unbinds ALL events from the original node!
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

            if (!this.cancelHelperRemoval) {
                if (this.helper[0] !== this.currentItem[0]) {
                    this.helper.remove();
                }
                this.helper = null;
            }

            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) {

                    // Trigger all delayed events
                    delayedTriggers[i].call(this, event);
                }
                this._trigger("stop", event, this._uiHash());
            }

            this.fromOutside = false;
            return !this.cancelHelperRemoval;

        },

        _trigger: function() {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                this.cancel();
            }
        },

        _uiHash: function(_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }

    });


    /*!
     * jQuery UI Spinner 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Spinner
    //>>group: Widgets
    //>>description: Displays buttons to easily input numbers via the keyboard or mouse.
    //>>docs: http://api.jqueryui.com/spinner/
    //>>demos: http://jqueryui.com/spinner/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/spinner.css
    //>>css.theme: ../../themes/base/theme.css



    function spinnerModifer(fn) {
        return function() {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) {
                this._trigger("change");
            }
        };
    }

    $.widget("ui.spinner", {
        version: "1.12.1",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            classes: {
                "ui-spinner": "ui-corner-all",
                "ui-spinner-down": "ui-corner-br",
                "ui-spinner-up": "ui-corner-tr"
            },
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,

            change: null,
            spin: null,
            start: null,
            stop: null
        },

        _create: function() {

            // handle string values that need to be parsed
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);

            // Only format if there is a value, prevents the field from being marked
            // as invalid in Firefox, see #9573.
            if (this.value() !== "") {

                // Format the value, but don't constrain.
                this._value(this.element.val(), true);
            }

            this._draw();
            this._on(this._events);
            this._refresh();

            // Turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },

        _getCreateOptions: function() {
            var options = this._super();
            var element = this.element;

            $.each(["min", "max", "step"], function(i, option) {
                var value = element.attr(option);
                if (value != null && value.length) {
                    options[option] = value;
                }
            });

            return options;
        },

        _events: {
            keydown: function(event) {
                if (this._start(event) && this._keydown(event)) {
                    event.preventDefault();
                }
            },
            keyup: "_stop",
            focus: function() {
                this.previous = this.element.val();
            },
            blur: function(event) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return;
                }

                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) {
                    this._trigger("change", event);
                }
            },
            mousewheel: function(event, delta) {
                if (!delta) {
                    return;
                }
                if (!this.spinning && !this._start(event)) {
                    return false;
                }

                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function() {
                    if (this.spinning) {
                        this._stop(event);
                    }
                }, 100);
                event.preventDefault();
            },
            "mousedown .ui-spinner-button": function(event) {
                var previous;

                // We never want the buttons to have focus; whenever the user is
                // interacting with the spinner, the focus should be on the input.
                // If the input is focused then this.previous is properly set from
                // when the input first received focus. If the input is not focused
                // then we need to set this.previous based on the value before spinning.
                previous = this.element[0] === $.ui.safeActiveElement(this.document[0]) ?
                    this.previous : this.element.val();

                function checkFocus() {
                    var isActive = this.element[0] === $.ui.safeActiveElement(this.document[0]);
                    if (!isActive) {
                        this.element.trigger("focus");
                        this.previous = previous;

                        // support: IE
                        // IE sets focus asynchronously, so we need to check if focus
                        // moved off of the input because the user clicked on the button.
                        this._delay(function() {
                            this.previous = previous;
                        });
                    }
                }

                // Ensure focus is on (or stays on) the text field
                event.preventDefault();
                checkFocus.call(this);

                // Support: IE
                // IE doesn't prevent moving focus even with event.preventDefault()
                // so we set a flag to know when we should ignore the blur event
                // and check (again) if focus moved off of the input.
                this.cancelBlur = true;
                this._delay(function() {
                    delete this.cancelBlur;
                    checkFocus.call(this);
                });

                if (this._start(event) === false) {
                    return;
                }

                this._repeat(null, $(event.currentTarget)
                    .hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function(event) {

                // button will add ui-state-active if mouse was down while mouseleave and kept down
                if (!$(event.currentTarget).hasClass("ui-state-active")) {
                    return;
                }

                if (this._start(event) === false) {
                    return false;
                }
                this._repeat(null, $(event.currentTarget)
                    .hasClass("ui-spinner-up") ? 1 : -1, event);
            },

            // TODO: do we really want to consider this a stop?
            // shouldn't we just stop the repeater and wait until mouseup before
            // we trigger the stop event?
            "mouseleave .ui-spinner-button": "_stop"
        },

        // Support mobile enhanced option and make backcompat more sane
        _enhance: function() {
            this.uiSpinner = this.element
                .attr("autocomplete", "off")
                .wrap("<span>")
                .parent()

                // Add buttons
                .append(
                    "<a></a><a></a>"
                );
        },

        _draw: function() {
            this._enhance();

            this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content");
            this._addClass("ui-spinner-input");

            this.element.attr("role", "spinbutton");

            // Button bindings
            this.buttons = this.uiSpinner.children("a")
                .attr("tabIndex", -1)
                .attr("aria-hidden", true)
                .button({
                    classes: {
                        "ui-button": ""
                    }
                });

            // TODO: Right now button does not support classes this is already updated in button PR
            this._removeClass(this.buttons, "ui-corner-all");

            this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up");
            this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down");
            this.buttons.first().button({
                "icon": this.options.icons.up,
                "showLabel": false
            });
            this.buttons.last().button({
                "icon": this.options.icons.down,
                "showLabel": false
            });

            // IE 6 doesn't understand height: 50% for the buttons
            // unless the wrapper has an explicit height
            if (this.buttons.height() > Math.ceil(this.uiSpinner.height() * 0.5) &&
                this.uiSpinner.height() > 0) {
                this.uiSpinner.height(this.uiSpinner.height());
            }
        },

        _keydown: function(event) {
            var options = this.options,
                keyCode = $.ui.keyCode;

            switch (event.keyCode) {
                case keyCode.UP:
                    this._repeat(null, 1, event);
                    return true;
                case keyCode.DOWN:
                    this._repeat(null, -1, event);
                    return true;
                case keyCode.PAGE_UP:
                    this._repeat(null, options.page, event);
                    return true;
                case keyCode.PAGE_DOWN:
                    this._repeat(null, -options.page, event);
                    return true;
            }

            return false;
        },

        _start: function(event) {
            if (!this.spinning && this._trigger("start", event) === false) {
                return false;
            }

            if (!this.counter) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },

        _repeat: function(i, steps, event) {
            i = i || 500;

            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                this._repeat(40, steps, event);
            }, i);

            this._spin(steps * this.options.step, event);
        },

        _spin: function(step, event) {
            var value = this.value() || 0;

            if (!this.counter) {
                this.counter = 1;
            }

            value = this._adjustValue(value + step * this._increment(this.counter));

            if (!this.spinning || this._trigger("spin", event, {
                    value: value
                }) !== false) {
                this._value(value);
                this.counter++;
            }
        },

        _increment: function(i) {
            var incremental = this.options.incremental;

            if (incremental) {
                return $.isFunction(incremental) ?
                    incremental(i) :
                    Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
            }

            return 1;
        },

        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },

        _precisionOf: function(num) {
            var str = num.toString(),
                decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },

        _adjustValue: function(value) {
            var base, aboveMin,
                options = this.options;

            // Make sure we're at a valid step
            // - find out where we are relative to the base (min or 0)
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;

            // - round to the nearest step
            aboveMin = Math.round(aboveMin / options.step) * options.step;

            // - rounding is based on 0, so adjust back to our base
            value = base + aboveMin;

            // Fix precision from bad JS floating point math
            value = parseFloat(value.toFixed(this._precision()));

            // Clamp the value
            if (options.max !== null && value > options.max) {
                return options.max;
            }
            if (options.min !== null && value < options.min) {
                return options.min;
            }

            return value;
        },

        _stop: function(event) {
            if (!this.spinning) {
                return;
            }

            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event);
        },

        _setOption: function(key, value) {
            var prevValue, first, last;

            if (key === "culture" || key === "numberFormat") {
                prevValue = this._parse(this.element.val());
                this.options[key] = value;
                this.element.val(this._format(prevValue));
                return;
            }

            if (key === "max" || key === "min" || key === "step") {
                if (typeof value === "string") {
                    value = this._parse(value);
                }
            }
            if (key === "icons") {
                first = this.buttons.first().find(".ui-icon");
                this._removeClass(first, null, this.options.icons.up);
                this._addClass(first, null, value.up);
                last = this.buttons.last().find(".ui-icon");
                this._removeClass(last, null, this.options.icons.down);
                this._addClass(last, null, value.down);
            }

            this._super(key, value);
        },

        _setOptionDisabled: function(value) {
            this._super(value);

            this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!value);
            this.element.prop("disabled", !!value);
            this.buttons.button(value ? "disable" : "enable");
        },

        _setOptions: spinnerModifer(function(options) {
            this._super(options);
        }),

        _parse: function(val) {
            if (typeof val === "string" && val !== "") {
                val = window.Globalize && this.options.numberFormat ?
                    Globalize.parseFloat(val, 10, this.options.culture) : +val;
            }
            return val === "" || isNaN(val) ? null : val;
        },

        _format: function(value) {
            if (value === "") {
                return "";
            }
            return window.Globalize && this.options.numberFormat ?
                Globalize.format(value, this.options.numberFormat, this.options.culture) :
                value;
        },

        _refresh: function() {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,

                // TODO: what should we do with values that can't be parsed?
                "aria-valuenow": this._parse(this.element.val())
            });
        },

        isValid: function() {
            var value = this.value();

            // Null is invalid
            if (value === null) {
                return false;
            }

            // If value gets adjusted, it's invalid
            return value === this._adjustValue(value);
        },

        // Update the value without triggering change
        _value: function(value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) {
                        parsed = this._adjustValue(parsed);
                    }
                    value = this._format(parsed);
                }
            }
            this.element.val(value);
            this._refresh();
        },

        _destroy: function() {
            this.element
                .prop("disabled", false)
                .removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow");

            this.uiSpinner.replaceWith(this.element);
        },

        stepUp: spinnerModifer(function(steps) {
            this._stepUp(steps);
        }),
        _stepUp: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop();
            }
        },

        stepDown: spinnerModifer(function(steps) {
            this._stepDown(steps);
        }),
        _stepDown: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop();
            }
        },

        pageUp: spinnerModifer(function(pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),

        pageDown: spinnerModifer(function(pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),

        value: function(newVal) {
            if (!arguments.length) {
                return this._parse(this.element.val());
            }
            spinnerModifer(this._value).call(this, newVal);
        },

        widget: function() {
            return this.uiSpinner;
        }
    });

    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {

        // Backcompat for spinner html extension points
        $.widget("ui.spinner", $.ui.spinner, {
            _enhance: function() {
                this.uiSpinner = this.element
                    .attr("autocomplete", "off")
                    .wrap(this._uiSpinnerHtml())
                    .parent()

                    // Add buttons
                    .append(this._buttonHtml());
            },
            _uiSpinnerHtml: function() {
                return "<span>";
            },

            _buttonHtml: function() {
                return "<a></a><a></a>";
            }
        });
    }

    var widgetsSpinner = $.ui.spinner;


    /*!
     * jQuery UI Tabs 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Tabs
    //>>group: Widgets
    //>>description: Transforms a set of container elements into a tab structure.
    //>>docs: http://api.jqueryui.com/tabs/
    //>>demos: http://jqueryui.com/tabs/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/tabs.css
    //>>css.theme: ../../themes/base/theme.css



    $.widget("ui.tabs", {
        version: "1.12.1",
        delay: 300,
        options: {
            active: null,
            classes: {
                "ui-tabs": "ui-corner-all",
                "ui-tabs-nav": "ui-corner-all",
                "ui-tabs-panel": "ui-corner-bottom",
                "ui-tabs-tab": "ui-corner-top"
            },
            collapsible: false,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,

            // Callbacks
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },

        _isLocal: (function() {
            var rhash = /#.*$/;

            return function(anchor) {
                var anchorUrl, locationUrl;

                anchorUrl = anchor.href.replace(rhash, "");
                locationUrl = location.href.replace(rhash, "");

                // Decoding may throw an error if the URL isn't UTF-8 (#9518)
                try {
                    anchorUrl = decodeURIComponent(anchorUrl);
                } catch (error) {}
                try {
                    locationUrl = decodeURIComponent(locationUrl);
                } catch (error) {}

                return anchor.hash.length > 1 && anchorUrl === locationUrl;
            };
        })(),

        _create: function() {
            var that = this,
                options = this.options;

            this.running = false;

            this._addClass("ui-tabs", "ui-widget ui-widget-content");
            this._toggleClass("ui-tabs-collapsible", null, options.collapsible);

            this._processTabs();
            options.active = this._initialActive();

            // Take disabling tabs via class attribute from HTML
            // into account and update option properly.
            if ($.isArray(options.disabled)) {
                options.disabled = $.unique(options.disabled.concat(
                    $.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                        return that.tabs.index(li);
                    })
                )).sort();
            }

            // Check for length avoids error when initializing empty list
            if (this.options.active !== false && this.anchors.length) {
                this.active = this._findActive(options.active);
            } else {
                this.active = $();
            }

            this._refresh();

            if (this.active.length) {
                this.load(options.active);
            }
        },

        _initialActive: function() {
            var active = this.options.active,
                collapsible = this.options.collapsible,
                locationHash = location.hash.substring(1);

            if (active === null) {

                // check the fragment identifier in the URL
                if (locationHash) {
                    this.tabs.each(function(i, tab) {
                        if ($(tab).attr("aria-controls") === locationHash) {
                            active = i;
                            return false;
                        }
                    });
                }

                // Check for a tab marked active via a class
                if (active === null) {
                    active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                }

                // No active tab, set to false
                if (active === null || active === -1) {
                    active = this.tabs.length ? 0 : false;
                }
            }

            // Handle numbers: negative, out of range
            if (active !== false) {
                active = this.tabs.index(this.tabs.eq(active));
                if (active === -1) {
                    active = collapsible ? false : 0;
                }
            }

            // Don't allow collapsible: false and active: false
            if (!collapsible && active === false && this.anchors.length) {
                active = 0;
            }

            return active;
        },

        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: !this.active.length ? $() : this._getPanelForTab(this.active)
            };
        },

        _tabKeydown: function(event) {
            var focusedTab = $($.ui.safeActiveElement(this.document[0])).closest("li"),
                selectedIndex = this.tabs.index(focusedTab),
                goingForward = true;

            if (this._handlePageNav(event)) {
                return;
            }

            switch (event.keyCode) {
                case $.ui.keyCode.RIGHT:
                case $.ui.keyCode.DOWN:
                    selectedIndex++;
                    break;
                case $.ui.keyCode.UP:
                case $.ui.keyCode.LEFT:
                    goingForward = false;
                    selectedIndex--;
                    break;
                case $.ui.keyCode.END:
                    selectedIndex = this.anchors.length - 1;
                    break;
                case $.ui.keyCode.HOME:
                    selectedIndex = 0;
                    break;
                case $.ui.keyCode.SPACE:

                    // Activate only, no collapsing
                    event.preventDefault();
                    clearTimeout(this.activating);
                    this._activate(selectedIndex);
                    return;
                case $.ui.keyCode.ENTER:

                    // Toggle (cancel delayed activation, allow collapsing)
                    event.preventDefault();
                    clearTimeout(this.activating);

                    // Determine if we should collapse or activate
                    this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                    return;
                default:
                    return;
            }

            // Focus the appropriate tab, based on which key was pressed
            event.preventDefault();
            clearTimeout(this.activating);
            selectedIndex = this._focusNextTab(selectedIndex, goingForward);

            // Navigating with control/command key will prevent automatic activation
            if (!event.ctrlKey && !event.metaKey) {

                // Update aria-selected immediately so that AT think the tab is already selected.
                // Otherwise AT may confuse the user by stating that they need to activate the tab,
                // but the tab will already be activated by the time the announcement finishes.
                focusedTab.attr("aria-selected", "false");
                this.tabs.eq(selectedIndex).attr("aria-selected", "true");

                this.activating = this._delay(function() {
                    this.option("active", selectedIndex);
                }, this.delay);
            }
        },

        _panelKeydown: function(event) {
            if (this._handlePageNav(event)) {
                return;
            }

            // Ctrl+up moves focus to the current tab
            if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                event.preventDefault();
                this.active.trigger("focus");
            }
        },

        // Alt+page up/down moves focus to the previous/next tab (and activates)
        _handlePageNav: function(event) {
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                this._activate(this._focusNextTab(this.options.active - 1, false));
                return true;
            }
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                this._activate(this._focusNextTab(this.options.active + 1, true));
                return true;
            }
        },

        _findNextTab: function(index, goingForward) {
            var lastTabIndex = this.tabs.length - 1;

            function constrain() {
                if (index > lastTabIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastTabIndex;
                }
                return index;
            }

            while ($.inArray(constrain(), this.options.disabled) !== -1) {
                index = goingForward ? index + 1 : index - 1;
            }

            return index;
        },

        _focusNextTab: function(index, goingForward) {
            index = this._findNextTab(index, goingForward);
            this.tabs.eq(index).trigger("focus");
            return index;
        },

        _setOption: function(key, value) {
            if (key === "active") {

                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            this._super(key, value);

            if (key === "collapsible") {
                this._toggleClass("ui-tabs-collapsible", null, value);

                // Setting collapsible: false while collapsed; open first panel
                if (!value && this.options.active === false) {
                    this._activate(0);
                }
            }

            if (key === "event") {
                this._setupEvents(value);
            }

            if (key === "heightStyle") {
                this._setupHeightStyle(value);
            }
        },

        _sanitizeSelector: function(hash) {
            return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },

        refresh: function() {
            var options = this.options,
                lis = this.tablist.children(":has(a[href])");

            // Get disabled tabs from class attribute from HTML
            // this will get converted to a boolean if needed in _refresh()
            options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                return lis.index(tab);
            });

            this._processTabs();

            // Was collapsed or no tabs
            if (options.active === false || !this.anchors.length) {
                options.active = false;
                this.active = $();

                // was active, but active tab is gone
            } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {

                // all remaining tabs are disabled
                if (this.tabs.length === options.disabled.length) {
                    options.active = false;
                    this.active = $();

                    // activate previous tab
                } else {
                    this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                }

                // was active, active tab still exists
            } else {

                // make sure active index is correct
                options.active = this.tabs.index(this.active);
            }

            this._refresh();
        },

        _refresh: function() {
            this._setOptionDisabled(this.options.disabled);
            this._setupEvents(this.options.event);
            this._setupHeightStyle(this.options.heightStyle);

            this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            });
            this.panels.not(this._getPanelForTab(this.active))
                .hide()
                .attr({
                    "aria-hidden": "true"
                });

            // Make sure one tab is in the tab order
            if (!this.active.length) {
                this.tabs.eq(0).attr("tabIndex", 0);
            } else {
                this.active
                    .attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    });
                this._addClass(this.active, "ui-tabs-active", "ui-state-active");
                this._getPanelForTab(this.active)
                    .show()
                    .attr({
                        "aria-hidden": "false"
                    });
            }
        },

        _processTabs: function() {
            var that = this,
                prevTabs = this.tabs,
                prevAnchors = this.anchors,
                prevPanels = this.panels;

            this.tablist = this._getList().attr("role", "tablist");
            this._addClass(this.tablist, "ui-tabs-nav",
                "ui-helper-reset ui-helper-clearfix ui-widget-header");

            // Prevent users from focusing disabled tabs via click
            this.tablist
                .on("mousedown" + this.eventNamespace, "> li", function(event) {
                    if ($(this).is(".ui-state-disabled")) {
                        event.preventDefault();
                    }
                })

                // Support: IE <9
                // Preventing the default action in mousedown doesn't prevent IE
                // from focusing the element, so if the anchor gets focused, blur.
                // We don't have to worry about focusing the previously focused
                // element since clicking on a non-focusable element should focus
                // the body anyway.
                .on("focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
                    if ($(this).closest("li").is(".ui-state-disabled")) {
                        this.blur();
                    }
                });

            this.tabs = this.tablist.find("> li:has(a[href])")
                .attr({
                    role: "tab",
                    tabIndex: -1
                });
            this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default");

            this.anchors = this.tabs.map(function() {
                    return $("a", this)[0];
                })
                .attr({
                    role: "presentation",
                    tabIndex: -1
                });
            this._addClass(this.anchors, "ui-tabs-anchor");

            this.panels = $();

            this.anchors.each(function(i, anchor) {
                var selector, panel, panelId,
                    anchorId = $(anchor).uniqueId().attr("id"),
                    tab = $(anchor).closest("li"),
                    originalAriaControls = tab.attr("aria-controls");

                // Inline tab
                if (that._isLocal(anchor)) {
                    selector = anchor.hash;
                    panelId = selector.substring(1);
                    panel = that.element.find(that._sanitizeSelector(selector));

                    // remote tab
                } else {

                    // If the tab doesn't already have aria-controls,
                    // generate an id by using a throw-away element
                    panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id;
                    selector = "#" + panelId;
                    panel = that.element.find(selector);
                    if (!panel.length) {
                        panel = that._createPanel(panelId);
                        panel.insertAfter(that.panels[i - 1] || that.tablist);
                    }
                    panel.attr("aria-live", "polite");
                }

                if (panel.length) {
                    that.panels = that.panels.add(panel);
                }
                if (originalAriaControls) {
                    tab.data("ui-tabs-aria-controls", originalAriaControls);
                }
                tab.attr({
                    "aria-controls": panelId,
                    "aria-labelledby": anchorId
                });
                panel.attr("aria-labelledby", anchorId);
            });

            this.panels.attr("role", "tabpanel");
            this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content");

            // Avoid memory leaks (#10056)
            if (prevTabs) {
                this._off(prevTabs.not(this.tabs));
                this._off(prevAnchors.not(this.anchors));
                this._off(prevPanels.not(this.panels));
            }
        },

        // Allow overriding how to find the list for rare usage scenarios (#7715)
        _getList: function() {
            return this.tablist || this.element.find("ol, ul").eq(0);
        },

        _createPanel: function(id) {
            return $("<div>")
                .attr("id", id)
                .data("ui-tabs-destroy", true);
        },

        _setOptionDisabled: function(disabled) {
            var currentItem, li, i;

            if ($.isArray(disabled)) {
                if (!disabled.length) {
                    disabled = false;
                } else if (disabled.length === this.anchors.length) {
                    disabled = true;
                }
            }

            // Disable tabs
            for (i = 0;
                (li = this.tabs[i]); i++) {
                currentItem = $(li);
                if (disabled === true || $.inArray(i, disabled) !== -1) {
                    currentItem.attr("aria-disabled", "true");
                    this._addClass(currentItem, null, "ui-state-disabled");
                } else {
                    currentItem.removeAttr("aria-disabled");
                    this._removeClass(currentItem, null, "ui-state-disabled");
                }
            }

            this.options.disabled = disabled;

            this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null,
                disabled === true);
        },

        _setupEvents: function(event) {
            var events = {};
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.anchors.add(this.tabs).add(this.panels));

            // Always prevent the default action, even when disabled
            this._on(true, this.anchors, {
                click: function(event) {
                    event.preventDefault();
                }
            });
            this._on(this.anchors, events);
            this._on(this.tabs, {
                keydown: "_tabKeydown"
            });
            this._on(this.panels, {
                keydown: "_panelKeydown"
            });

            this._focusable(this.tabs);
            this._hoverable(this.tabs);
        },

        _setupHeightStyle: function(heightStyle) {
            var maxHeight,
                parent = this.element.parent();

            if (heightStyle === "fill") {
                maxHeight = parent.height();
                maxHeight -= this.element.outerHeight() - this.element.height();

                this.element.siblings(":visible").each(function() {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });

                this.element.children().not(this.panels).each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.panels.each(function() {
                        $(this).height(Math.max(0, maxHeight -
                            $(this).innerHeight() + $(this).height()));
                    })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.panels.each(function() {
                    maxHeight = Math.max(maxHeight, $(this).height("").height());
                }).height(maxHeight);
            }
        },

        _eventHandler: function(event) {
            var options = this.options,
                active = this.active,
                anchor = $(event.currentTarget),
                tab = anchor.closest("li"),
                clickedIsActive = tab[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : this._getPanelForTab(tab),
                toHide = !active.length ? $() : this._getPanelForTab(active),
                eventData = {
                    oldTab: active,
                    oldPanel: toHide,
                    newTab: collapsing ? $() : tab,
                    newPanel: toShow
                };

            event.preventDefault();

            if (tab.hasClass("ui-state-disabled") ||

                // tab is already loading
                tab.hasClass("ui-tabs-loading") ||

                // can't switch durning an animation
                this.running ||

                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||

                // allow canceling activation
                (this._trigger("beforeActivate", event, eventData) === false)) {
                return;
            }

            options.active = collapsing ? false : this.tabs.index(tab);

            this.active = clickedIsActive ? $() : tab;
            if (this.xhr) {
                this.xhr.abort();
            }

            if (!toHide.length && !toShow.length) {
                $.error("jQuery UI Tabs: Mismatching fragment identifier.");
            }

            if (toShow.length) {
                this.load(this.tabs.index(tab), event);
            }
            this._toggle(event, eventData);
        },

        // Handles show/hide for selecting tabs
        _toggle: function(event, eventData) {
            var that = this,
                toShow = eventData.newPanel,
                toHide = eventData.oldPanel;

            this.running = true;

            function complete() {
                that.running = false;
                that._trigger("activate", event, eventData);
            }

            function show() {
                that._addClass(eventData.newTab.closest("li"), "ui-tabs-active", "ui-state-active");

                if (toShow.length && that.options.show) {
                    that._show(toShow, that.options.show, complete);
                } else {
                    toShow.show();
                    complete();
                }
            }

            // Start out by hiding, then showing, then completing
            if (toHide.length && this.options.hide) {
                this._hide(toHide, this.options.hide, function() {
                    that._removeClass(eventData.oldTab.closest("li"),
                        "ui-tabs-active", "ui-state-active");
                    show();
                });
            } else {
                this._removeClass(eventData.oldTab.closest("li"),
                    "ui-tabs-active", "ui-state-active");
                toHide.hide();
                show();
            }

            toHide.attr("aria-hidden", "true");
            eventData.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            });

            // If we're switching tabs, remove the old tab from the tab order.
            // If we're opening from collapsed state, remove the previous tab from the tab order.
            // If we're collapsing, then keep the collapsing tab in the tab order.
            if (toShow.length && toHide.length) {
                eventData.oldTab.attr("tabIndex", -1);
            } else if (toShow.length) {
                this.tabs.filter(function() {
                        return $(this).attr("tabIndex") === 0;
                    })
                    .attr("tabIndex", -1);
            }

            toShow.attr("aria-hidden", "false");
            eventData.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },

        _activate: function(index) {
            var anchor,
                active = this._findActive(index);

            // Trying to activate the already active panel
            if (active[0] === this.active[0]) {
                return;
            }

            // Trying to collapse, simulate a click on the current active header
            if (!active.length) {
                active = this.active;
            }

            anchor = active.find(".ui-tabs-anchor")[0];
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            });
        },

        _findActive: function(index) {
            return index === false ? $() : this.tabs.eq(index);
        },

        _getIndex: function(index) {

            // meta-function to give users option to provide a href string instead of a numerical index.
            if (typeof index === "string") {
                index = this.anchors.index(this.anchors.filter("[href$='" +
                    $.ui.escapeSelector(index) + "']"));
            }

            return index;
        },

        _destroy: function() {
            if (this.xhr) {
                this.xhr.abort();
            }

            this.tablist
                .removeAttr("role")
                .off(this.eventNamespace);

            this.anchors
                .removeAttr("role tabIndex")
                .removeUniqueId();

            this.tabs.add(this.panels).each(function() {
                if ($.data(this, "ui-tabs-destroy")) {
                    $(this).remove();
                } else {
                    $(this).removeAttr("role tabIndex " +
                        "aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded");
                }
            });

            this.tabs.each(function() {
                var li = $(this),
                    prev = li.data("ui-tabs-aria-controls");
                if (prev) {
                    li
                        .attr("aria-controls", prev)
                        .removeData("ui-tabs-aria-controls");
                } else {
                    li.removeAttr("aria-controls");
                }
            });

            this.panels.show();

            if (this.options.heightStyle !== "content") {
                this.panels.css("height", "");
            }
        },

        enable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === false) {
                return;
            }

            if (index === undefined) {
                disabled = false;
            } else {
                index = this._getIndex(index);
                if ($.isArray(disabled)) {
                    disabled = $.map(disabled, function(num) {
                        return num !== index ? num : null;
                    });
                } else {
                    disabled = $.map(this.tabs, function(li, num) {
                        return num !== index ? num : null;
                    });
                }
            }
            this._setOptionDisabled(disabled);
        },

        disable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === true) {
                return;
            }

            if (index === undefined) {
                disabled = true;
            } else {
                index = this._getIndex(index);
                if ($.inArray(index, disabled) !== -1) {
                    return;
                }
                if ($.isArray(disabled)) {
                    disabled = $.merge([index], disabled).sort();
                } else {
                    disabled = [index];
                }
            }
            this._setOptionDisabled(disabled);
        },

        load: function(index, event) {
            index = this._getIndex(index);
            var that = this,
                tab = this.tabs.eq(index),
                anchor = tab.find(".ui-tabs-anchor"),
                panel = this._getPanelForTab(tab),
                eventData = {
                    tab: tab,
                    panel: panel
                },
                complete = function(jqXHR, status) {
                    if (status === "abort") {
                        that.panels.stop(false, true);
                    }

                    that._removeClass(tab, "ui-tabs-loading");
                    panel.removeAttr("aria-busy");

                    if (jqXHR === that.xhr) {
                        delete that.xhr;
                    }
                };

            // Not remote
            if (this._isLocal(anchor[0])) {
                return;
            }

            this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));

            // Support: jQuery <1.8
            // jQuery <1.8 returns false if the request is canceled in beforeSend,
            // but as of 1.8, $.ajax() always returns a jqXHR object.
            if (this.xhr && this.xhr.statusText !== "canceled") {
                this._addClass(tab, "ui-tabs-loading");
                panel.attr("aria-busy", "true");

                this.xhr
                    .done(function(response, status, jqXHR) {

                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function() {
                            panel.html(response);
                            that._trigger("load", event, eventData);

                            complete(jqXHR, status);
                        }, 1);
                    })
                    .fail(function(jqXHR, status) {

                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function() {
                            complete(jqXHR, status);
                        }, 1);
                    });
            }
        },

        _ajaxSettings: function(anchor, event, eventData) {
            var that = this;
            return {

                // Support: IE <11 only
                // Strip any hash that exists to prevent errors with the Ajax request
                url: anchor.attr("href").replace(/#.*$/, ""),
                beforeSend: function(jqXHR, settings) {
                    return that._trigger("beforeLoad", event,
                        $.extend({
                            jqXHR: jqXHR,
                            ajaxSettings: settings
                        }, eventData));
                }
            };
        },

        _getPanelForTab: function(tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        }
    });

    // DEPRECATED
    // TODO: Switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {

        // Backcompat for ui-tab class (now ui-tabs-tab)
        $.widget("ui.tabs", $.ui.tabs, {
            _processTabs: function() {
                this._superApply(arguments);
                this._addClass(this.tabs, "ui-tab");
            }
        });
    }

    var widgetsTabs = $.ui.tabs;


    /*!
     * jQuery UI Tooltip 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Tooltip
    //>>group: Widgets
    //>>description: Shows additional information for any element on hover or focus.
    //>>docs: http://api.jqueryui.com/tooltip/
    //>>demos: http://jqueryui.com/tooltip/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/tooltip.css
    //>>css.theme: ../../themes/base/theme.css



    $.widget("ui.tooltip", {
        version: "1.12.1",
        options: {
            classes: {
                "ui-tooltip": "ui-corner-all ui-widget-shadow"
            },
            content: function() {

                // support: IE<9, Opera in jQuery <1.7
                // .text() can't accept undefined, so coerce to a string
                var title = $(this).attr("title") || "";

                // Escape title, since we're going from an attribute to raw HTML
                return $("<a>").text(title).html();
            },
            hide: true,

            // Disabled elements have inconsistent behavior across browsers (#8661)
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: true,
            track: false,

            // Callbacks
            close: null,
            open: null
        },

        _addDescribedBy: function(elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
            describedby.push(id);
            elem
                .data("ui-tooltip-id", id)
                .attr("aria-describedby", $.trim(describedby.join(" ")));
        },

        _removeDescribedBy: function(elem) {
            var id = elem.data("ui-tooltip-id"),
                describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
                index = $.inArray(id, describedby);

            if (index !== -1) {
                describedby.splice(index, 1);
            }

            elem.removeData("ui-tooltip-id");
            describedby = $.trim(describedby.join(" "));
            if (describedby) {
                elem.attr("aria-describedby", describedby);
            } else {
                elem.removeAttr("aria-describedby");
            }
        },

        _create: function() {
            this._on({
                mouseover: "open",
                focusin: "open"
            });

            // IDs of generated tooltips, needed for destroy
            this.tooltips = {};

            // IDs of parent tooltips where we removed the title attribute
            this.parents = {};

            // Append the aria-live region so tooltips announce correctly
            this.liveRegion = $("<div>")
                .attr({
                    role: "log",
                    "aria-live": "assertive",
                    "aria-relevant": "additions"
                })
                .appendTo(this.document[0].body);
            this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible");

            this.disabledTitles = $([]);
        },

        _setOption: function(key, value) {
            var that = this;

            this._super(key, value);

            if (key === "content") {
                $.each(this.tooltips, function(id, tooltipData) {
                    that._updateContent(tooltipData.element);
                });
            }
        },

        _setOptionDisabled: function(value) {
            this[value ? "_disable" : "_enable"]();
        },

        _disable: function() {
            var that = this;

            // Close open tooltips
            $.each(this.tooltips, function(id, tooltipData) {
                var event = $.Event("blur");
                event.target = event.currentTarget = tooltipData.element[0];
                that.close(event, true);
            });

            // Remove title attributes to prevent native tooltips
            this.disabledTitles = this.disabledTitles.add(
                this.element.find(this.options.items).addBack()
                .filter(function() {
                    var element = $(this);
                    if (element.is("[title]")) {
                        return element
                            .data("ui-tooltip-title", element.attr("title"))
                            .removeAttr("title");
                    }
                })
            );
        },

        _enable: function() {

            // restore title attributes
            this.disabledTitles.each(function() {
                var element = $(this);
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                }
            });
            this.disabledTitles = $([]);
        },

        open: function(event) {
            var that = this,
                target = $(event ? event.target : this.element)

                // we need closest here due to mouseover bubbling,
                // but always pointing at the same event target
                .closest(this.options.items);

            // No element to show a tooltip for or the tooltip is already open
            if (!target.length || target.data("ui-tooltip-id")) {
                return;
            }

            if (target.attr("title")) {
                target.data("ui-tooltip-title", target.attr("title"));
            }

            target.data("ui-tooltip-open", true);

            // Kill parent tooltips, custom or native, for hover
            if (event && event.type === "mouseover") {
                target.parents().each(function() {
                    var parent = $(this),
                        blurEvent;
                    if (parent.data("ui-tooltip-open")) {
                        blurEvent = $.Event("blur");
                        blurEvent.target = blurEvent.currentTarget = this;
                        that.close(blurEvent, true);
                    }
                    if (parent.attr("title")) {
                        parent.uniqueId();
                        that.parents[this.id] = {
                            element: this,
                            title: parent.attr("title")
                        };
                        parent.attr("title", "");
                    }
                });
            }

            this._registerCloseHandlers(event, target);
            this._updateContent(target, event);
        },

        _updateContent: function(target, event) {
            var content,
                contentOption = this.options.content,
                that = this,
                eventType = event ? event.type : null;

            if (typeof contentOption === "string" || contentOption.nodeType ||
                contentOption.jquery) {
                return this._open(event, target, contentOption);
            }

            content = contentOption.call(target[0], function(response) {

                // IE may instantly serve a cached response for ajax requests
                // delay this call to _open so the other call to _open runs first
                that._delay(function() {

                    // Ignore async response if tooltip was closed already
                    if (!target.data("ui-tooltip-open")) {
                        return;
                    }

                    // JQuery creates a special event for focusin when it doesn't
                    // exist natively. To improve performance, the native event
                    // object is reused and the type is changed. Therefore, we can't
                    // rely on the type being correct after the event finished
                    // bubbling, so we set it back to the previous value. (#8740)
                    if (event) {
                        event.type = eventType;
                    }
                    this._open(event, target, response);
                });
            });
            if (content) {
                this._open(event, target, content);
            }
        },

        _open: function(event, target, content) {
            var tooltipData, tooltip, delayedShow, a11yContent,
                positionOption = $.extend({}, this.options.position);

            if (!content) {
                return;
            }

            // Content can be updated multiple times. If the tooltip already
            // exists, then just update the content and bail.
            tooltipData = this._find(target);
            if (tooltipData) {
                tooltipData.tooltip.find(".ui-tooltip-content").html(content);
                return;
            }

            // If we have a title, clear it to prevent the native tooltip
            // we have to check first to avoid defining a title if none exists
            // (we don't want to cause an element to start matching [title])
            //
            // We use removeAttr only for key events, to allow IE to export the correct
            // accessible attributes. For mouse events, set to empty string to avoid
            // native tooltip showing up (happens only when removing inside mouseover).
            if (target.is("[title]")) {
                if (event && event.type === "mouseover") {
                    target.attr("title", "");
                } else {
                    target.removeAttr("title");
                }
            }

            tooltipData = this._tooltip(target);
            tooltip = tooltipData.tooltip;
            this._addDescribedBy(target, tooltip.attr("id"));
            tooltip.find(".ui-tooltip-content").html(content);

            // Support: Voiceover on OS X, JAWS on IE <= 9
            // JAWS announces deletions even when aria-relevant="additions"
            // Voiceover will sometimes re-read the entire log region's contents from the beginning
            this.liveRegion.children().hide();
            a11yContent = $("<div>").html(tooltip.find(".ui-tooltip-content").html());
            a11yContent.removeAttr("name").find("[name]").removeAttr("name");
            a11yContent.removeAttr("id").find("[id]").removeAttr("id");
            a11yContent.appendTo(this.liveRegion);

            function position(event) {
                positionOption.of = event;
                if (tooltip.is(":hidden")) {
                    return;
                }
                tooltip.position(positionOption);
            }
            if (this.options.track && event && /^mouse/.test(event.type)) {
                this._on(this.document, {
                    mousemove: position
                });

                // trigger once to override element-relative positioning
                position(event);
            } else {
                tooltip.position($.extend({ of: target
                }, this.options.position));
            }

            tooltip.hide();

            this._show(tooltip, this.options.show);

            // Handle tracking tooltips that are shown with a delay (#8644). As soon
            // as the tooltip is visible, position the tooltip using the most recent
            // event.
            // Adds the check to add the timers only when both delay and track options are set (#14682)
            if (this.options.track && this.options.show && this.options.show.delay) {
                delayedShow = this.delayedShow = setInterval(function() {
                    if (tooltip.is(":visible")) {
                        position(positionOption.of);
                        clearInterval(delayedShow);
                    }
                }, $.fx.interval);
            }

            this._trigger("open", event, {
                tooltip: tooltip
            });
        },

        _registerCloseHandlers: function(event, target) {
            var events = {
                keyup: function(event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0];
                        this.close(fakeEvent, true);
                    }
                }
            };

            // Only bind remove handler for delegated targets. Non-delegated
            // tooltips will handle this in destroy.
            if (target[0] !== this.element[0]) {
                events.remove = function() {
                    this._removeTooltip(this._find(target).tooltip);
                };
            }

            if (!event || event.type === "mouseover") {
                events.mouseleave = "close";
            }
            if (!event || event.type === "focusin") {
                events.focusout = "close";
            }
            this._on(true, target, events);
        },

        close: function(event) {
            var tooltip,
                that = this,
                target = $(event ? event.currentTarget : this.element),
                tooltipData = this._find(target);

            // The tooltip may already be closed
            if (!tooltipData) {

                // We set ui-tooltip-open immediately upon open (in open()), but only set the
                // additional data once there's actually content to show (in _open()). So even if the
                // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
                // the period between open() and _open().
                target.removeData("ui-tooltip-open");
                return;
            }

            tooltip = tooltipData.tooltip;

            // Disabling closes the tooltip, so we need to track when we're closing
            // to avoid an infinite loop in case the tooltip becomes disabled on close
            if (tooltipData.closing) {
                return;
            }

            // Clear the interval for delayed tracking tooltips
            clearInterval(this.delayedShow);

            // Only set title if we had one before (see comment in _open())
            // If the title attribute has changed since open(), don't restore
            if (target.data("ui-tooltip-title") && !target.attr("title")) {
                target.attr("title", target.data("ui-tooltip-title"));
            }

            this._removeDescribedBy(target);

            tooltipData.hiding = true;
            tooltip.stop(true);
            this._hide(tooltip, this.options.hide, function() {
                that._removeTooltip($(this));
            });

            target.removeData("ui-tooltip-open");
            this._off(target, "mouseleave focusout keyup");

            // Remove 'remove' binding only on delegated targets
            if (target[0] !== this.element[0]) {
                this._off(target, "remove");
            }
            this._off(this.document, "mousemove");

            if (event && event.type === "mouseleave") {
                $.each(this.parents, function(id, parent) {
                    $(parent.element).attr("title", parent.title);
                    delete that.parents[id];
                });
            }

            tooltipData.closing = true;
            this._trigger("close", event, {
                tooltip: tooltip
            });
            if (!tooltipData.hiding) {
                tooltipData.closing = false;
            }
        },

        _tooltip: function(element) {
            var tooltip = $("<div>").attr("role", "tooltip"),
                content = $("<div>").appendTo(tooltip),
                id = tooltip.uniqueId().attr("id");

            this._addClass(content, "ui-tooltip-content");
            this._addClass(tooltip, "ui-tooltip", "ui-widget ui-widget-content");

            tooltip.appendTo(this._appendTo(element));

            return this.tooltips[id] = {
                element: element,
                tooltip: tooltip
            };
        },

        _find: function(target) {
            var id = target.data("ui-tooltip-id");
            return id ? this.tooltips[id] : null;
        },

        _removeTooltip: function(tooltip) {
            tooltip.remove();
            delete this.tooltips[tooltip.attr("id")];
        },

        _appendTo: function(target) {
            var element = target.closest(".ui-front, dialog");

            if (!element.length) {
                element = this.document[0].body;
            }

            return element;
        },

        _destroy: function() {
            var that = this;

            // Close open tooltips
            $.each(this.tooltips, function(id, tooltipData) {

                // Delegate to close method to handle common cleanup
                var event = $.Event("blur"),
                    element = tooltipData.element;
                event.target = event.currentTarget = element[0];
                that.close(event, true);

                // Remove immediately; destroying an open tooltip doesn't use the
                // hide animation
                $("#" + id).remove();

                // Restore the title
                if (element.data("ui-tooltip-title")) {

                    // If the title attribute has changed since open(), don't restore
                    if (!element.attr("title")) {
                        element.attr("title", element.data("ui-tooltip-title"));
                    }
                    element.removeData("ui-tooltip-title");
                }
            });
            this.liveRegion.remove();
        }
    });

    // DEPRECATED
    // TODO: Switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {

        // Backcompat for tooltipClass option
        $.widget("ui.tooltip", $.ui.tooltip, {
            options: {
                tooltipClass: null
            },
            _tooltip: function() {
                var tooltipData = this._superApply(arguments);
                if (this.options.tooltipClass) {
                    tooltipData.tooltip.addClass(this.options.tooltipClass);
                }
                return tooltipData;
            }
        });
    }

    var widgetsTooltip = $.ui.tooltip;




}));
// Copyright (c) 2009 Daniel Wachsstock
// MIT license:
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:

// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
(function($) {
    // create the master widget
    $.widget("ui.widget", {
        // Aspect Oriented Programming tools from Justin Palmer's article
        'yield': null,
        returnValues: {},
        before: function(method, f) {
            var original = this[method];
            this[method] = function() {
                f.apply(this, arguments);
                return original.apply(this, arguments);
            };
        },
        after: function(method, f) {
            var original = this[method];
            this[method] = function() {
                this.returnValues[method] = original.apply(this, arguments);
                return f.apply(this, arguments);
            }
        },
        around: function(method, f) {
            var original = this[method];
            this[method] = function() {
                var tmp = this["yield"];
                this["yield"] = original;
                var ret = f.apply(this, arguments);
                this["yield"] = tmp;
                return ret;
            }
        }
    });

    // from http://groups.google.com/group/comp.lang.javascript/msg/e04726a66face2a2 and
    // http://webreflection.blogspot.com/2008/10/big-douglas-begetobject-revisited.html
    var object = (function(F) {
        return (function(o) {
            F.prototype = o;
            return new F();
        });
    })(function() {});

    // create a widget subclass
    var OVERRIDE = /xyz/.test(function() {
        xyz;
    }) ? /\b_super\b/ : /.*/;
    $.ui.widget.subclass = function subclass(name) {
        $.widget(name); // Slightly inefficient to create a widget only to discard its prototype, but it's not too bad
        name = name.split('.');
        var widget = $[name[0]][name[1]],
            superclass = this,
            superproto = superclass.prototype;


        var proto = arguments[0] = widget.prototype = object(superproto); // inherit from the superclass
        $.extend.apply(null, arguments); // and add other add-in methods to the prototype
        widget.subclass = subclass;

        // Subtle point: we want to call superclass init and destroy if they exist
        // (otherwise the user of this function would have to keep track of all that)
        for (key in proto)
            if (proto.hasOwnProperty(key)) switch (key) {
                case '_create':
                    var create = proto._create;
                    proto._create = function() {
                        superproto._create.apply(this);
                        create.apply(this);
                    };
                    break;
                case '_init':
                    var init = proto._init;
                    proto._init = function() {
                        superproto._init.apply(this);
                        init.apply(this);
                    };
                    break;
                case 'destroy':
                    var destroy = proto.destroy;
                    proto.destroy = function() {
                        destroy.apply(this);
                        superproto.destroy.apply(this);
                    };
                    break;
                case 'options':
                    var options = proto.options;
                    proto.options = $.extend({}, superproto.options, options);
                    break;
                default:
                    if ($.isFunction(proto[key]) && $.isFunction(superproto[key]) && OVERRIDE.test(proto[key])) {
                        proto[key] = (function(name, fn) {
                            return function() {
                                var tmp = this._super;
                                this._super = superproto[name];
                                try {
                                    var ret = fn.apply(this, arguments);
                                } finally {
                                    this._super = tmp;
                                }
                                return ret;
                            };
                        })(key, proto[key]);
                    }
                    break;
            }
    };
})(jQuery);

/*
 * Swipe 2.0
 *
 * Brad Birdsall
 * Copyright 2013, MIT License
 *
 */

function Swipe(container, options) {

    "use strict";

    // utilities
    var noop = function() {}; // simple no operation function
    var offloadFn = function(fn) {
        setTimeout(fn || noop, 0)
    }; // offload a functions execution

    // check browser capabilities
    var browser = {
        addEventListener: !!window.addEventListener,
        touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,
        transitions: (function(temp) {
            var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
            for (var i in props)
                if (temp.style[props[i]] !== undefined) return true;
            return false;
        })(document.createElement('swipe'))
    };

    // quit if no root element
    if (!container) return;
    var element = container.children[0];
    var slides, slidePos, width, length;
    options = options || {};
    var index = parseInt(options.startSlide, 10) || 0;
    var speed = options.speed || 300;
    options.continuous = options.continuous !== undefined ? options.continuous : true;
    options.direction = options.direction !== undefined ? options.direction : 'ltr';

    function setup() {

        // cache slides
        slides = element.children;
        length = slides.length;

        // set continuous to false if only one slide
        if (slides.length < 2) options.continuous = false;

        //special case if two slides
        if (browser.transitions && options.continuous && slides.length < 3) {
            element.appendChild(slides[0].cloneNode(true));
            element.appendChild(element.children[1].cloneNode(true));
            slides = element.children;
        }

        // create an array to store current positions of each slide
        slidePos = new Array(slides.length);

        // determine width of each slide
        width = Math.round(window.screen.width || container.getBoundingClientRect().width || container.offsetWidth);

        element.style.width = (slides.length * width) + 'px';

        // stack elements
        var pos = slides.length;
        while (pos--) {

            var slide = slides[pos];

            slide.style.width = width + 'px';
            slide.setAttribute('data-index', pos);

            if (browser.transitions) {
                if (options.direction == 'rtl') {
                    slide.style.right = (pos * -width) + 'px';
                    move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
                } else {
                    slide.style.left = (pos * -width) + 'px';
                    move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
                }
            }

        }

        // reposition elements before and after index
        if (options.continuous && browser.transitions) {
            move(circle(index - 1), -width, 0);
            move(circle(index + 1), width, 0);
        }

        if (!browser.transitions) element.style.left = (index * -width) + 'px';

        container.style.visibility = 'visible';
        if (typeof(FDX) != "undefined" && typeof(FDX.OFFER) != "undefined") {
            FDX.OFFER.alignRTLStyle();
        }

    }

    function prev() {

        if (options.continuous) slide(index - 1);
        else if (index) slide(index - 1);

    }

    function next() {

        if (options.continuous) slide(index + 1);
        else if (index < slides.length - 1) slide(index + 1);

    }

    function circle(index) {

        // a simple positive modulo using slides.length
        return (slides.length + (index % slides.length)) % slides.length;

    }

    function slide(to, slideSpeed) {

        // do nothing if already on requested slide
        if (index == to) return;

        if (browser.transitions) {

            var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward

            // get the actual position of the slide
            if (options.continuous) {
                var natural_direction = direction;
                direction = -slidePos[circle(to)] / width;

                // if going forward but to < index, use to = slides.length + to
                // if going backward but to > index, use to = -slides.length + to
                if (direction !== natural_direction) to = -direction * slides.length + to;

            }

            var diff = Math.abs(index - to) - 1;

            // move all the slides between index and to in the right direction
            while (diff--) move(circle((to > index ? to : index) - diff - 1), width * direction, 0);

            to = circle(to);

            move(index, width * direction, slideSpeed || speed);
            move(to, 0, slideSpeed || speed);

            if (options.continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place

        } else {

            to = circle(to);
            animate(index * -width, to * -width, slideSpeed || speed);
            //no fallback for a circular continuous if the browser does not accept transitions
        }

        index = to;
        offloadFn(options.callback && options.callback(index, slides[index]));
    }

    function move(index, dist, speed) {

        translate(index, dist, speed);
        slidePos[index] = dist;

    }

    function translate(index, dist, speed) {

        var slide = slides[index];
        var style = slide && slide.style;

        if (!style) return;

        style.webkitTransitionDuration =
            style.MozTransitionDuration =
            style.msTransitionDuration =
            style.OTransitionDuration =
            style.transitionDuration = speed + 'ms';

        style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
        style.msTransform =
            style.MozTransform =
            style.OTransform = 'translateX(' + dist + 'px)';

    }

    function animate(from, to, speed) {

        // if not an animation, just reposition
        if (!speed) {

            element.style.left = to + 'px';
            return;

        }

        var start = +new Date;

        var timer = setInterval(function() {

            var timeElap = +new Date - start;

            if (timeElap > speed) {

                element.style.left = to + 'px';

                if (delay) begin();

                options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);

                clearInterval(timer);
                return;

            }

            element.style.left = (((to - from) * (Math.floor((timeElap / speed) * 100) / 100)) + from) + 'px';

        }, 4);

    }

    // setup auto slideshow
    var delay = options.auto || 0;
    var interval;

    function begin() {

        interval = setTimeout(next, delay);

    }

    function stop() {

        delay = 0;
        clearTimeout(interval);

    }


    // setup initial vars
    var start = {};
    var delta = {};
    var isScrolling;

    // setup event capturing
    var events = {

        handleEvent: function(event) {

            switch (event.type) {
                case 'touchstart':
                    this.start(event);
                    break;
                case 'touchmove':
                    this.move(event);
                    break;
                case 'touchend':
                    offloadFn(this.end(event));
                    break;
                case 'webkitTransitionEnd':
                case 'msTransitionEnd':
                case 'oTransitionEnd':
                case 'otransitionend':
                case 'transitionend':
                    offloadFn(this.transitionEnd(event));
                    break;
                case 'resize':
                    offloadFn(setup.call());
                    break;
            }

            if (options.stopPropagation) event.stopPropagation();

        },
        start: function(event) {

            var touches = event.touches[0];

            // measure start values
            start = {

                // get initial touch coords
                x: touches.pageX,
                y: touches.pageY,

                // store time to determine touch duration
                time: +new Date

            };

            // used for testing first move event
            isScrolling = undefined;

            // reset delta and end measurements
            delta = {};

            // attach touchmove and touchend listeners
            element.addEventListener('touchmove', this, false);
            element.addEventListener('touchend', this, false);

        },
        move: function(event) {

            // ensure swiping with one touch and not pinching
            if (event.touches.length > 1 || event.scale && event.scale !== 1) return

            if (options.disableScroll) event.preventDefault();

            var touches = event.touches[0];

            // measure change in x and y
            delta = {
                x: touches.pageX - start.x,
                y: touches.pageY - start.y
            }

            // determine if scrolling test has run - one time test
            if (typeof isScrolling == 'undefined') {
                isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
            }

            // if user is not trying to scroll vertically
            if (!isScrolling) {

                // prevent native scrolling
                event.preventDefault();

                // stop slideshow
                stop();

                // increase resistance if first or last slide
                if (options.continuous) { // we don't add resistance at the end
                    if (options.direction == 'rtl') {
                        translate(circle(index + 1), delta.x + slidePos[circle(index - 1)], 0);
                        translate(index, delta.x + slidePos[index], 0);
                        translate(circle(index - 1), delta.x + slidePos[circle(index + 1)], 0);
                    } else {
                        translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);
                        translate(index, delta.x + slidePos[index], 0);
                        translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);
                    }

                } else {

                    delta.x =
                        delta.x /
                        ((!index && delta.x > 0 // if first slide and sliding left
                                ||
                                index == slides.length - 1 // or if last slide and sliding right
                                &&
                                delta.x < 0 // and if sliding at all
                            ) ?
                            (Math.abs(delta.x) / width + 1) // determine resistance level
                            :
                            1); // no resistance if false

                    // translate 1:1
                    translate(index - 1, delta.x + slidePos[index - 1], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(index + 1, delta.x + slidePos[index + 1], 0);
                }

            }

        },
        end: function(event) {

            // measure duration
            var duration = +new Date - start.time;

            // determine if slide attempt triggers next/prev slide
            var isValidSlide =
                Number(duration) < 250 // if slide duration is less than 250ms
                &&
                Math.abs(delta.x) > 20 // and if slide amt is greater than 20px
                ||
                Math.abs(delta.x) > width / 2; // or if slide amt is greater than half the width

            // determine if slide attempt is past start and end
            var isPastBounds = !index && delta.x > 0 // if first slide and slide amt is greater than 0
                ||
                index == slides.length - 1 && delta.x < 0; // or if last slide and slide amt is less than 0

            if (options.continuous) isPastBounds = false;

            // determine direction of swipe (true:right, false:left)
            var direction = delta.x < 0;

            // if not scrolling vertically
            if (!isScrolling) {

                if (options.direction == 'rtl') {
                    if ((isValidSlide && !isPastBounds)) {
                        if (!direction) {

                            if (options.continuous) { // we need to get the next in this direction in place
                                move(circle(index - 1), -width, 0);
                                move(circle(index + 2), width, 0);

                            } else {
                                move(index - 1, -width, 0);
                            }
                            move(index, slidePos[index] - width, 0);
                            move(circle(index + 1), slidePos[circle(index + 1)] - width, 0);
                            index = circle(index + 1);


                        } else {
                            if (options.continuous) { // we need to get the next in this direction in place

                                move(circle(index + 1), width, 0);
                                move(circle(index - 2), -width, 0);

                            } else {
                                move(index + 1, width, 0);
                            }

                            move(index, slidePos[index] + width, 0);
                            move(circle(index - 1), slidePos[circle(index - 1)] + width, 0);
                            index = circle(index - 1);

                        }

                        options.callback && options.callback(index, slides[index]);

                    } else {

                        if (options.continuous) {

                            move(circle(index - 1), -width, speed);
                            move(index, 0, speed);
                            move(circle(index + 1), width, speed);

                        } else {

                            move(index - 1, -width, speed);
                            move(index, 0, speed);
                            move(index + 1, width, speed);
                        }

                    }
                } else {
                    if ((isValidSlide && !isPastBounds)) {

                        if (direction) {

                            if (options.continuous) { // we need to get the next in this direction in place

                                move(circle(index - 1), -width, 0);
                                move(circle(index + 2), width, 0);

                            } else {
                                move(index - 1, -width, 0);
                            }

                            move(index, slidePos[index] - width, speed);
                            move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);
                            index = circle(index + 1);

                        } else {
                            if (options.continuous) { // we need to get the next in this direction in place

                                move(circle(index + 1), width, 0);
                                move(circle(index - 2), -width, 0);

                            } else {
                                move(index + 1, width, 0);
                            }

                            move(index, slidePos[index] + width, speed);
                            move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);
                            index = circle(index - 1);

                        }

                        options.callback && options.callback(index, slides[index]);

                    } else {

                        if (options.continuous) {

                            move(circle(index - 1), -width, speed);
                            move(index, 0, speed);
                            move(circle(index + 1), width, speed);

                        } else {

                            move(index - 1, -width, speed);
                            move(index, 0, speed);
                            move(index + 1, width, speed);
                        }

                    }
                }

            }

            // kill touchmove and touchend event listeners until touchstart called again
            element.removeEventListener('touchmove', events, false)
            element.removeEventListener('touchend', events, false)

        },
        transitionEnd: function(event) {

            if (parseInt(event.target.getAttribute('data-index'), 10) == index) {

                if (delay) begin();

                options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);

            }

        }

    }

    // trigger setup
    setup();

    // start auto slideshow if applicable
    if (delay) begin();


    // add event listeners
    if (browser.addEventListener) {

        // set touchstart event on element    
        if (browser.touch) element.addEventListener('touchstart', events, false);

        if (browser.transitions) {
            element.addEventListener('webkitTransitionEnd', events, false);
            element.addEventListener('msTransitionEnd', events, false);
            element.addEventListener('oTransitionEnd', events, false);
            element.addEventListener('otransitionend', events, false);
            element.addEventListener('transitionend', events, false);
        }

        // set resize event on window
        window.addEventListener('resize', events, false);

    } else {

        window.onresize = function() {
            setup()
        }; // to play nice with old IE

    }

    // expose the Swipe API
    return {
        move: function(index, dist, speed) {

            move(index, dist, speed);

        },
        setup: function() {

            setup();

        },
        slide: function(to, speed) {

            // cancel slideshow
            stop();

            slide(to, speed);

        },
        prev: function() {

            // cancel slideshow
            stop();

            prev();

        },
        next: function() {

            // cancel slideshow
            stop();

            next();

        },
        getPos: function() {

            // return current index position
            return index;

        },
        getNumSlides: function() {

            // return total number of slides
            return length;
        },
        kill: function() {

            // cancel slideshow
            stop();

            // reset element
            element.style.width = 'auto';
            if (options.direction == 'rtl') {
                element.style.right = 0;
            } else {
                element.style.left = 0;
            }

            // reset slides
            var pos = slides.length;
            while (pos--) {

                var slide = slides[pos];
                slide.style.width = '100%';
                if (options.direction == 'rtl') {
                    slide.style.right = 0;
                } else {
                    slide.style.left = 0;
                }

                if (browser.transitions) translate(pos, 0, 0);

            }

            // removed event listeners
            if (browser.addEventListener) {

                // remove current event listeners
                element.removeEventListener('touchstart', events, false);
                element.removeEventListener('webkitTransitionEnd', events, false);
                element.removeEventListener('msTransitionEnd', events, false);
                element.removeEventListener('oTransitionEnd', events, false);
                element.removeEventListener('otransitionend', events, false);
                element.removeEventListener('transitionend', events, false);
                window.removeEventListener('resize', events, false);

            } else {

                window.onresize = null;

            }

        }
    }

}


if (window.jQuery || window.Zepto) {
    (function($) {
        $.fn.Swipe = function(params) {
            return this.each(function() {
                $(this).data('Swipe', new Swipe($(this)[0], params));
            });
        }
    })(window.jQuery || window.Zepto)
}
if (!window.FDX) {
    window.FDX = {};
}

if (!window.FDX.services) {
    window.FDX.services = {};
}

if (!window.FDX.components) {
    window.FDX.components = {};
}

FDX.build = {
    version: '{build.version}',
    timestamp: '{build.timestamp}'
};
/* This is the FedEx.com common core javascript file.
It contains common methods and variables that can be used across all pages within AEM.
The FDX.CORE object defined below creates a namespace to prevent conflicts with other js libraries.

Author: joey.dukeminier@vml.com
Created: 2016-10-13
Updated: 2017-06-14
*/
if (!FDX) {
    var FDX = {};
}

FDX.CORE = {
    runMode: "production", // debug|production,
    mainContentWrapper: ".fxg-main-content",
    printIndicator: 'fxg-print-indicator',

    //Padding function to add leading zero to a number
    pad: function pad(num, size) {
        var s = num + "";
        while (s.length < size) s = "0" + s;
        return s;
    },

    setContentWrapperTopMargin: function() {

        // no need to do anything if header is not sticky
        var isSticky = $('.' + FDX.HEADER.headerClass).hasClass(FDX.HEADER.stickyClass);
        if (!isSticky) return;

        // add margin top to the main wrapper
        $(FDX.CORE.mainContentWrapper).css('cssText', 'margin-top:' + FDX.HEADER.height + 'px !important');
    },

    printCurrentPage: function() {
        $('.' + FDX.CORE.printIndicator).on('click', function() {
            window.print();
        });
    },

    isVisiable: function(element, wrapper) {
        var el = $(element);
        // The element width such as video
        var elementWidth = el.width();
        // The viewport width for current item
        var itemWidth = el.parent().parent().width();
        //The width of the entire the items
        var wrapperWidth = $(wrapper).width();
        // The offset for element
        var bounds = el.offset();

        var right = wrapperWidth / 2 - bounds.left - elementWidth;
        var left = bounds.left;

        return left < itemWidth ||
            right > itemWidth;
    },
};

window.addEventListener('load', function() {
    FDX.CORE.setContentWrapperTopMargin();
    FDX.CORE.printCurrentPage();
});
/* This is the FedEx.com session javascript file.
 The global FDX object must already be defined.
 This file contains methods to get and set cookies.

 Author: joey.dukeminier@vml.com
 Created: 2017-03-27
 */
if (!FDX) {
    var FDX = {};
}

FDX.SESSION = {

    userAuthenticated: false,
    userModel: null,
    userRewards: 0,
    userRewardsTier: "",
    defaultRewardsTier: "VALUED REWARDS MEMBER",
    apiURL: "",
    clientID: "",
    clientSecret: "",
    grantType: "",
    apiConfigURL: "/etc/services/getapigconfigs",
    rewardsUATHost: "fedexapiuat.epsilon.com",
    rewardsKey: "",
    rewardsHost: "fedexapi.epsilon.com",
    targetRedirectAuth: false,
    cubeShippipng: false,
    purpleIdURL: "",
    purpleIduserAuthenticated: false,
    globalHomePage: window.location.origin + "/global/choose-location.html",

    COOKIENAMES: {
        contactName: "fcl_contactname",
        fName: "fcl_fname",
        lName: "lastName",
        companyName: "companyName",
        countryCode: "cc",
        postalCode: "postalCode",
        countryPath: "countryPath",
        locale: "fdx_locale",
        login: "fdx_login",
        rewards: "fdx_rewardPoints",
        userRewardsTier: "fdx_memberType",
        uuid: "fcl_uuid",
        sessionId: "FCLSESSIONID",
        jSessionId: "JSESSIONID",
        cbid: "fdx_cbid",
        userType: "fdx_usertype",
        rememberMe: "fdx_rememberme", // THIS IS A CUSTOM COOKIE SET BY VML. DO NOT REMOVE.
    },

    getCookie: function(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    },

    setCookie: function(name, value, days) {
        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            var expires = "; expires=" + date.toGMTString();
        } else var expires = "";

        if (typeof(value) != "undefined" && value != "") {
            document.cookie = name + "=" + value + expires + "; path=/";
        }
    },
    //Set secured cookie, fix for AVERT
    setSecuredCookie: function(name, value, days) {
        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            var expires = "; expires=" + date.toGMTString();
        } else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/" + "; secure";
    },

    // added July 1, 2017 for alert cookie
    setCookieBySeconds: function(name, value, seconds) {
        if (seconds) {
            var date = new Date();
            date.setTime(date.getTime() + (seconds * 1000));
            var expires = "; expires=" + date.toGMTString();
        } else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";
    },
    getAcronym: function(str) {
        var matches = str.match(/\b(\w)/g);
        var acronym = matches.join('');
        return acronym.toUpperCase();
    },

    getContactName: function() {

        if (typeof(fdx) !== 'undefined' && fdx.isBrand !== 'undefined' && fdx.isBrand == "true") {

            return FDX.SESSION.getUserModel().userProfileAddress.contact.personName.firstName.charAt(0).toUpperCase() +
                FDX.SESSION.getUserModel().userProfileAddress.contact.personName.lastName.charAt(0).toUpperCase();

        }

        // if the firstName is less than 11 characters long we will present it

        if (FDX.SESSION.getUserModel().userProfileAddress.contact.personName.firstName.length < 11) {
            return FDX.SESSION.getUserModel().userProfileAddress.contact.personName.firstName;
        } else {
            return FDX.SESSION.getAcronym(FDX.SESSION.getUserModel().userProfileAddress.contact.personName.firstName + " " +
                FDX.SESSION.getUserModel().userProfileAddress.contact.personName.lastName);
        }
    },

    getaFName: function() {

        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.fName);
    },

    getCountryCode: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.countryCode) != null ? FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.countryCode) : "/us/";
    },

    getCountryPath: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.countryPath) != null ? FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.countryPath) : "us";
    },

    getUUID: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.uuid);
    },

    getSessionID: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.sessionId);
    },

    getCBID: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.cbid);
    },


    getLocale: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.locale) != null ? FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.locale) : "en_US";
    },
    tokenUpdate: function() {
        if (sessionStorage.getItem("loginDataStorage")) {

            var parsedObject = JSON.parse(sessionStorage.getItem("loginDataStorage"));
            var tokenExpireTime = new Date(Date.parse(parsedObject.tokenExpireTime));

            if (Date.now() > tokenExpireTime.getTime()) {
                FDX.CLIENTLOGIN.loginCheck = true;
                FDX.CLIENTLOGIN.getOAuthToken();
            }
            if (localStorage.getItem("targetUserAuthenticated")) {
                FDX.SHIPPINGROUTING.doAPIShipingUserisLoggedIn();
            } else {

                var userLoggedInDetails = sessionStorage.getItem("userLoggedIn");
                //FDX.CLIENTLOGIN.doAPIisLoggedIn();
                if (localStorage.getItem("userLoggedInFlag") != 'true' || (userLoggedInDetails == null || JSON.parse(userLoggedInDetails).output.userLoggedIn == 'false') ||
                    document.cookie.indexOf("fdx_login") <= 0) {
                    FDX.CLIENTLOGIN.doAPIisLoggedIn();
                } else {
                    FDX.CLIENTLOGIN.doGetUserInfoDetails();
                }
            }
        } else {
            FDX.CLIENTLOGIN.getOAuthToken();
        }
    },
    purpleIdLoginUserCheck: function(storageVal) {
        if (storageVal) {
            var token = JSON.parse(storageVal).accessToken.accessToken;
            $.ajax({
                type: "GET",
                async: true,
                crossDomain: true,
                cache: false,
                url: FDX.SESSION.purpleIdURL,
                headers: {
                    Accept: "application/json",
                    "Content-Type": "application/json",
                    Authorization: "Bearer " + token,
                    "X-locale": "en_US",
                    "X-loggedin": "true",
                    "X-version": "1.0",
                    "X-clientid": "WCDO",
                },
                success: function(data) {
                    if (data.name) {
                        FDX.SESSION.purpleIduserAuthenticated = true;
                        console.log("checkAuth" + data.name);
                        $('.fxg-user-options__sign-in a span').text(data.given_name.charAt(0).toUpperCase() + data.family_name.charAt(0).toUpperCase());
                        FDX.UTILNAV.showAuthenticatedState();
                    } else {

                    }
                },
                error: function(request, status, error) {

                },
            });
        }

    },
    getLogin: function() {
        // If we are logged in the user model should be set
        if (FDX.SESSION.getUserModel() != null) {
            return true
        }
        if (typeof(FDX) != undefined && FDX.SESSION.getCookie('wcmmode') === null) {
            var configSelector = (window.location.host).split('.', 1);
            var apiServiceURL = FDX.SESSION.apiConfigURL + ".jsonp";
            if (configSelector[0] != "www") {
                apiServiceURL = FDX.SESSION.apiConfigURL + "." + configSelector[0] + ".jsonp";
            }

            $.when($.ajax(encodeURI(apiServiceURL))).then(function(msg, textStatus, jqXHR) {
                if (typeof(msg) == "string") {
                    msg = JSON.parse(msg);
                }

                FDX.SESSION.clientID = msg.clientID;
                FDX.SESSION.clientSecret = msg.clientSecret;
                FDX.SESSION.grantType = msg.grantType;
                FDX.SESSION.apiURL = msg.apigURL;
                FDX.SESSION.rewardsClientID = msg.rewardsClientID;
                FDX.SESSION.rewardsClientSecret = msg.rewardsClientSecret;
                FDX.SESSION.rewardsAPIGEnabled = msg.rewardsAPIGEnabled;
                FDX.SESSION.tokenUpdate();
            });
        }
    },

    getPurpleIdLogin: function(storageVal) {
        // If we are logged in the user model should be set
        if (FDX.SESSION.getUserModel() != null) {
            return true
        }
        if (typeof(FDX) != undefined && FDX.SESSION.getCookie('wcmmode') === null) {
            var configSelector = (window.location.host).split('.', 1);
            var apiServiceURL = FDX.SESSION.apiConfigURL + ".jsonp";
            if (configSelector[0] != "www") {
                apiServiceURL = FDX.SESSION.apiConfigURL + "." + configSelector[0] + ".jsonp";
            }

            $.when($.ajax(encodeURI(apiServiceURL))).then(function(msg, textStatus, jqXHR) {
                if (typeof(msg) == "string") {
                    msg = JSON.parse(msg);
                }
                FDX.SESSION.purpleIdURL = msg.purpleIdURL;
                FDX.SESSION.purpleIdLoginUserCheck(storageVal);
            });
        }
    },

    isLoggedIn: function() {
        var userLoggedInDetails = sessionStorage.getItem("userLoggedIn");
        //FDX.CLIENTLOGIN.doAPIisLoggedIn();
        if (localStorage.getItem("userLoggedInFlag") != 'true' || (userLoggedInDetails == null || JSON.parse(userLoggedInDetails).output.userLoggedIn == 'false') ||
            document.cookie.indexOf("fdx_login") <= 0) {
            FDX.CLIENTLOGIN.doAPIisLoggedIn();
        } else {
            FDX.CLIENTLOGIN.doGetUserInfoDetails();
        }
    },

    getJSessionID: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.jSessionId);
    },

    getRewardCookie: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.rewards);
    },
    getRewardTypeCookie: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.userRewardsTier);
    },
    getUserRewardsTier: function() {
        // TODO: ADD LOGIC HERE TO GET REWARDS TIER FROM REWARD COOKIE
        // RETURN DEFAULT FOR NOW
        return FDX.SESSION.defaultRewardsTier;
    },

    setRememberMe: function(username, expiry) {
        FDX.SESSION.setSecuredCookie(FDX.SESSION.COOKIENAMES.rememberMe, username, expiry);
    },

    getRememberMe: function() {
        return FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.rememberMe);
    },

    destroyRememberMe: function() {
        FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.rememberMe, '', -1);
    },
    destroyLogedInState: function() {
        //FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.login, '', -1);
        //FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.FName, '', -1);
        FDX.SESSION.remove(FDX.SESSION.COOKIENAMES.login);
        FDX.SESSION.remove(FDX.SESSION.COOKIENAMES.contactName);
        FDX.SESSION.remove(FDX.SESSION.COOKIENAMES.rewards);
        FDX.SESSION.remove(FDX.SESSION.COOKIENAMES.userRewardsTier);
        FDX.SESSION.remove(FDX.SESSION.COOKIENAMES.postalCode);
        FDX.SESSION.remove(FDX.SESSION.COOKIENAMES.fName);
        FDX.SESSION.remove(FDX.SESSION.COOKIENAMES.uuid);
        sessionStorage.removeItem("userDetails");
        sessionStorage.removeItem('userDetails');
        sessionStorage.removeItem('userLoggedIn');
        //Temp variable to fix SHF session storage clear isssue, SHF will watch this flag.
        localStorage.setItem('userLoggedInFlag', false);

    },
    removeRedirectCookie: function() {
        document.cookie = "fdx_redirect" +
            "=null; domain=fedex.com; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT;";
    },
    remove: function(name) {
        document.cookie = name +
            "=null; domain=fedex.com; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT;";
    },
    setAuthenticated: function(authenticated) {
        FDX.SESSION.userAuthenticated = authenticated;
    },
    setTargetRedirectAuth: function(authenticated) {
        FDX.SESSION.targetRedirectAuth = authenticated;
    },

    setUserRewards: function() {
        var rewards = FDX.SESSION.getRewardCookie();
        if (rewards == "" || rewards == null || rewards == undefined) {
            FDX.SESSION.userRewards = 0;
        } else {
            FDX.SESSION.userRewards = Number(rewards)
            var rewardType = FDX.SESSION.getRewardTypeCookie();
            if (rewardType == "" || rewardType == null || rewardType == undefined) {

            } else {
                FDX.SESSION.userRewardsTier = rewardType;
            }
        }
    },

    setMockCookies: function(expiry) {
        // Method used by FDX.LOGIN for debugging. FDX.runMode should be set to "debug"
        // To destroy cookies, pass in "-1" for expiry
        if (FDX.CORE.runMode == "debug") {
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.contactName, "John Doe", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.fName, "John", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.countryCode, "/us/", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.countryPath, "us", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.uuid, "1234567890", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.sessionId, "1234567890", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.cbid, "1234567890", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.locale, "en_US", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.login, "1234567890", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.jSessionId, "1234567890", expiry);
            FDX.SESSION.setCookie(FDX.SESSION.COOKIENAMES.rewards, "987654", expiry);
        }
    },

    setMockUserModel: function() {
        if (FDX.CORE.runMode == "debug") {
            FDX.SESSION.userModel = FDX.SESSION.mockUserModel;
        }
    },
    setUserModel: function(model) {
        FDX.SESSION.userModel = model;
    },
    getUserModel: function() {
        return FDX.SESSION.userModel;
    },
    destroyUserModel: function() {
        FDX.SESSION.userModel = null;
    },

    mockUserModel: {
        "successful": true,
        "userProfile": {
            "profileLocked": false,
            "loginInformation": {
                "userId": "wportesting1",
                "secretQuestion": {
                    "code": "SP2Q1",
                    "text": "What is your mother\u0027s first name?         "
                }
            },
            "userProfileAddress": {
                "contact": {
                    "personName": {
                        "firstName": "Jayas",
                        "middleName": "(*\u0026amp;#$(*\u0026amp;@#$",
                        "lastName": "Tolleson"
                    },
                    "companyName": "RAYMOND HO \u0026 CO",
                    "phoneNumber": "6472638310",
                    "faxNumber": "",
                    "emailAddress": "a_jeyamala@hotmail.com"
                },
                "contactAncillaryDetail": {
                    "phoneNumberDetails": [{
                            "type": "HOME",
                            "number": {
                                "countryCode": "1",
                                "localNumber": "6472638310"
                            },
                            "permissions": {}
                        },
                        {
                            "type": "MOBILE",
                            "number": {
                                "countryCode": "",
                                "localNumber": ""
                            },
                            "permissions": {}
                        },
                        {
                            "type": "FAX",
                            "number": {
                                "countryCode": "",
                                "localNumber": ""
                            },
                            "permissions": {}
                        }
                    ]
                },
                "address": {
                    "streetLines": ["30 fedex pkwy", ""],
                    "city": "COLLIERVILLE",
                    "stateOrProvinceCode": "TN",
                    "postalCode": "38017",
                    "countryCode": "US",
                    "residential": false
                }
            }
        }
    }
};

$(document).ready(function() {
    // Set authenticated state on page load 
    if (typeof(fdx) !== 'undefined' && fdx.isBrand !== 'undefined' && fdx.isBrand == "true") {
        var storageVal = localStorage.getItem("okta-token-storage");
        if (storageVal) {
            FDX.SESSION.getPurpleIdLogin(storageVal);
        } else {
            FDX.SESSION.getLogin();
        }

    } else if (window.location.href.indexOf(FDX.SESSION.globalHomePage) != 0) {
        FDX.SESSION.getLogin();
    }
    // If authenticated then set Rewards
    if (FDX.SESSION.userAuthenticated) {
        // set reward points value
        FDX.SESSION.setUserRewards();
        FDX.UTILNAV.toggleRewardPointsLink();
    }
});
/* This is the FedEx.com common core javascript file.
It contains common methods and variables that can be used across all pages within AEM.
The FDX object defined below creates a namespace to prevent conflicts with other js libraries.
•	Check Percentage of Traffic
•	Check Browser Type
•	Check Browser Version
•	Check Device Type
•	Check Continent

Author: gour.mohantyr@wipro.com
Created: 2017-06-09
 */

if (!FDX) {
    var FDX = {};
}

FDX.THROTTLE = {

    getThrottlePercentage: function() {
        var throttlepercent = 0;;
        var fdx_cbid = FDX.SESSION.getCBID();
        if (fdx_cbid !== null && typeof fdx_cbid !== "undefined") {
            var cbidSerialOffset = fdx_cbid.substr(23, 2) || 0;
            throttlepercent = cbidSerialOffset;
            if (cbidSerialOffset <= throttlepercent) {
                console.log("ThrottlePercentage :" + "fdx_cbid : " + fdx_cbid +
                    " cbidSerialOffset : " + cbidSerialOffset +
                    " throttlepercent : " + throttlepercent);
            }
        }
        return throttlepercent;
    },

    getThrottleBrowserType: function() {
        var fdx_nAgt = navigator.userAgent;
        var fdx_browserName = navigator.appName;
        var fdx_nameOffset, fdx_verOffset, fdx_ix;

        if ((fdx_verOffset = fdx_nAgt.indexOf("OPR/")) != -1) {
            fdx_browserName = "Opera";
        }
        // In older Opera, the true version is after "Opera" or after
        // "Version"
        else if ((fdx_verOffset = fdx_nAgt.indexOf("Opera")) != -1) {
            fdx_browserName = "Opera";
        }
        // In MSIE, the true version is after "MSIE" in userAgent
        else if ((fdx_verOffset = fdx_nAgt.indexOf("MSIE")) != -1) {
            fdx_browserName = "Microsoft Internet Explorer";
        }
        // In Chrome, the true version is after "Chrome"
        else if ((fdx_verOffset = fdx_nAgt.indexOf("Chrome")) != -1) {
            fdx_browserName = "Chrome";
        }
        // In Safari, the true version is after "Safari" or after "Version"
        else if ((fdx_verOffset = fdx_nAgt.indexOf("Safari")) != -1) {
            fdx_browserName = "Safari";
        }
        // In Firefox, the true version is after "Firefox"
        else if ((fdx_verOffset = fdx_nAgt.indexOf("Firefox")) != -1) {
            fdx_browserName = "Firefox";
        }
        // In most other browsers, "name/version" is at the end of userAgent
        else if ((fdx_nameOffset = fdx_nAgt.lastIndexOf(' ') + 1) < (fdx_verOffset = fdx_nAgt
                .lastIndexOf('/'))) {
            fdx_browserName = fdx_nAgt.substring(fdx_nameOffset, fdx_verOffset);
            if (fdx_browserName.toLowerCase() == fdx_browserName.toUpperCase()) {
                fdx_browserName = navigator.appName;
            }
        }

        return fdx_browserName;
    },

    getThrottleBrowserVersion: function() {
        var fdx_nVer = navigator.appVersion;
        var fdx_nAgt = navigator.userAgent;
        var fdx_fullVersion = '' + parseFloat(navigator.appVersion);
        var fdx_majorVersion = parseInt(navigator.appVersion, 10);
        var fdx_nameOffset, fdx_verOffset, fdx_ix;

        if ((fdx_verOffset = fdx_nAgt.indexOf("OPR/")) != -1) {
            fdx_fullVersion = fdx_nAgt.substring(fdx_verOffset + 4);
        }
        // In older Opera, the true version is after "Opera" or after
        // "Version"
        else if ((fdx_verOffset = fdx_nAgt.indexOf("Opera")) != -1) {
            fdx_fullVersion = fdx_nAgt.substring(fdx_verOffset + 6);
            if ((fdx_verOffset = fdx_nAgt.indexOf("Version")) != -1) {
                fdx_fullVersion = fdx_nAgt.substring(fdx_verOffset + 8);
            }
        }
        // In MSIE, the true version is after "MSIE" in userAgent
        else if ((fdx_verOffset = fdx_nAgt.indexOf("MSIE")) != -1) {
            fdx_fullVersion = fdx_nAgt.substring(fdx_verOffset + 5);
        }
        // In Chrome, the true version is after "Chrome"
        else if ((fdx_verOffset = fdx_nAgt.indexOf("Chrome")) != -1) {
            fdx_fullVersion = fdx_nAgt.substring(fdx_verOffset + 7);
        }
        // In Safari, the true version is after "Safari" or after "Version"
        else if ((fdx_verOffset = fdx_nAgt.indexOf("Safari")) != -1) {
            fdx_fullVersion = fdx_nAgt.substring(fdx_verOffset + 7);
            if ((fdx_verOffset = fdx_nAgt.indexOf("Version")) != -1) {
                fdx_fullVersion = fdx_nAgt.substring(fdx_verOffset + 8);
            }
        }
        // In Firefox, the true version is after "Firefox"
        else if ((fdx_verOffset = fdx_nAgt.indexOf("Firefox")) != -1) {
            fdx_fullVersion = fdx_nAgt.substring(fdx_verOffset + 8);
        }

        return fdx_fullVersion;
    },

    getThrottleDeviceType: function() {
        var fdx_device_type = FDX.SESSION.getDeviceType();

        if (fdx_device_type === "desktop") {
            console.log("desktop");
        } else if (fdx_device_type === "mobile") {
            console.log("desktop");
        } else if (fx_device_type === "tablet" && match.tabletUrl) {
            console.log("desktop");
        }

        return fdx_device_type;
    },

    getThrottleContinent: function() {
        var fdx_locale = FDX.SESSION.getLocale();

        if (fdx_locale == "en_US" || fdx_locale == "ar_AE") {
            console.log("Redirect content to" + fdx_locale);
        }
        return fdx_locale;
    }

};

if (!FDX) {
    var FDX = {};
}

FDX.DTM = {

    // Function to push data to FDX.DATALAYER.event object and set linkdata
    // variable.
    pushLinkInfo: function(link) {
        /*eventData = {
              linkData : (typeof link.getAttribute("data-analytics") !== 'undefined') ? link.getAttribute("data-analytics") : "",
              linkType : (typeof link.getAttribute("target") !== 'undefined') ? link.getAttribute("target") : "_self"
                  }
        FDX.DATALAYER.event.push(eventData);*/
        FDX.DATALAYER.page.link.data = (typeof link.getAttribute("data-analytics") !== 'undefined') ? link.getAttribute("data-analytics") : "",
            FDX.DATALAYER.page.link.type = (typeof link.getAttribute("target") !== 'undefined' && link.getAttribute("target")) ? "newPage" : (typeof link.getAttribute("data-target") !== 'undefined' && link.getAttribute("data-target") && link.getAttribute("data-target") == '_blank') ? "newPage" : "samePage"
    },
    pushButtonInfo: function(data, type) {
        FDX.DATALAYER.page.button.data = data,
            FDX.DATALAYER.page.button.type = type
    },

    // Function to update the search term. 
    updateSearchTerm: function() {
        var searchTerm = document.getElementById('fxg-search-text');
        if (typeof searchTerm !== 'undefined') {
            FDX.DATALAYER.page.onsiteSearch.term = searchTerm.value,
                FDX.DATALAYER.page.onsiteSearch.suggested = ""
        }

    },

    // Function to update the location app selected value. 
    updateLocationApp: function() {
        FDX.DATALAYER.locationApp.googleAPIFlag = FDX.DATALAYER.googleAPIFlag;
        if (FDX.DATALAYER.locationApp.googleAPIFlag) {
            FDX.LOCATIONS.address = FDX.INPUT.addressFromAuto;
            FDX.LOCATIONS.geometry = FDX.INPUT.geometryFromAuto;
        }

    },

    // Function to update the rate and ship  app . 
    updateRateShipAppFrom: function(from) {
        FDX.DATALAYER.rateShipApp.from.googleAPIFlag = FDX.DATALAYER.googleAPIFlag;
        if (FDX.DATALAYER.rateShipApp.from.googleAPIFlag) {
            FDX.RATE_SHIP.fromAddress = FDX.INPUT.addressFromAuto;
        }
        FDX.DATALAYER.rateShipApp.from.value = from;
    },
    // Function to update the rate and ship  app . 
    updateRateShipAppTo: function(to) {
        FDX.DATALAYER.rateShipApp.to.googleAPIFlag = FDX.DATALAYER.googleAPIFlag;

        if (FDX.DATALAYER.rateShipApp.to.googleAPIFlag) {
            FDX.RATE_SHIP.toAddress = FDX.INPUT.addressFromAuto;
            console.log('Datalayer --->', FDX.INPUT.addressFromAuto)
        }
        FDX.DATALAYER.rateShipApp.to.value = to;
    },
    // Function to retrieve the latest event of the specified type
    getLastEventByType: function(type) {
        for (var a = FDX.DATALAYER.event.length - 1; a >= 0; a--) {
            if (FDX.DATALAYER.event[a].type && FDX.DATALAYER.event[a].type == "1") {
                return FDX.DATALAYER.event[a].name;
            }
        }
    },
    // Function to update the search term and asset type
    pushAssetSearchInfo: function(keyword, type) {
        FDX.DATALAYER.page.assetSearch.keyword = keyword,
            FDX.DATALAYER.page.assetSearch.type = type
    }
};
FDX.scrollToAnchor = function() {
    if (FDX.hashVal !== "") {
        var aTag = $("a[name='" + FDX.hashVal + "']");
        $(aTag).each(function() {
            $('html,body').animate({
                scrollTop: $(this).offset().top
            }, 'slow');
        });
    }
};

$(document).ready(function() {
    if (window.location.hash != '') {
        var value = window.location.hash;
        anchorLink(value);
    }
    FDX.scrollToAnchor();
    $('.fxg-rte h3 a,.fxg-rte p a,.link a').click(function() {
        if (this.href.indexOf('#') > -1)
            var tag = this.href.substring(this.href.indexOf('#'), this.href.length)
        anchorLink(tag)
    })

});

function anchorLink(tagId) {
    //Adding condition to check if hash code has slashes in it.
    if (tagId != undefined && !tagId.includes("#/", 0) && tagId !== '#') {
        var tag = $('html').find(tagId);
        if (tag != undefined && tag.length > 0) {
            multiAccordion(tag);
            if (tag.parent().prop('className') == 'fxg-accordion-wrapper') {
                tag.collapse('show');
                $('html,body').animate({
                    scrollTop: $('html').find(tag).offset().top - 120
                }, 'slow');

            } else
                $('html,body').animate({
                    scrollTop: $('html').find(tag).offset().top - 75
                }, 'slow');
        }
    }
}

function multiAccordion(tag) {
    var parentAcc = tag.parents('.fxg-content-box.panel-collapse');
    if (parentAcc != undefined && parentAcc.length > 0) {
        for (var j = 0; j < parentAcc.length; j++) {
            if ($(parentAcc[j]).length > 0) {
                if ($(parentAcc[j]).parent().find('.fxg-accordion-purple_style').length > 0) {
                    $(parentAcc[j]).parent().find('.fxg-expandable-cols__minus_sign').show();
                    $(parentAcc[j]).parent().find('.fxg-expandable-cols__plus_sign').hide();
                }
                $(parentAcc[j]).collapse('show');
            }
        }

    }
}

/* Functions to call Adobe Target segmentationc all.
 */
if (!FDX) {
    var FDX = {};
}

FDX.MBOXCHECK = {
    userCheck: false,

    getValue: function(cookieAMCV, inputParam) {
        var cookieValue;
        var length = inputParam.length;
        cookieValue = cookieAMCV.substring(cookieAMCV.indexOf(inputParam) +
            length);
        cookieValue = cookieValue.substring(cookieValue.indexOf("|") + 1);
        cookieValue = cookieValue.substring(cookieValue, cookieValue
            .indexOf("|"));
        return cookieValue;
    },

    getSessionValue: function(cookieMbox, param) {

        var targetSessioniD;
        if (cookieMbox.indexOf(param) >= 0) {
            var paramLength = param.length;
            targetSessioniD = cookieMbox.substring(cookieMbox.indexOf(param) +
                paramLength);
            targetSessioniD = targetSessioniD.substring(targetSessioniD,
                targetSessioniD.indexOf("#"));
        }
        return targetSessioniD;
    },
    doMboxAPICall: function(mboxId) {

        var amcvCookie = FDX.SESSION
            .getCookie('AMCV_1E22171B520E93BF0A490D44%40AdobeOrg');
        var marketingCloudVisotorId = "";
        var mboxMCGVID = "";
        var mbox = "api-mbox";
        var thirdPartyId = "12345abcde";
        var mboxAAMB = "";
        var MCAAMLH = "";
        var at_property = "4ba065c0-6b92-13a5-ccc8-2b8cfb21abda";
        var mboxCookie = FDX.SESSION.getCookie('mbox');
        var tntId;
        var sessionId;

        if (amcvCookie) {
            amcvCookie = unescape(amcvCookie);
            marketingCloudVisotorId = FDX.MBOXCHECK.getValue(
                amcvCookie, "MCMID");
            mboxMCGVID = marketingCloudVisotorId;
            mboxAAMB = FDX.MBOXCHECK.getValue(amcvCookie, "MCAAMB");
            MCAAMLH = FDX.MBOXCHECK.getValue(amcvCookie, "MCAAMLH");
        }

        if (mboxCookie) {
            sessionId = FDX.MBOXCHECK.getSessionValue(mboxCookie,
                "session#");
            tntId = FDX.MBOXCHECK
                .getSessionValue(mboxCookie, "PC#");

        }
        if ((typeof(sessionId) === 'undefined') || mboxId == "" || (typeof(tntId) === 'undefined')) {

            FDX.MBOXCHECK.userCheck = false;
            localStorage.setItem("magsUserCheck", FDX.MBOXCHECK.userCheck);

        }

        $.ajax('https://fedex.tt.omtrdc.net/rest/v1/mbox/' + sessionId + '?client=fedex', {
            type: 'POST',
            data: JSON.stringify({
                "mbox": mboxId,
                "tntId": tntId,
                "marketingCloudVisitorId": marketingCloudVisotorId,
                "thirdPartyId": thirdPartyId,
                "mboxParameters": {
                    "mboxMCGVID": mboxMCGVID,
                    "mboxAAMB": mboxAAMB,
                    "mboxMCGLH": MCAAMLH,
                    "at_property": at_property
                }
            }),
            headers: {
                'Content-Type': 'application/json',
                'cache-control': 'no-cache'
            },
            dataType: 'json',
            async: true,
            crossDomain: true,
            processData: false,
            success: function(data) {
                console.log(data);
                if (typeof(data.content) == undefined) {
                    FDX.MBOXCHECK.userCheck = "default";
                    localStorage.setItem("magsUserCheck", FDX.MBOXCHECK.userCheck);
                }
                if (typeof(data.content) !== undefined && data.content == "MAGS") {
                    FDX.MBOXCHECK.userCheck = "true";
                    localStorage.setItem("magsUserCheck", FDX.MBOXCHECK.userCheck);
                }
                if (typeof(data.content) !== undefined && data.content == "") {
                    FDX.MBOXCHECK.userCheck = "false";
                    localStorage.setItem("magsUserCheck", FDX.MBOXCHECK.userCheck);
                }
            },
            error: function(jqxhr, status, exception) {
                console.log("Exception", status, exception);
                FDX.MBOXCHECK.userCheck = "default";
                localStorage.setItem("magsUserCheck", FDX.MBOXCHECK.userCheck);
            }
        });




    }
};
/*!
 * Bootstrap v3.3.6 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */

if (typeof jQuery === 'undefined') {
    throw new Error('Bootstrap\'s JavaScript requires jQuery')
}

+
function($) {
    'use strict';
    var version = $.fn.jquery.split(' ')[0].split('.')
    if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 2)) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3')
    }
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.6
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
    // ============================================================

    function transitionEnd() {
        var el = document.createElement('bootstrap')

        var transEndEventNames = {
            WebkitTransition: 'webkitTransitionEnd',
            MozTransition: 'transitionend',
            OTransition: 'oTransitionEnd otransitionend',
            transition: 'transitionend'
        }

        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {
                    end: transEndEventNames[name]
                }
            }
        }

        return false // explicit for ie8 (  ._.)
    }

    // http://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function(duration) {
        var called = false
        var $el = this
        $(this).one('bsTransitionEnd', function() {
            called = true
        })
        var callback = function() {
            if (!called) $($el).trigger($.support.transition.end)
        }
        setTimeout(callback, duration)
        return this
    }

    $(function() {
        $.support.transition = transitionEnd()

        if (!$.support.transition) return

        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
            }
        }
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.6
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // ALERT CLASS DEFINITION
    // ======================

    var dismiss = '[data-dismiss="alert"]'
    var Alert = function(el) {
        $(el).on('click', dismiss, this.close)
    }

    Alert.VERSION = '3.3.6'

    Alert.TRANSITION_DURATION = 150

    Alert.prototype.close = function(e) {
        var $this = $(this)
        var selector = $this.attr('data-target')

        if (!selector) {
            selector = $this.attr('href')
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
        }

        var $parent = $(selector)

        if (e) e.preventDefault()

        if (!$parent.length) {
            $parent = $this.closest('.alert')
        }

        $parent.trigger(e = $.Event('close.bs.alert'))

        if (e.isDefaultPrevented()) return

        $parent.removeClass('in')

        function removeElement() {
            // detach from parent, fire event then clean up data
            $parent.detach().trigger('closed.bs.alert').remove()
        }

        $.support.transition && $parent.hasClass('fade') ?
            $parent
            .one('bsTransitionEnd', removeElement)
            .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
            removeElement()
    }


    // ALERT PLUGIN DEFINITION
    // =======================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.alert')

            if (!data) $this.data('bs.alert', (data = new Alert(this)))
            if (typeof option == 'string') data[option].call($this)
        })
    }

    var old = $.fn.alert

    $.fn.alert = Plugin
    $.fn.alert.Constructor = Alert


    // ALERT NO CONFLICT
    // =================

    $.fn.alert.noConflict = function() {
        $.fn.alert = old
        return this
    }


    // ALERT DATA-API
    // ==============

    $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.6
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // BUTTON PUBLIC CLASS DEFINITION
    // ==============================

    var Button = function(element, options) {
        this.$element = $(element)
        this.options = $.extend({}, Button.DEFAULTS, options)
        this.isLoading = false
    }

    Button.VERSION = '3.3.6'

    Button.DEFAULTS = {
        loadingText: 'loading...'
    }

    Button.prototype.setState = function(state) {
        var d = 'disabled'
        var $el = this.$element
        var val = $el.is('input') ? 'val' : 'html'
        var data = $el.data()

        state += 'Text'

        if (data.resetText == null) $el.data('resetText', $el[val]())

        // push to event loop to allow forms to submit
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state])

            if (state == 'loadingText') {
                this.isLoading = true
                $el.addClass(d).attr(d, d)
            } else if (this.isLoading) {
                this.isLoading = false
                $el.removeClass(d).removeAttr(d)
            }
        }, this), 0)
    }

    Button.prototype.toggle = function() {
        var changed = true
        var $parent = this.$element.closest('[data-toggle="buttons"]')

        if ($parent.length) {
            var $input = this.$element.find('input')
            if ($input.prop('type') == 'radio') {
                if ($input.prop('checked')) changed = false
                $parent.find('.active').removeClass('active')
                this.$element.addClass('active')
            } else if ($input.prop('type') == 'checkbox') {
                if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
                this.$element.toggleClass('active')
            }
            $input.prop('checked', this.$element.hasClass('active'))
            if (changed) $input.trigger('change')
        } else {
            this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
            this.$element.toggleClass('active')
        }
    }


    // BUTTON PLUGIN DEFINITION
    // ========================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.button')
            var options = typeof option == 'object' && option

            if (!data) $this.data('bs.button', (data = new Button(this, options)))

            if (option == 'toggle') data.toggle()
            else if (option) data.setState(option)
        })
    }

    var old = $.fn.button

    $.fn.button = Plugin
    $.fn.button.Constructor = Button


    // BUTTON NO CONFLICT
    // ==================

    $.fn.button.noConflict = function() {
        $.fn.button = old
        return this
    }


    // BUTTON DATA-API
    // ===============

    $(document)
        .on('click.bs.button.data-api', '[data-toggle^="button"]', function(e) {
            var $btn = $(e.target)
            if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
            Plugin.call($btn, 'toggle')
            if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault()
        })
        .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function(e) {
            $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
        })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.6
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // CAROUSEL CLASS DEFINITION
    // =========================

    var Carousel = function(element, options) {
        this.$element = $(element)
        this.$indicators = this.$element.find('.carousel-indicators')
        this.options = options
        this.paused = null
        this.sliding = null
        this.interval = null
        this.$active = null
        this.$items = null

        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
            .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
            .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
    }

    Carousel.VERSION = '3.3.6'

    Carousel.TRANSITION_DURATION = 600

    Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
    }

    Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName)) return
        switch (e.which) {
            case 37:
                this.prev();
                break
            case 39:
                this.next();
                break
            default:
                return
        }

        e.preventDefault()
    }

    Carousel.prototype.cycle = function(e) {
        e || (this.paused = false)

        this.interval && clearInterval(this.interval)

        this.options.interval &&
            !this.paused &&
            (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

        return this
    }

    Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children('.item')
        return this.$items.index(item || this.$active)
    }

    Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active)
        var willWrap = (direction == 'prev' && activeIndex === 0) ||
            (direction == 'next' && activeIndex == (this.$items.length - 1))
        if (willWrap && !this.options.wrap) return active
        var delta = direction == 'prev' ? -1 : 1
        var itemIndex = (activeIndex + delta) % this.$items.length
        return this.$items.eq(itemIndex)
    }

    Carousel.prototype.to = function(pos) {
        var that = this
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

        if (pos > (this.$items.length - 1) || pos < 0) return

        if (this.sliding) return this.$element.one('slid.bs.carousel', function() {
            that.to(pos)
        }) // yes, "slid"
        if (activeIndex == pos) return this.pause().cycle()

        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
    }

    Carousel.prototype.pause = function(e) {
        e || (this.paused = true)

        if (this.$element.find('.next, .prev').length && $.support.transition) {
            this.$element.trigger($.support.transition.end)
            this.cycle(true)
        }

        this.interval = clearInterval(this.interval)

        return this
    }

    Carousel.prototype.next = function() {
        if (this.sliding) return
        return this.slide('next')
    }

    Carousel.prototype.prev = function() {
        if (this.sliding) return
        return this.slide('prev')
    }

    Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find('.item.active')
        var $next = next || this.getItemForDirection(type, $active)
        var isCycling = this.interval
        var direction = type == 'next' ? 'left' : 'right'
        var that = this

        if ($next.hasClass('active')) return (this.sliding = false)

        var relatedTarget = $next[0]
        var slideEvent = $.Event('slide.bs.carousel', {
            relatedTarget: relatedTarget,
            direction: direction
        })
        this.$element.trigger(slideEvent)
        if (slideEvent.isDefaultPrevented()) return

        this.sliding = true

        isCycling && this.pause()

        if (this.$indicators.length) {
            this.$indicators.find('.active').removeClass('active')
            var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
            $nextIndicator && $nextIndicator.addClass('active')
        }

        var slidEvent = $.Event('slid.bs.carousel', {
            relatedTarget: relatedTarget,
            direction: direction
        }) // yes, "slid"
        if ($.support.transition && this.$element.hasClass('slide')) {
            $next.addClass(type)
            $next[0].offsetWidth // force reflow
            $active.addClass(direction)
            $next.addClass(direction)
            $active
                .one('bsTransitionEnd', function() {
                    $next.removeClass([type, direction].join(' ')).addClass('active')
                    $active.removeClass(['active', direction].join(' '))
                    that.sliding = false
                    setTimeout(function() {
                        that.$element.trigger(slidEvent)
                    }, 0)
                })
                .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
        } else {
            $active.removeClass('active')
            $next.addClass('active')
            this.sliding = false
            this.$element.trigger(slidEvent)
        }

        isCycling && this.cycle()

        return this
    }


    // CAROUSEL PLUGIN DEFINITION
    // ==========================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.carousel')
            var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
            var action = typeof option == 'string' ? option : options.slide

            if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
            if (typeof option == 'number') data.to(option)
            else if (action) data[action]()
            else if (options.interval) data.pause().cycle()
        })
    }

    var old = $.fn.carousel

    $.fn.carousel = Plugin
    $.fn.carousel.Constructor = Carousel


    // CAROUSEL NO CONFLICT
    // ====================

    $.fn.carousel.noConflict = function() {
        $.fn.carousel = old
        return this
    }


    // CAROUSEL DATA-API
    // =================

    var clickHandler = function(e) {
        var href
        var $this = $(this)
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
        if (!$target.hasClass('carousel')) return
        var options = $.extend({}, $target.data(), $this.data())
        var slideIndex = $this.attr('data-slide-to')
        if (slideIndex) options.interval = false

        Plugin.call($target, options)

        if (slideIndex) {
            $target.data('bs.carousel').to(slideIndex)
        }

        e.preventDefault()
    }

    $(document)
        .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
        .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

    $(window).on('load', function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this)
            Plugin.call($carousel, $carousel.data())
        })
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.6
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // COLLAPSE PUBLIC CLASS DEFINITION
    // ================================

    var Collapse = function(element, options) {
        this.$element = $(element)
        this.options = $.extend({}, Collapse.DEFAULTS, options)
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
            '[data-toggle="collapse"][data-target="#' + element.id + '"]')
        this.transitioning = null

        if (this.options.parent) {
            this.$parent = this.getParent()
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger)
        }

        if (this.options.toggle) this.toggle()
    }

    Collapse.VERSION = '3.3.6'

    Collapse.TRANSITION_DURATION = 350

    Collapse.DEFAULTS = {
        toggle: true
    }

    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass('width')
        return hasWidth ? 'width' : 'height'
    }

    Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass('in')) return

        var activesData
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

        if (actives && actives.length) {
            activesData = actives.data('bs.collapse')
            if (activesData && activesData.transitioning) return
        }

        var startEvent = $.Event('show.bs.collapse')
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented()) return

        if (actives && actives.length) {
            Plugin.call(actives, 'hide')
            activesData || actives.data('bs.collapse', null)
        }

        var dimension = this.dimension()

        this.$element
            .removeClass('collapse')
            .addClass('collapsing')[dimension](0)
            .attr('aria-expanded', true)

        this.$trigger
            .removeClass('collapsed')
            .attr('aria-expanded', true)

        this.transitioning = 1

        var complete = function() {
            this.$element
                .removeClass('collapsing')
                .addClass('collapse in')[dimension]('')
            this.transitioning = 0
            this.$element
                .trigger('shown.bs.collapse')
        }

        if (!$.support.transition) return complete.call(this)

        var scrollSize = $.camelCase(['scroll', dimension].join('-'))

        this.$element
            .one('bsTransitionEnd', $.proxy(complete, this))
            .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
    }

    Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass('in')) return

        var startEvent = $.Event('hide.bs.collapse')
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented()) return

        var dimension = this.dimension()

        this.$element[dimension](this.$element[dimension]())[0].offsetHeight

        this.$element
            .addClass('collapsing')
            .removeClass('collapse in')
            .attr('aria-expanded', false)

        this.$trigger
            .addClass('collapsed')
            .attr('aria-expanded', false)

        this.transitioning = 1

        var complete = function() {
            this.transitioning = 0
            this.$element
                .removeClass('collapsing')
                .addClass('collapse')
                .trigger('hidden.bs.collapse')
        }

        if (!$.support.transition) return complete.call(this)

        this.$element[dimension](0)
            .one('bsTransitionEnd', $.proxy(complete, this))
            .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
    }

    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass('in') ? 'hide' : 'show']()
    }

    Collapse.prototype.getParent = function() {
        return $(this.options.parent)
            .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
            .each($.proxy(function(i, element) {
                var $element = $(element)
                this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
            }, this))
            .end()
    }

    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass('in')

        $element.attr('aria-expanded', isOpen)
        $trigger
            .toggleClass('collapsed', !isOpen)
            .attr('aria-expanded', isOpen)
    }

    function getTargetFromTrigger($trigger) {
        var href
        var target = $trigger.attr('data-target') ||
            (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

        return $(target)
    }


    // COLLAPSE PLUGIN DEFINITION
    // ==========================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.collapse')
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

            if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
            if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    var old = $.fn.collapse

    $.fn.collapse = Plugin
    $.fn.collapse.Constructor = Collapse


    // COLLAPSE NO CONFLICT
    // ====================

    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old
        return this
    }


    // COLLAPSE DATA-API
    // =================

    $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function(e) {
        var $this = $(this)

        if (!$this.attr('data-target')) e.preventDefault()

        var $target = getTargetFromTrigger($this)
        var data = $target.data('bs.collapse')
        var option = data ? 'toggle' : $this.data()

        Plugin.call($target, option)
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.6
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // DROPDOWN CLASS DEFINITION
    // =========================

    var backdrop = '.dropdown-backdrop'
    var toggle = '[data-toggle="dropdown"]'
    var Dropdown = function(element) {
        $(element).on('click.bs.dropdown', this.toggle)
    }

    Dropdown.VERSION = '3.3.6'

    function getParent($this) {
        var selector = $this.attr('data-target')

        if (!selector) {
            selector = $this.attr('href')
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
        }

        var $parent = selector && $(selector)

        return $parent && $parent.length ? $parent : $this.parent()
    }

    function clearMenus(e) {
        if (e && e.which === 3) return
        $(backdrop).remove()
        $(toggle).each(function() {
            var $this = $(this)
            var $parent = getParent($this)
            var relatedTarget = {
                relatedTarget: this
            }

            if (!$parent.hasClass('open')) return

            if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

            $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

            if (e.isDefaultPrevented()) return

            $this.attr('aria-expanded', 'false')
            $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
        })
    }

    Dropdown.prototype.toggle = function(e) {
        var $this = $(this)

        if ($this.is('.disabled, :disabled')) return

        var $parent = getParent($this)
        var isActive = $parent.hasClass('open')

        clearMenus()

        if (!isActive) {
            if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
                // if mobile we use a backdrop because click events don't delegate
                $(document.createElement('div'))
                    .addClass('dropdown-backdrop')
                    .insertAfter($(this))
                    .on('click', clearMenus)
            }

            var relatedTarget = {
                relatedTarget: this
            }
            $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

            if (e.isDefaultPrevented()) return

            $this
                .trigger('focus')
                .attr('aria-expanded', 'true')

            $parent
                .toggleClass('open')
                .trigger($.Event('shown.bs.dropdown', relatedTarget))
        }

        return false
    }

    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

        var $this = $(this)

        e.preventDefault()
        e.stopPropagation()

        if ($this.is('.disabled, :disabled')) return

        var $parent = getParent($this)
        var isActive = $parent.hasClass('open')

        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger('focus')
            return $this.trigger('click')
        }

        var desc = ' li:not(.disabled):visible a'
        var $items = $parent.find('.dropdown-menu' + desc)

        if (!$items.length) return

        var index = $items.index(e.target)

        if (e.which == 38 && index > 0) index-- // up
            if (e.which == 40 && index < $items.length - 1) index++ // down
                if (!~index) index = 0

        $items.eq(index).trigger('focus')
    }


    // DROPDOWN PLUGIN DEFINITION
    // ==========================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.dropdown')

            if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
            if (typeof option == 'string') data[option].call($this)
        })
    }

    var old = $.fn.dropdown

    $.fn.dropdown = Plugin
    $.fn.dropdown.Constructor = Dropdown


    // DROPDOWN NO CONFLICT
    // ====================

    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old
        return this
    }


    // APPLY TO STANDARD DROPDOWN ELEMENTS
    // ===================================

    $(document)
        .on('click.bs.dropdown.data-api', clearMenus)
        .on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
            e.stopPropagation()
        })
        .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
        .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
        .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.6
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // MODAL CLASS DEFINITION
    // ======================

    var Modal = function(element, options) {
        this.options = options
        this.$body = $(document.body)
        this.$element = $(element)
        this.$dialog = this.$element.find('.modal-dialog')
        this.$backdrop = null
        this.isShown = null
        this.originalBodyPad = null
        this.scrollbarWidth = 0
        this.ignoreBackdropClick = false

        if (this.options.remote) {
            this.$element
                .find('.modal-content')
                .load(this.options.remote, $.proxy(function() {
                    this.$element.trigger('loaded.bs.modal')
                }, this))
        }
    }

    Modal.VERSION = '3.3.6'

    Modal.TRANSITION_DURATION = 300
    Modal.BACKDROP_TRANSITION_DURATION = 150

    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    }

    Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget)
    }

    Modal.prototype.show = function(_relatedTarget) {
        var that = this
        var e = $.Event('show.bs.modal', {
            relatedTarget: _relatedTarget
        })

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        this.isShown = true

        this.checkScrollbar()
        this.setScrollbar()
        this.$body.addClass('modal-open')

        this.escape()
        this.resize()

        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

        this.$dialog.on('mousedown.dismiss.bs.modal', function() {
            that.$element.one('mouseup.dismiss.bs.modal', function(e) {
                if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
            })
        })

        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass('fade')

            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body) // don't move modals dom position
            }

            that.$element
                .show()
                .scrollTop(0)

            that.adjustDialog()

            if (transition) {
                that.$element[0].offsetWidth // force reflow
            }

            that.$element.addClass('in')

            that.enforceFocus()

            var e = $.Event('shown.bs.modal', {
                relatedTarget: _relatedTarget
            })

            transition ?
                that.$dialog // wait for modal to slide in
                .one('bsTransitionEnd', function() {
                    that.$element.trigger('focus').trigger(e)
                })
                .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
                that.$element.trigger('focus').trigger(e)
        })
    }

    Modal.prototype.hide = function(e) {
        if (e) e.preventDefault()

        e = $.Event('hide.bs.modal')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        this.escape()
        this.resize()

        $(document).off('focusin.bs.modal')

        this.$element
            .removeClass('in')
            .off('click.dismiss.bs.modal')
            .off('mouseup.dismiss.bs.modal')

        this.$dialog.off('mousedown.dismiss.bs.modal')

        $.support.transition && this.$element.hasClass('fade') ?
            this.$element
            .one('bsTransitionEnd', $.proxy(this.hideModal, this))
            .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
            this.hideModal()
    }

    Modal.prototype.enforceFocus = function() {
        $(document)
            .off('focusin.bs.modal') // guard against infinite focus loop
            .on('focusin.bs.modal', $.proxy(function(e) {
                if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                    this.$element.trigger('focus')
                }
            }, this))
    }

    Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
            this.$element.on('keydown.dismiss.bs.modal', $.proxy(function(e) {
                e.which == 27 && this.hide()
            }, this))
        } else if (!this.isShown) {
            this.$element.off('keydown.dismiss.bs.modal')
        }
    }

    Modal.prototype.resize = function() {
        if (this.isShown) {
            $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
        } else {
            $(window).off('resize.bs.modal')
        }
    }

    Modal.prototype.hideModal = function() {
        var that = this
        this.$element.hide()
        this.backdrop(function() {
            that.$body.removeClass('modal-open')
            that.resetAdjustments()
            that.resetScrollbar()
            that.$element.trigger('hidden.bs.modal')
        })
    }

    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
    }

    Modal.prototype.backdrop = function(callback) {
        var that = this
        var animate = this.$element.hasClass('fade') ? 'fade' : ''

        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate

            this.$backdrop = $(document.createElement('div'))
                .addClass('modal-backdrop ' + animate)
                .appendTo(this.$body)

            this.$element.on('click.dismiss.bs.modal', $.proxy(function(e) {
                if (this.ignoreBackdropClick) {
                    this.ignoreBackdropClick = false
                    return
                }
                if (e.target !== e.currentTarget) return
                this.options.backdrop == 'static' ?
                    this.$element[0].focus() :
                    this.hide()
            }, this))

            if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

            this.$backdrop.addClass('in')

            if (!callback) return

            doAnimate ?
                this.$backdrop
                .one('bsTransitionEnd', callback)
                .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
                callback()

        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass('in')

            var callbackRemove = function() {
                that.removeBackdrop()
                callback && callback()
            }
            $.support.transition && this.$element.hasClass('fade') ?
                this.$backdrop
                .one('bsTransitionEnd', callbackRemove)
                .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
                callbackRemove()

        } else if (callback) {
            callback()
        }
    }

    // these following methods are used to handle overflowing modals

    Modal.prototype.handleUpdate = function() {
        this.adjustDialog()
    }

    Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        })
    }

    Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: '',
            paddingRight: ''
        })
    }

    Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth
        if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
            var documentElementRect = document.documentElement.getBoundingClientRect()
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
        this.scrollbarWidth = this.measureScrollbar()
    }

    Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
        this.originalBodyPad = document.body.style.paddingRight || ''
        if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
    }

    Modal.prototype.resetScrollbar = function() {
        this.$body.css('padding-right', this.originalBodyPad)
    }

    Modal.prototype.measureScrollbar = function() { // thx walsh
        var scrollDiv = document.createElement('div')
        scrollDiv.className = 'modal-scrollbar-measure'
        this.$body.append(scrollDiv)
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
        this.$body[0].removeChild(scrollDiv)
        return scrollbarWidth
    }


    // MODAL PLUGIN DEFINITION
    // =======================

    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.modal')
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

            if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
            if (typeof option == 'string') data[option](_relatedTarget)
            else if (options.show) data.show(_relatedTarget)
        })
    }

    var old = $.fn.modal

    $.fn.modal = Plugin
    $.fn.modal.Constructor = Modal


    // MODAL NO CONFLICT
    // =================

    $.fn.modal.noConflict = function() {
        $.fn.modal = old
        return this
    }


    // MODAL DATA-API
    // ==============

    $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function(e) {
        var $this = $(this)
        var href = $this.attr('href')
        var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
        var option = $target.data('bs.modal') ? 'toggle' : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data())

        if ($this.is('a')) e.preventDefault()

        $target.one('show.bs.modal', function(showEvent) {
            if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
            $target.one('hidden.bs.modal', function() {
                $this.is(':visible') && $this.trigger('focus')
            })
        })
        Plugin.call($target, option, this)
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.6
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // TOOLTIP PUBLIC CLASS DEFINITION
    // ===============================

    var Tooltip = function(element, options) {
        this.type = null
        this.options = null
        this.enabled = null
        this.timeout = null
        this.hoverState = null
        this.$element = null
        this.inState = null

        this.init('tooltip', element, options)
    }

    Tooltip.VERSION = '3.3.6'

    Tooltip.TRANSITION_DURATION = 150

    Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
            selector: 'body',
            padding: 0
        }
    }

    Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true
        this.type = type
        this.$element = $(element)
        this.options = this.getOptions(options)
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
        this.inState = {
            click: false,
            hover: false,
            focus: false
        }

        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
            throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
        }

        var triggers = this.options.trigger.split(' ')

        for (var i = triggers.length; i--;) {
            var trigger = triggers[i]

            if (trigger == 'click') {
                this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
            } else if (trigger != 'manual') {
                var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin'
                var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

                this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
                this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
            }
        }

        this.options.selector ?
            (this._options = $.extend({}, this.options, {
                trigger: 'manual',
                selector: ''
            })) :
            this.fixTitle()
    }

    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS
    }

    Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options)

        if (options.delay && typeof options.delay == 'number') {
            options.delay = {
                show: options.delay,
                hide: options.delay
            }
        }

        return options
    }

    Tooltip.prototype.getDelegateOptions = function() {
        var options = {}
        var defaults = this.getDefaults()

        this._options && $.each(this._options, function(key, value) {
            if (defaults[key] != value) options[key] = value
        })

        return options
    }

    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ?
            obj : $(obj.currentTarget).data('bs.' + this.type)

        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
            $(obj.currentTarget).data('bs.' + this.type, self)
        }

        if (obj instanceof $.Event) {
            self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
        }

        if (self.tip().hasClass('in') || self.hoverState == 'in') {
            self.hoverState = 'in'
            return
        }

        clearTimeout(self.timeout)

        self.hoverState = 'in'

        if (!self.options.delay || !self.options.delay.show) return self.show()

        self.timeout = setTimeout(function() {
            if (self.hoverState == 'in') self.show()
        }, self.options.delay.show)
    }

    Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
            if (this.inState[key]) return true
        }

        return false
    }

    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ?
            obj : $(obj.currentTarget).data('bs.' + this.type)

        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
            $(obj.currentTarget).data('bs.' + this.type, self)
        }

        if (obj instanceof $.Event) {
            self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
        }

        if (self.isInStateTrue()) return

        clearTimeout(self.timeout)

        self.hoverState = 'out'

        if (!self.options.delay || !self.options.delay.hide) return self.hide()

        self.timeout = setTimeout(function() {
            if (self.hoverState == 'out') self.hide()
        }, self.options.delay.hide)
    }

    Tooltip.prototype.show = function() {
        var e = $.Event('show.bs.' + this.type)

        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e)

            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
            if (e.isDefaultPrevented() || !inDom) return
            var that = this

            var $tip = this.tip()

            var tipId = this.getUID(this.type)

            this.setContent()
            $tip.attr('id', tipId)
            this.$element.attr('aria-describedby', tipId)

            if (this.options.animation) $tip.addClass('fade')

            var placement = typeof this.options.placement == 'function' ?
                this.options.placement.call(this, $tip[0], this.$element[0]) :
                this.options.placement

            var autoToken = /\s?auto?\s?/i
            var autoPlace = autoToken.test(placement)
            if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

            $tip
                .detach()
                .css({
                    top: 0,
                    left: 0,
                    display: 'block'
                })
                .addClass(placement)
                .data('bs.' + this.type, this)

            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
            this.$element.trigger('inserted.bs.' + this.type)

            var pos = this.getPosition()
            var actualWidth = $tip[0].offsetWidth
            var actualHeight = $tip[0].offsetHeight

            if (autoPlace) {
                var orgPlacement = placement
                var viewportDim = this.getPosition(this.$viewport)

                placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' :
                    placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' :
                    placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' :
                    placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' :
                    placement

                $tip
                    .removeClass(orgPlacement)
                    .addClass(placement)
            }

            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

            this.applyPlacement(calculatedOffset, placement)

            var complete = function() {
                var prevHoverState = that.hoverState
                that.$element.trigger('shown.bs.' + that.type)
                that.hoverState = null

                if (prevHoverState == 'out') that.leave(that)
            }

            $.support.transition && this.$tip.hasClass('fade') ?
                $tip
                .one('bsTransitionEnd', complete)
                .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
                complete()
        }
    }

    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip()
        var width = $tip[0].offsetWidth
        var height = $tip[0].offsetHeight

        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt($tip.css('margin-top'), 10)
        var marginLeft = parseInt($tip.css('margin-left'), 10)

        // we must check for NaN for ie 8/9
        if (isNaN(marginTop)) marginTop = 0
        if (isNaN(marginLeft)) marginLeft = 0

        offset.top += marginTop
        offset.left += marginLeft

        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                })
            }
        }, offset), 0)

        $tip.addClass('in')

        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth = $tip[0].offsetWidth
        var actualHeight = $tip[0].offsetHeight

        if (placement == 'top' && actualHeight != height) {
            offset.top = offset.top + height - actualHeight
        }

        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

        if (delta.left) offset.left += delta.left
        else offset.top += delta.top

        var isVertical = /top|bottom/.test(placement)
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

        $tip.offset(offset)
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
    }

    Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow()
            .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
            .css(isVertical ? 'top' : 'left', '')
    }

    Tooltip.prototype.setContent = function() {
        var $tip = this.tip()
        var title = this.getTitle()

        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
        $tip.removeClass('fade in top bottom left right')
    }

    Tooltip.prototype.hide = function(callback) {
        var that = this
        var $tip = $(this.$tip)
        var e = $.Event('hide.bs.' + this.type)

        function complete() {
            if (that.hoverState != 'in') $tip.detach()
            that.$element
                .removeAttr('aria-describedby')
                .trigger('hidden.bs.' + that.type)
            callback && callback()
        }

        this.$element.trigger(e)

        if (e.isDefaultPrevented()) return

        $tip.removeClass('in')

        $.support.transition && $tip.hasClass('fade') ?
            $tip
            .one('bsTransitionEnd', complete)
            .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
            complete()

        this.hoverState = null

        return this
    }

    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
            $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
        }
    }

    Tooltip.prototype.hasContent = function() {
        return this.getTitle()
    }

    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element

        var el = $element[0]
        var isBody = el.tagName == 'BODY'

        var elRect = el.getBoundingClientRect()
        if (elRect.width == null) {
            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
            elRect = $.extend({}, elRect, {
                width: elRect.right - elRect.left,
                height: elRect.bottom - elRect.top
            })
        }
        var elOffset = isBody ? {
            top: 0,
            left: 0
        } : $element.offset()
        var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        }
        var outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null

        return $.extend({}, elRect, scroll, outerDims, elOffset)
    }

    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? {
                top: pos.top + pos.height,
                left: pos.left + pos.width / 2 - actualWidth / 2
            } :
            placement == 'top' ? {
                top: pos.top - actualHeight,
                left: pos.left + pos.width / 2 - actualWidth / 2
            } :
            placement == 'left' ? {
                top: pos.top + pos.height / 2 - actualHeight / 2,
                left: pos.left - actualWidth
            } :
            /* placement == 'right' */
            {
                top: pos.top + pos.height / 2 - actualHeight / 2,
                left: pos.left + pos.width
            }

    }

    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        }
        if (!this.$viewport) return delta

        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
        var viewportDimensions = this.getPosition(this.$viewport)

        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
            if (topEdgeOffset < viewportDimensions.top) { // top overflow
                delta.top = viewportDimensions.top - topEdgeOffset
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth
            if (leftEdgeOffset < viewportDimensions.left) { // left overflow
                delta.left = viewportDimensions.left - leftEdgeOffset
            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
            }
        }

        return delta
    }

    Tooltip.prototype.getTitle = function() {
        var title
        var $e = this.$element
        var o = this.options

        title = $e.attr('data-original-title') ||
            (typeof o.title == 'function' ? o.title.call($e[0]) : o.title)

        return title
    }

    Tooltip.prototype.getUID = function(prefix) {
        do prefix += ~~(Math.random() * 1000000)
        while (document.getElementById(prefix))
        return prefix
    }

    Tooltip.prototype.tip = function() {
        if (!this.$tip) {
            this.$tip = $(this.options.template)
            if (this.$tip.length != 1) {
                throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
            }
        }
        return this.$tip
    }

    Tooltip.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
    }

    Tooltip.prototype.enable = function() {
        this.enabled = true
    }

    Tooltip.prototype.disable = function() {
        this.enabled = false
    }

    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled
    }

    Tooltip.prototype.toggle = function(e) {
        var self = this
        if (e) {
            self = $(e.currentTarget).data('bs.' + this.type)
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions())
                $(e.currentTarget).data('bs.' + this.type, self)
            }
        }

        if (e) {
            self.inState.click = !self.inState.click
            if (self.isInStateTrue()) self.enter(self)
            else self.leave(self)
        } else {
            self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
        }
    }

    Tooltip.prototype.destroy = function() {
        var that = this
        clearTimeout(this.timeout)
        this.hide(function() {
            that.$element.off('.' + that.type).removeData('bs.' + that.type)
            if (that.$tip) {
                that.$tip.detach()
            }
            that.$tip = null
            that.$arrow = null
            that.$viewport = null
        })
    }


    // TOOLTIP PLUGIN DEFINITION
    // =========================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.tooltip')
            var options = typeof option == 'object' && option

            if (!data && /destroy|hide/.test(option)) return
            if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    var old = $.fn.tooltip

    $.fn.tooltip = Plugin
    $.fn.tooltip.Constructor = Tooltip


    // TOOLTIP NO CONFLICT
    // ===================

    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old
        return this
    }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.6
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // POPOVER PUBLIC CLASS DEFINITION
    // ===============================

    var Popover = function(element, options) {
        this.init('popover', element, options)
    }

    if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

    Popover.VERSION = '3.3.6'

    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    })


    // NOTE: POPOVER EXTENDS tooltip.js
    // ================================

    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

    Popover.prototype.constructor = Popover

    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS
    }

    Popover.prototype.setContent = function() {
        var $tip = this.tip()
        var title = this.getTitle()
        var content = this.getContent()

        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
        $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
            this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
        ](content)

        $tip.removeClass('fade top bottom left right in')

        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
    }

    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent()
    }

    Popover.prototype.getContent = function() {
        var $e = this.$element
        var o = this.options

        return $e.attr('data-content') ||
            (typeof o.content == 'function' ?
                o.content.call($e[0]) :
                o.content)
    }

    Popover.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
    }


    // POPOVER PLUGIN DEFINITION
    // =========================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.popover')
            var options = typeof option == 'object' && option

            if (!data && /destroy|hide/.test(option)) return
            if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    var old = $.fn.popover

    $.fn.popover = Plugin
    $.fn.popover.Constructor = Popover


    // POPOVER NO CONFLICT
    // ===================

    $.fn.popover.noConflict = function() {
        $.fn.popover = old
        return this
    }

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.6
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // SCROLLSPY CLASS DEFINITION
    // ==========================

    function ScrollSpy(element, options) {
        this.$body = $(document.body)
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options)
        this.selector = (this.options.target || '') + ' .nav li > a'
        this.offsets = []
        this.targets = []
        this.activeTarget = null
        this.scrollHeight = 0

        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
        this.refresh()
        this.process()
    }

    ScrollSpy.VERSION = '3.3.6'

    ScrollSpy.DEFAULTS = {
        offset: 10
    }

    ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }

    ScrollSpy.prototype.refresh = function() {
        var that = this
        var offsetMethod = 'offset'
        var offsetBase = 0

        this.offsets = []
        this.targets = []
        this.scrollHeight = this.getScrollHeight()

        if (!$.isWindow(this.$scrollElement[0])) {
            offsetMethod = 'position'
            offsetBase = this.$scrollElement.scrollTop()
        }

        this.$body
            .find(this.selector)
            .map(function() {
                var $el = $(this)
                var href = $el.data('target') || $el.attr('href')
                var $href = /^#./.test(href) && $(href)

                return ($href &&
                    $href.length &&
                    $href.is(':visible') &&
                    [
                        [$href[offsetMethod]().top + offsetBase, href]
                    ]) || null
            })
            .sort(function(a, b) {
                return a[0] - b[0]
            })
            .each(function() {
                that.offsets.push(this[0])
                that.targets.push(this[1])
            })
    }

    ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
        var scrollHeight = this.getScrollHeight()
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height()
        var offsets = this.offsets
        var targets = this.targets
        var activeTarget = this.activeTarget
        var i

        if (this.scrollHeight != scrollHeight) {
            this.refresh()
        }

        if (scrollTop >= maxScroll) {
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
        }

        if (activeTarget && scrollTop < offsets[0]) {
            this.activeTarget = null
            return this.clear()
        }

        for (i = offsets.length; i--;) {
            activeTarget != targets[i] &&
                scrollTop >= offsets[i] &&
                (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) &&
                this.activate(targets[i])
        }
    }

    ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target

        this.clear()

        var selector = this.selector +
            '[data-target="' + target + '"],' +
            this.selector + '[href="' + target + '"]'

        var active = $(selector)
            .parents('li')
            .addClass('active')

        if (active.parent('.dropdown-menu').length) {
            active = active
                .closest('li.dropdown')
                .addClass('active')
        }

        active.trigger('activate.bs.scrollspy')
    }

    ScrollSpy.prototype.clear = function() {
        $(this.selector)
            .parentsUntil(this.options.target, '.active')
            .removeClass('active')
    }


    // SCROLLSPY PLUGIN DEFINITION
    // ===========================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.scrollspy')
            var options = typeof option == 'object' && option

            if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    var old = $.fn.scrollspy

    $.fn.scrollspy = Plugin
    $.fn.scrollspy.Constructor = ScrollSpy


    // SCROLLSPY NO CONFLICT
    // =====================

    $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old
        return this
    }


    // SCROLLSPY DATA-API
    // ==================

    $(window).on('load.bs.scrollspy.data-api', function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this)
            Plugin.call($spy, $spy.data())
        })
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.6
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // TAB CLASS DEFINITION
    // ====================

    var Tab = function(element) {
        // jscs:disable requireDollarBeforejQueryAssignment
        this.element = $(element)
        // jscs:enable requireDollarBeforejQueryAssignment
    }

    Tab.VERSION = '3.3.6'

    Tab.TRANSITION_DURATION = 150

    Tab.prototype.show = function() {
        var $this = this.element
        var $ul = $this.closest('ul:not(.dropdown-menu)')
        var selector = $this.data('target')

        if (!selector) {
            selector = $this.attr('href')
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
        }

        if ($this.parent('li').hasClass('active')) return

        var $previous = $ul.find('.active:last a')
        var hideEvent = $.Event('hide.bs.tab', {
            relatedTarget: $this[0]
        })
        var showEvent = $.Event('show.bs.tab', {
            relatedTarget: $previous[0]
        })

        $previous.trigger(hideEvent)
        $this.trigger(showEvent)

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

        var $target = $(selector)

        this.activate($this.closest('li'), $ul)
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: 'hidden.bs.tab',
                relatedTarget: $this[0]
            })
            $this.trigger({
                type: 'shown.bs.tab',
                relatedTarget: $previous[0]
            })
        })
    }

    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find('> .active')
        var transition = callback &&
            $.support.transition &&
            ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

        function next() {
            $active
                .removeClass('active')
                .find('> .dropdown-menu > .active')
                .removeClass('active')
                .end()
                .find('[data-toggle="tab"]')
                .attr('aria-expanded', false)

            element
                .addClass('active')
                .find('[data-toggle="tab"]')
                .attr('aria-expanded', true)

            if (transition) {
                element[0].offsetWidth // reflow for transition
                element.addClass('in')
            } else {
                element.removeClass('fade')
            }

            if (element.parent('.dropdown-menu').length) {
                element
                    .closest('li.dropdown')
                    .addClass('active')
                    .end()
                    .find('[data-toggle="tab"]')
                    .attr('aria-expanded', true)
            }

            callback && callback()
        }

        $active.length && transition ?
            $active
            .one('bsTransitionEnd', next)
            .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
            next()

        $active.removeClass('in')
    }


    // TAB PLUGIN DEFINITION
    // =====================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.tab')

            if (!data) $this.data('bs.tab', (data = new Tab(this)))
            if (typeof option == 'string') data[option]()
        })
    }

    var old = $.fn.tab

    $.fn.tab = Plugin
    $.fn.tab.Constructor = Tab


    // TAB NO CONFLICT
    // ===============

    $.fn.tab.noConflict = function() {
        $.fn.tab = old
        return this
    }


    // TAB DATA-API
    // ============

    var clickHandler = function(e) {
        e.preventDefault()
        Plugin.call($(this), 'show')
    }

    $(document)
        .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
        .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.6
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+
function($) {
    'use strict';

    // AFFIX CLASS DEFINITION
    // ======================

    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options)

        this.$target = $(this.options.target)
            .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
            .on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this))

        this.$element = $(element)
        this.affixed = null
        this.unpin = null
        this.pinnedOffset = null

        this.checkPosition()
    }

    Affix.VERSION = '3.3.6'

    Affix.RESET = 'affix affix-top affix-bottom'

    Affix.DEFAULTS = {
        offset: 0,
        target: window
    }

    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop()
        var position = this.$element.offset()
        var targetHeight = this.$target.height()

        if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

        if (this.affixed == 'bottom') {
            if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
            return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
        }

        var initializing = this.affixed == null
        var colliderTop = initializing ? scrollTop : position.top
        var colliderHeight = initializing ? targetHeight : height

        if (offsetTop != null && scrollTop <= offsetTop) return 'top'
        if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

        return false
    }

    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset
        this.$element.removeClass(Affix.RESET).addClass('affix')
        var scrollTop = this.$target.scrollTop()
        var position = this.$element.offset()
        return (this.pinnedOffset = position.top - scrollTop)
    }

    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1)
    }

    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(':visible')) return

        var height = this.$element.height()
        var offset = this.options.offset
        var offsetTop = offset.top
        var offsetBottom = offset.bottom
        var scrollHeight = Math.max($(document).height(), $(document.body).height())

        if (typeof offset != 'object') offsetBottom = offsetTop = offset
        if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element)
        if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css('top', '')

            var affixType = 'affix' + (affix ? '-' + affix : '')
            var e = $.Event(affixType + '.bs.affix')

            this.$element.trigger(e)

            if (e.isDefaultPrevented()) return

            this.affixed = affix
            this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

            this.$element
                .removeClass(Affix.RESET)
                .addClass(affixType)
                .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
        }

        if (affix == 'bottom') {
            this.$element.offset({
                top: scrollHeight - height - offsetBottom
            })
        }
    }


    // AFFIX PLUGIN DEFINITION
    // =======================

    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
            var data = $this.data('bs.affix')
            var options = typeof option == 'object' && option

            if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    var old = $.fn.affix

    $.fn.affix = Plugin
    $.fn.affix.Constructor = Affix


    // AFFIX NO CONFLICT
    // =================

    $.fn.affix.noConflict = function() {
        $.fn.affix = old
        return this
    }


    // AFFIX DATA-API
    // ==============

    $(window).on('load', function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this)
            var data = $spy.data()

            data.offset = data.offset || {}

            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
            if (data.offsetTop != null) data.offset.top = data.offsetTop

            Plugin.call($spy, data)
        })
    })

}(jQuery);

"function" !== typeof Object.create && (Object.create = function(f) {
    function g() {}
    g.prototype = f;
    return new g
});
(function(f, g, k) {
    var l = {
        init: function(a, b) {
            this.$elem = f(b);
            this.options = f.extend({}, f.fn.owlCarousel.options, this.$elem.data(), a);
            this.userOptions = a;
            this.loadContent()
        },
        loadContent: function() {
            function a(a) {
                var d, e = "";
                if ("function" === typeof b.options.jsonSuccess) b.options.jsonSuccess.apply(this, [a]);
                else {
                    for (d in a.owl) a.owl.hasOwnProperty(d) && (e += a.owl[d].item);
                    b.$elem.html(e)
                }
                b.logIn()
            }
            var b = this,
                e;
            "function" === typeof b.options.beforeInit && b.options.beforeInit.apply(this, [b.$elem]);
            "string" === typeof b.options.jsonPath ?
                (e = b.options.jsonPath, f.getJSON(e, a)) : b.logIn()
        },
        logIn: function() {
            this.$elem.data("owl-originalStyles", this.$elem.attr("style"));
            this.$elem.data("owl-originalClasses", this.$elem.attr("class"));
            this.$elem.css({
                opacity: 0
            });
            this.orignalItems = this.options.items;
            this.checkBrowser();
            this.wrapperWidth = 0;
            this.checkVisible = null;
            this.setVars()
        },
        setVars: function() {
            if (0 === this.$elem.children().length) return !1;
            this.baseClass();
            this.eventTypes();
            this.$userItems = this.$elem.children();
            this.itemsAmount = this.$userItems.length;
            this.wrapItems();
            this.$owlItems = this.$elem.find(".owl-item");
            this.$owlWrapper = this.$elem.find(".owl-wrapper");
            this.playDirection = "next";
            this.prevItem = 0;
            this.prevArr = [0];
            this.currentItem = 0;
            this.customEvents();
            this.onStartup()
        },
        onStartup: function() {
            this.updateItems();
            this.calculateAll();
            this.buildControls();
            this.updateControls();
            this.response();
            this.moveEvents();
            this.stopOnHover();
            this.owlStatus();
            !1 !== this.options.transitionStyle && this.transitionTypes(this.options.transitionStyle);
            !0 === this.options.autoPlay &&
                (this.options.autoPlay = 5E3);
            this.play();
            this.$elem.find(".owl-wrapper").css("display", "block");
            this.$elem.is(":visible") ? this.$elem.css("opacity", 1) : this.watchVisibility();
            this.onstartup = !1;
            this.eachMoveUpdate();
            "function" === typeof this.options.afterInit && this.options.afterInit.apply(this, [this.$elem])
        },
        eachMoveUpdate: function() {
            !0 === this.options.lazyLoad && this.lazyLoad();
            !0 === this.options.autoHeight && this.autoHeight();
            this.onVisibleItems();
            "function" === typeof this.options.afterAction && this.options.afterAction.apply(this, [this.$elem])
        },
        updateVars: function() {
            "function" === typeof this.options.beforeUpdate && this.options.beforeUpdate.apply(this, [this.$elem]);
            this.watchVisibility();
            this.updateItems();
            this.calculateAll();
            this.updatePosition();
            this.updateControls();
            this.eachMoveUpdate();
            "function" === typeof this.options.afterUpdate && this.options.afterUpdate.apply(this, [this.$elem])
        },
        reload: function() {
            var a = this;
            g.setTimeout(function() {
                a.updateVars()
            }, 0)
        },
        watchVisibility: function() {
            var a = this;
            if (!1 === a.$elem.is(":visible")) a.$elem.css({
                    opacity: 0
                }),
                g.clearInterval(a.autoPlayInterval), g.clearInterval(a.checkVisible);
            else return !1;
            a.checkVisible = g.setInterval(function() {
                a.$elem.is(":visible") && (a.reload(), a.$elem.animate({
                    opacity: 1
                }, 200), g.clearInterval(a.checkVisible))
            }, 500)
        },
        wrapItems: function() {
            this.$userItems.wrapAll('<div class="owl-wrapper">').wrap('<div class="owl-item"></div>');
            this.$elem.find(".owl-wrapper").wrap('<div class="owl-wrapper-outer">');
            this.wrapperOuter = this.$elem.find(".owl-wrapper-outer");
            this.$elem.css("display", "block")
        },
        baseClass: function() {
            var a = this.$elem.hasClass(this.options.baseClass),
                b = this.$elem.hasClass(this.options.theme);
            a || this.$elem.addClass(this.options.baseClass);
            b || this.$elem.addClass(this.options.theme)
        },
        updateItems: function() {
            var a, b;
            if (!1 === this.options.responsive) return !1;
            if (!0 === this.options.singleItem) return this.options.items = this.orignalItems = 1, this.options.itemsCustom = !1, this.options.itemsDesktop = !1, this.options.itemsDesktopSmall = !1, this.options.itemsTablet = !1, this.options.itemsTabletSmall = !1, this.options.itemsMobile = !1;
            a = f(this.options.responsiveBaseWidth).width();
            a > (this.options.itemsDesktop[0] || this.orignalItems) && (this.options.items = this.orignalItems);
            if (!1 !== this.options.itemsCustom)
                for (this.options.itemsCustom.sort(function(a, b) {
                        return a[0] - b[0]
                    }), b = 0; b < this.options.itemsCustom.length; b += 1) this.options.itemsCustom[b][0] <= a && (this.options.items = this.options.itemsCustom[b][1]);
            else a <= this.options.itemsDesktop[0] && !1 !== this.options.itemsDesktop && (this.options.items = this.options.itemsDesktop[1]),
                a <= this.options.itemsDesktopSmall[0] && !1 !== this.options.itemsDesktopSmall && (this.options.items = this.options.itemsDesktopSmall[1]), a <= this.options.itemsTablet[0] && !1 !== this.options.itemsTablet && (this.options.items = this.options.itemsTablet[1]), a <= this.options.itemsTabletSmall[0] && !1 !== this.options.itemsTabletSmall && (this.options.items = this.options.itemsTabletSmall[1]), a <= this.options.itemsMobile[0] && !1 !== this.options.itemsMobile && (this.options.items = this.options.itemsMobile[1]);
            this.options.items > this.itemsAmount &&
                !0 === this.options.itemsScaleUp && (this.options.items = this.itemsAmount)
        },
        response: function() {
            var a = this,
                b, e;
            if (!0 !== a.options.responsive) return !1;
            e = f(g).width();
            a.resizer = function() {
                f(g).width() !== e && (!1 !== a.options.autoPlay && g.clearInterval(a.autoPlayInterval), g.clearTimeout(b), b = g.setTimeout(function() {
                    e = f(g).width();
                    a.updateVars()
                }, a.options.responsiveRefreshRate))
            };
            f(g).resize(a.resizer)
        },
        updatePosition: function() {
            this.jumpTo(this.currentItem);
            !1 !== this.options.autoPlay && this.checkAp()
        },
        appendItemsSizes: function() {
            var a =
                this,
                b = 0,
                e = a.itemsAmount - a.options.items;
            a.$owlItems.each(function(c) {
                var d = f(this);
                d.css({
                    width: a.itemWidth
                }).data("owl-item", Number(c));
                if (0 === c % a.options.items || c === e) c > e || (b += 1);
                d.data("owl-roundPages", b)
            })
        },
        appendWrapperSizes: function() {
            this.$owlWrapper.css({
                width: this.$owlItems.length * this.itemWidth * 2,
                left: 0
            });
            this.appendItemsSizes()
        },
        calculateAll: function() {
            this.calculateWidth();
            this.appendWrapperSizes();
            this.loops();
            this.max()
        },
        calculateWidth: function() {
            this.itemWidth = Math.round(this.$elem.width() /
                this.options.items)
        },
        max: function() {
            var a = -1 * (this.itemsAmount * this.itemWidth - this.options.items * this.itemWidth);
            this.options.items > this.itemsAmount ? this.maximumPixels = a = this.maximumItem = 0 : (this.maximumItem = this.itemsAmount - this.options.items, this.maximumPixels = a);
            return a
        },
        min: function() {
            return 0
        },
        loops: function() {
            var a = 0,
                b = 0,
                e, c;
            this.positionsInArray = [0];
            this.pagesInArray = [];
            for (e = 0; e < this.itemsAmount; e += 1) b += this.itemWidth, this.positionsInArray.push(-b), !0 === this.options.scrollPerPage && (c = f(this.$owlItems[e]),
                c = c.data("owl-roundPages"), c !== a && (this.pagesInArray[a] = this.positionsInArray[e], a = c))
        },
        buildControls: function() {
            if (!0 === this.options.navigation || !0 === this.options.pagination) this.owlControls = f('<div class="owl-controls"/>').toggleClass("clickable", !this.browser.isTouch).appendTo(this.$elem);
            !0 === this.options.pagination && this.buildPagination();
            !0 === this.options.navigation && this.buildButtons()
        },
        buildButtons: function() {
            var a = this,
                b = f('<div class="owl-buttons"/>');
            a.owlControls.append(b);
            a.buttonPrev =
                f("<div/>", {
                    "class": "owl-prev",
                    html: a.options.navigationText[0] || ""
                });
            a.buttonNext = f("<div/>", {
                "class": "owl-next",
                html: a.options.navigationText[1] || ""
            });
            b.append(a.buttonPrev).append(a.buttonNext);
            b.on("touchstart.owlControls mousedown.owlControls", 'div[class^="owl"]', function(a) {
                a.preventDefault()
            });
            b.on("touchend.owlControls mouseup.owlControls", 'div[class^="owl"]', function(b) {
                b.preventDefault();
                f(this).hasClass("owl-next") ? a.next() : a.prev()
            })
        },
        buildPagination: function() {
            var a = this;
            a.paginationWrapper =
                f('<div class="owl-pagination"/>');
            a.owlControls.append(a.paginationWrapper);
            a.paginationWrapper.on("touchend.owlControls mouseup.owlControls", ".owl-page", function(b) {
                b.preventDefault();
                Number(f(this).data("owl-page")) !== a.currentItem && a.goTo(Number(f(this).data("owl-page")), !0)
            })
        },
        updatePagination: function() {
            var a, b, e, c, d, g;
            if (!1 === this.options.pagination) return !1;
            this.paginationWrapper.html("");
            a = 0;
            b = this.itemsAmount - this.itemsAmount % this.options.items;
            for (c = 0; c < this.itemsAmount; c += 1) 0 === c % this.options.items &&
                (a += 1, b === c && (e = this.itemsAmount - this.options.items), d = f("<div/>", {
                    "class": "owl-page"
                }), g = f("<span></span>", {
                    text: !0 === this.options.paginationNumbers ? a : "",
                    "class": !0 === this.options.paginationNumbers ? "owl-numbers" : ""
                }), d.append(g), d.data("owl-page", b === c ? e : c), d.data("owl-roundPages", a), this.paginationWrapper.append(d));
            this.checkPagination()
        },
        checkPagination: function() {
            var a = this;
            if (!1 === a.options.pagination) return !1;
            a.paginationWrapper.find(".owl-page").each(function() {
                f(this).data("owl-roundPages") ===
                    f(a.$owlItems[a.currentItem]).data("owl-roundPages") && (a.paginationWrapper.find(".owl-page").removeClass("active"), f(this).addClass("active"))
            })
        },
        checkNavigation: function() {
            if (!1 === this.options.navigation) return !1;
            !1 === this.options.rewindNav && (0 === this.currentItem && 0 === this.maximumItem ? (this.buttonPrev.addClass("disabled"), this.buttonNext.addClass("disabled")) : 0 === this.currentItem && 0 !== this.maximumItem ? (this.buttonPrev.addClass("disabled"), this.buttonNext.removeClass("disabled")) : this.currentItem ===
                this.maximumItem ? (this.buttonPrev.removeClass("disabled"), this.buttonNext.addClass("disabled")) : 0 !== this.currentItem && this.currentItem !== this.maximumItem && (this.buttonPrev.removeClass("disabled"), this.buttonNext.removeClass("disabled")))
        },
        updateControls: function() {
            this.updatePagination();
            this.checkNavigation();
            this.owlControls && (this.options.items >= this.itemsAmount ? this.owlControls.hide() : this.owlControls.show())
        },
        destroyControls: function() {
            this.owlControls && this.owlControls.remove()
        },
        next: function(a) {
            if (this.isTransition) return !1;
            this.currentItem += !0 === this.options.scrollPerPage ? this.options.items : 1;
            if (this.currentItem > this.maximumItem + (!0 === this.options.scrollPerPage ? this.options.items - 1 : 0))
                if (!0 === this.options.rewindNav) this.currentItem = 0, a = "rewind";
                else return this.currentItem = this.maximumItem, !1;
            this.goTo(this.currentItem, a)
        },
        prev: function(a) {
            if (this.isTransition) return !1;
            this.currentItem = !0 === this.options.scrollPerPage && 0 < this.currentItem && this.currentItem < this.options.items ? 0 : this.currentItem - (!0 === this.options.scrollPerPage ?
                this.options.items : 1);
            if (0 > this.currentItem)
                if (!0 === this.options.rewindNav) this.currentItem = this.maximumItem, a = "rewind";
                else return this.currentItem = 0, !1;
            this.goTo(this.currentItem, a)
        },
        goTo: function(a, b, e) {
            var c = this;
            if (c.isTransition) return !1;
            "function" === typeof c.options.beforeMove && c.options.beforeMove.apply(this, [c.$elem]);
            a >= c.maximumItem ? a = c.maximumItem : 0 >= a && (a = 0);
            c.currentItem = c.owl.currentItem = a;
            if (!1 !== c.options.transitionStyle && "drag" !== e && 1 === c.options.items && !0 === c.browser.support3d) return c.swapSpeed(0), !0 === c.browser.support3d ? c.transition3d(c.positionsInArray[a]) : c.css2slide(c.positionsInArray[a], 1), c.afterGo(), c.singleItemTransition(), !1;
            a = c.positionsInArray[a];
            !0 === c.browser.support3d ? (c.isCss3Finish = !1, !0 === b ? (c.swapSpeed("paginationSpeed"), g.setTimeout(function() {
                c.isCss3Finish = !0
            }, c.options.paginationSpeed)) : "rewind" === b ? (c.swapSpeed(c.options.rewindSpeed), g.setTimeout(function() {
                c.isCss3Finish = !0
            }, c.options.rewindSpeed)) : (c.swapSpeed("slideSpeed"), g.setTimeout(function() {
                    c.isCss3Finish = !0
                },
                c.options.slideSpeed)), c.transition3d(a)) : !0 === b ? c.css2slide(a, c.options.paginationSpeed) : "rewind" === b ? c.css2slide(a, c.options.rewindSpeed) : c.css2slide(a, c.options.slideSpeed);
            c.afterGo()
        },
        jumpTo: function(a) {
            "function" === typeof this.options.beforeMove && this.options.beforeMove.apply(this, [this.$elem]);
            a >= this.maximumItem || -1 === a ? a = this.maximumItem : 0 >= a && (a = 0);
            this.swapSpeed(0);
            !0 === this.browser.support3d ? this.transition3d(this.positionsInArray[a]) : this.css2slide(this.positionsInArray[a], 1);
            this.currentItem =
                this.owl.currentItem = a;
            this.afterGo()
        },
        afterGo: function() {
            this.prevArr.push(this.currentItem);
            this.prevItem = this.owl.prevItem = this.prevArr[this.prevArr.length - 2];
            this.prevArr.shift(0);
            this.prevItem !== this.currentItem && (this.checkPagination(), this.checkNavigation(), this.eachMoveUpdate(), !1 !== this.options.autoPlay && this.checkAp());
            "function" === typeof this.options.afterMove && this.prevItem !== this.currentItem && this.options.afterMove.apply(this, [this.$elem])
        },
        stop: function() {
            this.apStatus = "stop";
            g.clearInterval(this.autoPlayInterval)
        },
        checkAp: function() {
            "stop" !== this.apStatus && this.play()
        },
        play: function() {
            var a = this;
            a.apStatus = "play";
            if (!1 === a.options.autoPlay) return !1;
            g.clearInterval(a.autoPlayInterval);
            a.autoPlayInterval = g.setInterval(function() {
                a.next(!0)
            }, a.options.autoPlay)
        },
        swapSpeed: function(a) {
            "slideSpeed" === a ? this.$owlWrapper.css(this.addCssSpeed(this.options.slideSpeed)) : "paginationSpeed" === a ? this.$owlWrapper.css(this.addCssSpeed(this.options.paginationSpeed)) : "string" !== typeof a && this.$owlWrapper.css(this.addCssSpeed(a))
        },
        addCssSpeed: function(a) {
            return {
                "-webkit-transition": "all " + a + "ms ease",
                "-moz-transition": "all " + a + "ms ease",
                "-o-transition": "all " + a + "ms ease",
                transition: "all " + a + "ms ease"
            }
        },
        removeTransition: function() {
            return {
                "-webkit-transition": "",
                "-moz-transition": "",
                "-o-transition": "",
                transition: ""
            }
        },
        doTranslate: function(a) {
            return {
                "-webkit-transform": "translate3d(" + a + "px, 0px, 0px)",
                "-moz-transform": "translate3d(" + a + "px, 0px, 0px)",
                "-o-transform": "translate3d(" + a + "px, 0px, 0px)",
                "-ms-transform": "translate3d(" +
                    a + "px, 0px, 0px)",
                transform: "translate3d(" + a + "px, 0px,0px)"
            }
        },
        transition3d: function(a) {
            this.$owlWrapper.css(this.doTranslate(a))
        },
        css2move: function(a) {
            this.$owlWrapper.css({
                left: a
            })
        },
        css2slide: function(a, b) {
            var e = this;
            e.isCssFinish = !1;
            e.$owlWrapper.stop(!0, !0).animate({
                left: a
            }, {
                duration: b || e.options.slideSpeed,
                complete: function() {
                    e.isCssFinish = !0
                }
            })
        },
        checkBrowser: function() {
            var a = k.createElement("div");
            a.style.cssText = "  -moz-transform:translate3d(0px, 0px, 0px); -ms-transform:translate3d(0px, 0px, 0px); -o-transform:translate3d(0px, 0px, 0px); -webkit-transform:translate3d(0px, 0px, 0px); transform:translate3d(0px, 0px, 0px)";
            a = a.style.cssText.match(/translate3d\(0px, 0px, 0px\)/g);
            this.browser = {
                support3d: null !== a && 1 === a.length,
                isTouch: "ontouchstart" in g || g.navigator.msMaxTouchPoints
            }
        },
        moveEvents: function() {
            if (!1 !== this.options.mouseDrag || !1 !== this.options.touchDrag) this.gestures(), this.disabledEvents()
        },
        eventTypes: function() {
            var a = ["s", "e", "x"];
            this.ev_types = {};
            !0 === this.options.mouseDrag && !0 === this.options.touchDrag ? a = ["touchstart.owl mousedown.owl", "touchmove.owl mousemove.owl", "touchend.owl touchcancel.owl mouseup.owl"] :
                !1 === this.options.mouseDrag && !0 === this.options.touchDrag ? a = ["touchstart.owl", "touchmove.owl", "touchend.owl touchcancel.owl"] : !0 === this.options.mouseDrag && !1 === this.options.touchDrag && (a = ["mousedown.owl", "mousemove.owl", "mouseup.owl"]);
            this.ev_types.start = a[0];
            this.ev_types.move = a[1];
            this.ev_types.end = a[2]
        },
        disabledEvents: function() {
            this.$elem.on("dragstart.owl", function(a) {
                a.preventDefault()
            });
            this.$elem.on("mousedown.disableTextSelect", function(a) {
                return f(a.target).is("input, textarea, select, option")
            })
        },
        gestures: function() {
            function a(a) {
                if (void 0 !== a.touches) return {
                    x: a.touches[0].pageX,
                    y: a.touches[0].pageY
                };
                if (void 0 === a.touches) {
                    if (void 0 !== a.pageX) return {
                        x: a.pageX,
                        y: a.pageY
                    };
                    if (void 0 === a.pageX) return {
                        x: a.clientX,
                        y: a.clientY
                    }
                }
            }

            function b(a) {
                "on" === a ? (f(k).on(d.ev_types.move, e), f(k).on(d.ev_types.end, c)) : "off" === a && (f(k).off(d.ev_types.move), f(k).off(d.ev_types.end))
            }

            function e(b) {
                b = b.originalEvent || b || g.event;
                d.newPosX = a(b).x - h.offsetX;
                d.newPosY = a(b).y - h.offsetY;
                d.newRelativeX = d.newPosX - h.relativePos;
                "function" === typeof d.options.startDragging && !0 !== h.dragging && 0 !== d.newRelativeX && (h.dragging = !0, d.options.startDragging.apply(d, [d.$elem]));
                (8 < d.newRelativeX || -8 > d.newRelativeX) && !0 === d.browser.isTouch && (void 0 !== b.preventDefault ? b.preventDefault() : b.returnValue = !1, h.sliding = !0);
                (10 < d.newPosY || -10 > d.newPosY) && !1 === h.sliding && f(k).off("touchmove.owl");
                d.newPosX = Math.max(Math.min(d.newPosX, d.newRelativeX / 5), d.maximumPixels + d.newRelativeX / 5);
                !0 === d.browser.support3d ? d.transition3d(d.newPosX) : d.css2move(d.newPosX)
            }

            function c(a) {
                a = a.originalEvent || a || g.event;
                var c;
                a.target = a.target || a.srcElement;
                h.dragging = !1;
                !0 !== d.browser.isTouch && d.$owlWrapper.removeClass("grabbing");
                d.dragDirection = 0 > d.newRelativeX ? d.owl.dragDirection = "left" : d.owl.dragDirection = "right";
                0 !== d.newRelativeX && (c = d.getNewPosition(), d.goTo(c, !1, "drag"), h.targetElement === a.target && !0 !== d.browser.isTouch && (f(a.target).on("click.disable", function(a) {
                        a.stopImmediatePropagation();
                        a.stopPropagation();
                        a.preventDefault();
                        f(a.target).off("click.disable")
                    }),
                    a = f._data(a.target, "events").click, c = a.pop(), a.splice(0, 0, c)));
                b("off")
            }
            var d = this,
                h = {
                    offsetX: 0,
                    offsetY: 0,
                    baseElWidth: 0,
                    relativePos: 0,
                    position: null,
                    minSwipe: null,
                    maxSwipe: null,
                    sliding: null,
                    dargging: null,
                    targetElement: null
                };
            d.isCssFinish = !0;
            d.$elem.on(d.ev_types.start, ".owl-wrapper", function(c) {
                c = c.originalEvent || c || g.event;
                var e;
                if (3 === c.which) return !1;
                if (!(d.itemsAmount <= d.options.items)) {
                    if (!1 === d.isCssFinish && !d.options.dragBeforeAnimFinish || !1 === d.isCss3Finish && !d.options.dragBeforeAnimFinish) return !1;
                    !1 !== d.options.autoPlay && g.clearInterval(d.autoPlayInterval);
                    !0 === d.browser.isTouch || d.$owlWrapper.hasClass("grabbing") || d.$owlWrapper.addClass("grabbing");
                    d.newPosX = 0;
                    d.newRelativeX = 0;
                    f(this).css(d.removeTransition());
                    e = f(this).position();
                    h.relativePos = e.left;
                    h.offsetX = a(c).x - e.left;
                    h.offsetY = a(c).y - e.top;
                    b("on");
                    h.sliding = !1;
                    h.targetElement = c.target || c.srcElement
                }
            })
        },
        getNewPosition: function() {
            var a = this.closestItem();
            a > this.maximumItem ? a = this.currentItem = this.maximumItem : 0 <= this.newPosX && (this.currentItem =
                a = 0);
            return a
        },
        closestItem: function() {
            var a = this,
                b = !0 === a.options.scrollPerPage ? a.pagesInArray : a.positionsInArray,
                e = a.newPosX,
                c = null;
            f.each(b, function(d, g) {
                e - a.itemWidth / 20 > b[d + 1] && e - a.itemWidth / 20 < g && "left" === a.moveDirection() ? (c = g, a.currentItem = !0 === a.options.scrollPerPage ? f.inArray(c, a.positionsInArray) : d) : e + a.itemWidth / 20 < g && e + a.itemWidth / 20 > (b[d + 1] || b[d] - a.itemWidth) && "right" === a.moveDirection() && (!0 === a.options.scrollPerPage ? (c = b[d + 1] || b[b.length - 1], a.currentItem = f.inArray(c, a.positionsInArray)) :
                    (c = b[d + 1], a.currentItem = d + 1))
            });
            return a.currentItem
        },
        moveDirection: function() {
            var a;
            0 > this.newRelativeX ? (a = "right", this.playDirection = "next") : (a = "left", this.playDirection = "prev");
            return a
        },
        customEvents: function() {
            var a = this;
            a.$elem.on("owl.next", function() {
                a.next()
            });
            a.$elem.on("owl.prev", function() {
                a.prev()
            });
            a.$elem.on("owl.play", function(b, e) {
                a.options.autoPlay = e;
                a.play();
                a.hoverStatus = "play"
            });
            a.$elem.on("owl.stop", function() {
                a.stop();
                a.hoverStatus = "stop"
            });
            a.$elem.on("owl.goTo", function(b, e) {
                a.goTo(e)
            });
            a.$elem.on("owl.jumpTo", function(b, e) {
                a.jumpTo(e)
            })
        },
        stopOnHover: function() {
            var a = this;
            !0 === a.options.stopOnHover && !0 !== a.browser.isTouch && !1 !== a.options.autoPlay && (a.$elem.on("mouseover", function() {
                a.stop()
            }), a.$elem.on("mouseout", function() {
                "stop" !== a.hoverStatus && a.play()
            }))
        },
        lazyLoad: function() {
            var a, b, e, c, d;
            if (!1 === this.options.lazyLoad) return !1;
            for (a = 0; a < this.itemsAmount; a += 1) b = f(this.$owlItems[a]), "loaded" !== b.data("owl-loaded") && (e = b.data("owl-item"), c = b.find(".lazyOwl"), "string" !== typeof c.data("src") ?
                b.data("owl-loaded", "loaded") : (void 0 === b.data("owl-loaded") && (c.hide(), b.addClass("loading").data("owl-loaded", "checked")), (d = !0 === this.options.lazyFollow ? e >= this.currentItem : !0) && e < this.currentItem + this.options.items && c.length && this.lazyPreload(b, c)))
        },
        lazyPreload: function(a, b) {
            function e() {
                a.data("owl-loaded", "loaded").removeClass("loading");
                b.removeAttr("data-src");
                "fade" === d.options.lazyEffect ? b.fadeIn(400) : b.show();
                "function" === typeof d.options.afterLazyLoad && d.options.afterLazyLoad.apply(this, [d.$elem])
            }

            function c() {
                f += 1;
                d.completeImg(b.get(0)) || !0 === k ? e() : 100 >= f ? g.setTimeout(c, 100) : e()
            }
            var d = this,
                f = 0,
                k;
            "DIV" === b.prop("tagName") ? (b.css("background-image", "url(" + b.data("src") + ")"), k = !0) : b[0].src = b.data("src");
            c()
        },
        autoHeight: function() {
            function a() {
                var a = f(e.$owlItems[e.currentItem]).height();
                e.wrapperOuter.css("height", a + "px");
                e.wrapperOuter.hasClass("autoHeight") || g.setTimeout(function() {
                    e.wrapperOuter.addClass("autoHeight")
                }, 0)
            }

            function b() {
                d += 1;
                e.completeImg(c.get(0)) ? a() : 100 >= d ? g.setTimeout(b,
                    100) : e.wrapperOuter.css("height", "")
            }
            var e = this,
                c = f(e.$owlItems[e.currentItem]).find("img"),
                d;
            void 0 !== c.get(0) ? (d = 0, b()) : a()
        },
        completeImg: function(a) {
            return !a.complete || "undefined" !== typeof a.naturalWidth && 0 === a.naturalWidth ? !1 : !0
        },
        onVisibleItems: function() {
            var a;
            !0 === this.options.addClassActive && this.$owlItems.removeClass("active");
            this.visibleItems = [];
            for (a = this.currentItem; a < this.currentItem + this.options.items; a += 1) this.visibleItems.push(a), !0 === this.options.addClassActive && f(this.$owlItems[a]).addClass("active");
            this.owl.visibleItems = this.visibleItems
        },
        transitionTypes: function(a) {
            this.outClass = "owl-" + a + "-out";
            this.inClass = "owl-" + a + "-in"
        },
        singleItemTransition: function() {
            var a = this,
                b = a.outClass,
                e = a.inClass,
                c = a.$owlItems.eq(a.currentItem),
                d = a.$owlItems.eq(a.prevItem),
                f = Math.abs(a.positionsInArray[a.currentItem]) + a.positionsInArray[a.prevItem],
                g = Math.abs(a.positionsInArray[a.currentItem]) + a.itemWidth / 2;
            a.isTransition = !0;
            a.$owlWrapper.addClass("owl-origin").css({
                "-webkit-transform-origin": g + "px",
                "-moz-perspective-origin": g +
                    "px",
                "perspective-origin": g + "px"
            });
            d.css({
                position: "relative",
                left: f + "px"
            }).addClass(b).on("webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend", function() {
                a.endPrev = !0;
                d.off("webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend");
                a.clearTransStyle(d, b)
            });
            c.addClass(e).on("webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend", function() {
                a.endCurrent = !0;
                c.off("webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend");
                a.clearTransStyle(c, e)
            })
        },
        clearTransStyle: function(a,
            b) {
            a.css({
                position: "",
                left: ""
            }).removeClass(b);
            this.endPrev && this.endCurrent && (this.$owlWrapper.removeClass("owl-origin"), this.isTransition = this.endCurrent = this.endPrev = !1)
        },
        owlStatus: function() {
            this.owl = {
                userOptions: this.userOptions,
                baseElement: this.$elem,
                userItems: this.$userItems,
                owlItems: this.$owlItems,
                currentItem: this.currentItem,
                prevItem: this.prevItem,
                visibleItems: this.visibleItems,
                isTouch: this.browser.isTouch,
                browser: this.browser,
                dragDirection: this.dragDirection
            }
        },
        clearEvents: function() {
            this.$elem.off(".owl owl mousedown.disableTextSelect");
            f(k).off(".owl owl");
            f(g).off("resize", this.resizer)
        },
        unWrap: function() {
            0 !== this.$elem.children().length && (this.$owlWrapper.unwrap(), this.$userItems.unwrap().unwrap(), this.owlControls && this.owlControls.remove());
            this.clearEvents();
            this.$elem.attr("style", this.$elem.data("owl-originalStyles") || "").attr("class", this.$elem.data("owl-originalClasses"))
        },
        destroy: function() {
            this.stop();
            g.clearInterval(this.checkVisible);
            this.unWrap();
            this.$elem.removeData()
        },
        reinit: function(a) {
            a = f.extend({}, this.userOptions,
                a);
            this.unWrap();
            this.init(a, this.$elem)
        },
        addItem: function(a, b) {
            var e;
            if (!a) return !1;
            if (0 === this.$elem.children().length) return this.$elem.append(a), this.setVars(), !1;
            this.unWrap();
            e = void 0 === b || -1 === b ? -1 : b;
            e >= this.$userItems.length || -1 === e ? this.$userItems.eq(-1).after(a) : this.$userItems.eq(e).before(a);
            this.setVars()
        },
        removeItem: function(a) {
            if (0 === this.$elem.children().length) return !1;
            a = void 0 === a || -1 === a ? -1 : a;
            this.unWrap();
            this.$userItems.eq(a).remove();
            this.setVars()
        }
    };
    f.fn.owlCarousel = function(a) {
        return this.each(function() {
            if (!0 ===
                f(this).data("owl-init")) return !1;
            f(this).data("owl-init", !0);
            var b = Object.create(l);
            b.init(a, this);
            f.data(this, "owlCarousel", b)
        })
    };
    f.fn.owlCarousel.options = {
        items: 5,
        itemsCustom: !1,
        itemsDesktop: [1199, 4],
        itemsDesktopSmall: [979, 3],
        itemsTablet: [768, 2],
        itemsTabletSmall: !1,
        itemsMobile: [479, 1],
        singleItem: !1,
        itemsScaleUp: !1,
        slideSpeed: 200,
        paginationSpeed: 800,
        rewindSpeed: 1E3,
        autoPlay: !1,
        stopOnHover: !1,
        navigation: !1,
        navigationText: ["prev", "next"],
        rewindNav: !0,
        scrollPerPage: !1,
        pagination: !0,
        paginationNumbers: !1,
        responsive: !0,
        responsiveRefreshRate: 200,
        responsiveBaseWidth: g,
        baseClass: "owl-carousel",
        theme: "owl-theme",
        lazyLoad: !1,
        lazyFollow: !0,
        lazyEffect: "fade",
        autoHeight: !1,
        jsonPath: !1,
        jsonSuccess: !1,
        dragBeforeAnimFinish: !0,
        mouseDrag: !0,
        touchDrag: !0,
        addClassActive: !1,
        transitionStyle: !1,
        beforeUpdate: !1,
        afterUpdate: !1,
        beforeInit: !1,
        afterInit: !1,
        beforeMove: !1,
        afterMove: !1,
        afterAction: !1,
        startDragging: !1,
        afterLazyLoad: !1
    }
})(jQuery, window, document);
/**
 * stacktable.js
 * Author & copyright (c) 2012: John Polacek
 * CardTable by: Justin McNally (2015)
 * MIT license
 *
 * Page: http://johnpolacek.github.com/stacktable.js
 * Repo: https://github.com/johnpolacek/stacktable.js/
 *
 * jQuery plugin for stacking tables on small screens
 * Requires jQuery version 1.7 or above
 *
 */
;
(function($) {
    $.fn.cardtable = function(options) {
        var $tables = this,
            defaults = {
                headIndex: 0
            },
            settings = $.extend({}, defaults, options),
            headIndex;

        // checking the "headIndex" option presence... or defaults it to 0
        if (options && options.headIndex)
            headIndex = options.headIndex;
        else
            headIndex = 0;

        return $tables.each(function() {
            var $table = $(this);
            if ($table.hasClass('stacktable')) {
                return;
            }
            var table_css = $(this).prop('class');
            var $stacktable = $('<div></div>');
            if (typeof settings.myClass !== 'undefined') $stacktable.addClass(settings.myClass);
            var markup = '';
            var $caption, $topRow, headMarkup, bodyMarkup, tr_class;

            $table.addClass('stacktable large-only');

            $caption = $table.find(">caption").clone();
            $topRow = $table.find('>thead>tr,>tbody>tr,>tfoot>tr,>tr').eq(0);

            // avoid duplication when paginating
            $table.siblings().filter('.small-only').remove();

            // using rowIndex and cellIndex in order to reduce ambiguity
            $table.find('>tbody>tr').each(function() {

                // declaring headMarkup and bodyMarkup, to be used for separately head and body of single records
                headMarkup = '';
                bodyMarkup = '';
                tr_class = $(this).prop('class');
                // for the first row, "headIndex" cell is the head of the table
                // for the other rows, put the "headIndex" cell as the head for that row
                // then iterate through the key/values
                $(this).find('>td,>th').each(function(cellIndex) {
                    if ($(this).html() !== '') {
                        bodyMarkup += '<tr class="' + tr_class + '">';
                        if ($topRow.find('>td,>th').eq(cellIndex).html()) {
                            bodyMarkup += '<td class="st-key">' + $topRow.find('>td,>th').eq(cellIndex).html() + '</td>';
                        } else {
                            bodyMarkup += '<td class="st-key"></td>';
                        }
                        bodyMarkup += '<td class="st-val ' + $(this).prop('class') + '">' + $(this).html() + '</td>';
                        bodyMarkup += '</tr>';
                    }
                });

                markup += '<table class=" ' + table_css + ' stacktable small-only"><tbody>' + headMarkup + bodyMarkup + '</tbody></table>';
            });

            $table.find('>tfoot>tr>td').each(function(rowIndex, value) {
                if ($.trim($(value).text()) !== '') {
                    markup += '<table class="' + table_css + ' stacktable small-only"><tbody><tr><td>' + $(value).html() + '</td></tr></tbody></table>';
                }
            });

            $stacktable.prepend($caption);
            $stacktable.append($(markup));
            $table.before($stacktable);
        });
    };

    $.fn.stacktable = function(options) {
        var $tables = this,
            defaults = {
                headIndex: 0,
                displayHeader: true
            },
            settings = $.extend({}, defaults, options),
            headIndex;

        // checking the "headIndex" option presence... or defaults it to 0
        if (options && options.headIndex)
            headIndex = options.headIndex;
        else
            headIndex = 0;

        return $tables.each(function() {
            var table_css = $(this).prop('class');
            var $stacktable = $('<table class="' + table_css + ' stacktable small-only"><tbody></tbody></table>');
            if (typeof settings.myClass !== 'undefined') $stacktable.addClass(settings.myClass);
            var markup = '';
            var $table, $caption, $topRow, headMarkup, bodyMarkup, tr_class, displayHeader;

            $table = $(this);
            $table.addClass('stacktable large-only');
            $caption = $table.find(">caption").clone();
            $topRow = $table.find('>thead>tr,>tbody>tr,>tfoot>tr').eq(0);

            displayHeader = $table.data('display-header') === undefined ? settings.displayHeader : $table.data('display-header');

            // using rowIndex and cellIndex in order to reduce ambiguity
            $table.find('>tbody>tr, >thead>tr').each(function(rowIndex) {

                // declaring headMarkup and bodyMarkup, to be used for separately head and body of single records
                headMarkup = '';
                bodyMarkup = '';
                tr_class = $(this).prop('class');

                // for the first row, "headIndex" cell is the head of the table
                if (rowIndex === 0) {
                    // the main heading goes into the markup variable
                    if (displayHeader) {
                        markup += '<tr class=" ' + tr_class + ' "><th class="st-head-row st-head-row-main" colspan="2">' + $(this).find('>th,>td').eq(headIndex).html() + '</th></tr>';
                    }
                } else {
                    // for the other rows, put the "headIndex" cell as the head for that row
                    // then iterate through the key/values
                    $(this).find('>td,>th').each(function(cellIndex) {
                        if (cellIndex === headIndex) {
                            headMarkup = '<tr class="' + tr_class + '"><th class="st-head-row" colspan="2">' + $(this).html() + '</th></tr>';
                        } else {
                            if ($(this).html() !== '') {
                                bodyMarkup += '<tr class="' + tr_class + '">';
                                if ($topRow.find('>td,>th').eq(cellIndex).html()) {
                                    bodyMarkup += '<td class="st-key">' + $topRow.find('>td,>th').eq(cellIndex).html() + '</td>';
                                } else {
                                    bodyMarkup += '<td class="st-key"></td>';
                                }
                                bodyMarkup += '<td class="st-val ' + $(this).prop('class') + '">' + $(this).html() + '</td>';
                                bodyMarkup += '</tr>';
                            }
                        }
                    });

                    markup += headMarkup + bodyMarkup;
                }
            });

            $stacktable.prepend($caption);
            $stacktable.append($(markup));
            $table.before($stacktable);
        });
    };

    $.fn.stackcolumns = function(options) {
        var $tables = this,
            defaults = {},
            settings = $.extend({}, defaults, options);

        return $tables.each(function() {
            var $table = $(this);
            var $caption = $table.find(">caption").clone();
            var num_cols = $table.find('>thead>tr,>tbody>tr,>tfoot>tr').eq(0).find('>td,>th').length; //first table <tr> must not contain colspans, or add sum(colspan-1) here.
            if (num_cols < 3) //stackcolumns has no effect on tables with less than 3 columns
                return;

            var $stackcolumns = $('<table class="stacktable small-only"></table>');
            if (typeof settings.myClass !== 'undefined') $stackcolumns.addClass(settings.myClass);
            $table.addClass('stacktable large-only');
            var tb = $('<tbody></tbody>');
            var col_i = 1; //col index starts at 0 -> start copy at second column.

            while (col_i < num_cols) {
                $table.find('>thead>tr,>tbody>tr,>tfoot>tr').each(function(index) {
                    var tem = $('<tr></tr>'); // todo opt. copy styles of $this; todo check if parent is thead or tfoot to handle accordingly
                    if (index === 0) tem.addClass("st-head-row st-head-row-main");
                    var first = $(this).find('>td,>th').eq(0).clone().addClass("st-key");
                    var target = col_i;
                    // if colspan apply, recompute target for second cell.
                    if ($(this).find("*[colspan]").length) {
                        var i = 0;
                        $(this).find('>td,>th').each(function() {
                            var cs = $(this).attr("colspan");
                            if (cs) {
                                cs = parseInt(cs, 10);
                                target -= cs - 1;
                                if ((i + cs) > (col_i)) //out of current bounds
                                    target += i + cs - col_i - 1;
                                i += cs;
                            } else {
                                i++;
                            }

                            if (i > col_i)
                                return false; //target is set; break.
                        });
                    }
                    var second = $(this).find('>td,>th').eq(target).clone().addClass("st-val").removeAttr("colspan");
                    tem.append(first, second);
                    tb.append(tem);
                });
                ++col_i;
            }

            $stackcolumns.append($(tb));
            $stackcolumns.prepend($caption);
            $table.before($stackcolumns);
        });
    };

}(jQuery));

/* This is the FedEx.com link component javascript file.
 The global FDX object must already be defined.

 Author: joey.dukeminier@vml.com
 Created: 2017-03-30
 */
if (!FDX) {
    var FDX = {};
}

FDX.LINK = {
    linkClass: "fxg-link",
    secureLinkClass: "fxg-secure--link",
    secureAdvLinkClass: "fxg-secure-adv--link",
    isShippingCall: false,
    targetRedirect: "fxg-target-redirect--link",
    adminUrl: "",
    altUrl: "",
    mBoxId: "",
    clientID: "",
    fclpage: "",
    flag: false,


    addTelelphoneLink: function(elem, tel) {
        $(elem).attr('href', tel);
    },
    checkSecureLink: function(elem) {
        if (FDX.SESSION.userAuthenticated || FDX.SESSION.targetRedirectAuth) {
            window.history.pushState({
                url: "" + window.location.href + ""
            }, '', window.location.href);
            window.open($(elem).attr("href"), $(elem).attr("target"), '', true);
        } else {

            if (FDX.DATALAYER.page.pageInfo.useWLGN === "true") {
                sessionStorage.setItem("secureLink", $(elem).attr("href"));
                window.open(FDX.DATALAYER.page.pageInfo.wlgnURL, '_self', '', true);
            } else {
                //console.log("not logged");
                $('.' + FDX.DROPDOWN.dropdownClass).trigger("click");
                // FDX.LOGIN.setLoginResource("window.open('"+$(elem).attr("href")+"','"+$(elem).attr("target")+"','',true)");
                FDX.LOGIN.setLoginResource($(elem), 'OPEN')

                $('input#NavLoginUserId').focus();
                if ($(document).width() <= FDX.BREAKPOINTS.TabletMediaQuery) {
                    // console.log('Focus is not happening123');

                    $('.fxg-user-options__option.fxg-user-options__sign-in').addClass('fxg-dropdown__item--open');
                    $('input#NavLoginUserId').focus();
                }
            }
        }
    },
    checkTargetRedirect: function(elem) {
        var isWlgnLink = FDX.DATALAYER.page.pageInfo.useWLGN;
        if (FDX.LINK.clientID == "LSHP") {
            FDX.LINK.isShippingCall = true;
        }
        //code changes for 528073 : Modify AEM code to call the new JS
        FDX.SHIPPINGROUTING.setSecureClientId(true);
        FDX.SHIPPINGROUTING.setPaths(FDX.LINK.adminUrl, FDX.LINK.altUrl, FDX.LINK.mBoxId, FDX.LINK.fclpage, FDX.LINK.clientID);
        if (FDX.SESSION.targetRedirectAuth || FDX.SESSION.userAuthenticated) {
            //528073 : Modify AEM code to call the new JS
            FDX.SHIPPINGROUTING.doAPIShipingUserisLoggedIn(elem);
        } else {
            if (isWlgnLink === 'true') {
                //WLGN enabled
                window.open(FDX.DATALAYER.page.pageInfo.wlgnURL, '_self', '', true);
            } else {
                $('.' + FDX.DROPDOWN.dropdownClass).trigger("click");

                // FDX.LOGIN.setLoginResource("window.open('" + $(elem).attr("href") + "','" + $(elem).attr("target") + "','',true)");
                FDX.LOGIN.setLoginResource($(elem), 'OPEN')

                $('input#NavLoginUserId').focus();
                if ($(document).width() <= FDX.BREAKPOINTS.TabletMediaQuery) {
                    // console.log('Focus is not happening123');
                    $('.fxg-user-options__option.fxg-user-options__sign-in').addClass('fxg-dropdown__item--open');
                    $('input#NavLoginUserId').focus();

                }
            }
        }
    },
    checkSecureExternalLink: function(e, elem) {
        e.preventDefault();
        if ($(elem).hasClass(FDX.LINK.secureAdvLinkClass)) {
            FDX.LINK.checkSecureLink(elem);
        } else {
            window.history.pushState({
                url: "" + window.location.href + ""
            }, '', window.location.href);
            window.open($(elem).attr("href"), $(elem).attr("target"), '', true);
            if ($(document).width() <= FDX.BREAKPOINTS.TabletMediaQuery) {
                // console.log('Focus is not happening123');
                $('.fxg-user-options__option.fxg-user-options__sign-in').addClass('fxg-dropdown__item--open');
                $('input#NavLoginUserId').focus();

            }
        }
    },
    checkAccordionLink: function(e, elem) {
        e.preventDefault();
        var targetId = $(elem).attr("targetid");
        if (targetId)
            sessionStorage.setItem('target', targetId);
        //window.open($(elem).attr("href"),$(elem).attr("targetid"),'',true);
    },
    checkSecureLinkSubmit: function(e, elem, formId) {
        var $form = $('form#' + formId);
        e.preventDefault();
        if ($(elem).hasClass(FDX.LINK.secureAdvLinkClass)) {
            if (FDX.SESSION.userAuthenticated) {
                $form[0].submit();
            } else {
                $('.' + FDX.DROPDOWN.dropdownClass).trigger("click");

                //FDX.LOGIN.setLoginResource("$('form#"+formId+"')[0].submit()");
                FDX.LOGIN.setLoginResource($form, "SUBMIT");
            }
        } else {
            $form[0].submit();
        }
    },
    checkSearchSecureLink: function(e, elem, keyword, sortOrder, tagIds, businesUnitTagIds) {
        e.preventDefault();
        if ($(elem).hasClass(FDX.LINK.secureAdvLinkClass)) {
            enhancedLinkSearchparam(keyword, sortOrder);
            enhancedLinkTags(tagIds, 'Photos', businesUnitTagIds);
            if (FDX.SESSION.userAuthenticated) {
                window.history.pushState({
                    url: "" + window.location.href + ""
                }, '', window.location.href);
                window.open($(elem).attr("href"), $(elem).attr("target"), '', true);
            } else {
                $('.' + FDX.DROPDOWN.dropdownClass).trigger("click");
                // FDX.LOGIN.setLoginResource("window.open('"+$(elem).attr("href")+"','"+$(elem).attr("target")+"','',true)");
                FDX.LOGIN.setLoginResource($(elem), 'OPEN')
            }
        } else {
            enhancedLinkSearchparam(keyword, sortOrder);
            enhancedLinkTags(tagIds, 'Photos', businesUnitTagIds);
            window.history.pushState({
                url: "" + window.location.href + ""
            }, '', window.location.href);
            window.open($(elem).attr("href"), $(elem).attr("target"), '', true);
        }
    },

    getTargetAttributes: function(e) {
        var targetinfo = e.target.dataset.target.split(",");
        var ev1 = {};
        for (var x = 0; x < targetinfo.length; x++) {
            var kv1 = targetinfo[x].split("|");
            if (kv1.length == 2) {
                var b = kv1[1];
                switch (kv1[0]) {
                    case "adminLinkPath":
                        FDX.LINK.adminUrl = b;
                        break;
                    case "alternateLinkPath":
                        FDX.LINK.altUrl = b;
                        break;
                    case "mboxId":
                        FDX.LINK.mBoxId = b;
                        break;
                    case "fclaRegPage":
                        FDX.LINK.fclpage = b;
                        break;
                    case "clientId":
                        FDX.LINK.clientID = b;
                        break;
                }
            }
        }
    },
    showHideLockIcon: function() {

        if (typeof FDX.CLIENTLOGIN.userDetails === 'undefined') {

            $(".lock-hide").show();

        } else {

            $(".lock-hide").hide();


        }
        /*    if(typeof FDX.CLIENTLOGIN.userDetails === 'undefined'){
			 $('.fxg-nav .link.link-lock').each(function(){
                 $(this).children('.fxg-link__lock').css('display','block');
                 $(this).children('.fxg-link').addClass('fxg-link-lock');
             });
        }else{
                $('.link.link-lock').each(function(){
                  $(this).children('.fxg-link__lock').css('display','none');
                  $(this).children('.fxg-link').removeClass('fxg-link-lock');
              });
        }*/
    }
};


$(document).ready(function() {
    // Loop over every a to determine if it has a data-tel attribute.
    $('a').each(function() {
        if ($(this).attr('data-tel') != null && $(this).attr('data-tel') != undefined && $(this).attr('data-tel') != "") {
            FDX.LINK.addTelelphoneLink(this, $(this).attr('data-tel'));
        }

        if ($(this).parent().hasClass('link-lock') && $(this).parents().hasClass('fxg-dropdown__sub-menu')) {
            $(this).parent().attr('tabindex', 0);
            $(this).attr('tabindex', -1);
        }

    });
    $("." + FDX.LINK.secureLinkClass + ",." + FDX.LINK.targetRedirect).on('click', function(e) {
        e.preventDefault();
        if (typeof(e.target.dataset.target) !== typeof undefined && e.target.dataset.target !== null) {
            // console.log("-- Target Info: " + e.target.dataset.target);
            FDX.LINK.getTargetAttributes(e);
        }
        if (FDX.LINK.clientID == "LSHP" && $(this).hasClass(FDX.LINK.targetRedirect)) {
            FDX.LINK.checkTargetRedirect(this);
        } else {
            FDX.LINK.checkSecureLink(this);
        }
    });

    $('.fxg-user-options__sign-in-text, .fxg-user-options__icon').click(function() {
        FDX.LINK.isShippingCall = false;
    });

    //storing the targetId of accordion on click of link
    $(".fxg-link").click(function() {
        var targetId = $(this).attr("targetid");
        if (targetId) {
            sessionStorage.setItem('target', targetId);
        }
    });

    $('input#NavLoginUserId').focus();
    $('.fxg-link__lock svg').attr('aria-hidden', 'true');

});
/**
 * Loader Service
 *
 * Load and initialize components and services
 */

(function($, _, window) {
    window.FDX.services.loader = (function() {

        /**
         * Init service
         *
         * @public
         */
        function init() {}

        /**
         * Init services
         *
         * @public
         */
        function initServices() {

            // iterate through all services and initialize them
            for (var i in FDX.services) {
                FDX.services[i].init();
            }
        }

        /**
         * Init components
         *
         * @public
         */
        function initComponents() {

            // iterate through all components and create instances for each component
            for (var i in FDX.components) {
                FDX.components[i].createInstances();
            }
        }

        // return service
        return {
            init: init,
            initServices: initServices,
            initComponents: initComponents
        }

    })();


})(window.jQuery, window._, window);
/**
 * Session Service
 *
 * Retrieving and setting values of user session and cookies
 */

(function($, _, window) {
    window.FDX.services.session = (function() {

        /**
         * Init service
         *
         * @public
         */
        function init() {}

        /**
         * Get cookie
         *
         * @public
         * @param {string} name - cookie name
         * @return {string} cookie value
         */
        function getCookie(name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        /**
         * Set cookie
         *
         * @public
         * @param {string} name - cookie name
         * @param {string} value - cookie value
         * @param {number} days - number of days whereafter cookie expires
         */
        function setCookie(name, value, days) {
            if (days) {
                var date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                var expires = "; expires=" + date.toGMTString();
            } else var expires = "";

            if (typeof(value) != "undefined" && value != "") {
                document.cookie = name + "=" + value + expires + "; path=/";
            }
        }

        // return service
        return {
            init: init,
            getCookie: getCookie,
            setCookie: setCookie
        }

    })();


})(window.jQuery, window._, window);
/**
 * Utility Service
 *
 * Diverse utilities
 */

(function($, _, $services) {
    window.FDX.services.utils = (function() {

        var renderDateTimeOptions = {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            hour12: true
        };

        var textarea;

        /**
         * Init service
         *
         * @public
         */
        function init() {}

        /**
         * Get notifications data from the server for a specific type
         *
         * @public
         * @param {Object} config - key/value pair
         * @return {string[]} array of classes
         */
        function responsiveClasses(config) {
            var classes = [];
            if (config.hideOnDesktop === 'on') classes.push('fxg-desktop--hide');
            if (config.hideOnTablet === 'on') classes.push('fxg-tablet--hide');
            if (config.hideOnMobile === 'on') classes.push('fxg-mobile--hide');
            return classes;
        }

        /**
         * Get device type
         *
         * @public
         * @return {string} device type ( "IOS" | "ANDROID" | "DESKTOP" )
         */
        function deviceType() {
            if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {
                return 'IOS';
            }

            if (/Android/i.test(window.navigator.userAgent)) {
                return 'ANDROID';
            }

            return 'DESKTOP'
        }

        /**
         * Render date time for current locale
         *
         * @public
         * @param {Object|number} date - Date object/milliseconds
         * @param {Object} options - key/value pair
         * @return {string} formatted date time
         */
        function formatDateTime(date, options) {

            // convert date if needed
            if (typeof(date) === 'number') date = new Date(date);

            // get locale and options
            var locale = $services.session.getCookie('fdx_locale') || 'en_US';
            var locale = locale.replace('_', '-');
            options = $.extend({}, renderDateTimeOptions, options);

            // format
            var output = new Intl.DateTimeFormat(locale, options).format(date);
            return output;
        }

        /**
         * Decode HTML entities back to plain string
         *
         * @public
         * @param {string} html - html containing encoded entities
         * @return {string} decoded string
         */
        function decodeHTMLEntities(html) {
            if (!textarea) textarea = document.createElement('textarea');
            textarea.innerHTML = html;
            return textarea.value;
        }

        // return service
        return {
            init: init,
            responsiveClasses: responsiveClasses,
            deviceType: deviceType,
            formatDateTime: formatDateTime,
            decodeHTMLEntities: decodeHTMLEntities
        }

    })();


})(
    jQuery,
    _,
    FDX.services
);
/**
 * Analytics Service
 *
 * This service supports new GDL analytics API and in case of no GDL API available
 * then it fallbacks to Adobe analytics service.
 */

(function($, window, $fdx) {

    window.FDX.services.analytics = (function() {

        /**
         * Init service
         *
         * @public
         */
        function init() {}

        /**
         * Adobe analytics (FDX.DTM)
         *
         * @param {object} payload - analytics data required for adobe analytics.
         * @private
         */
        function pushDTM(payload) {
            // Adobe analytics payload format
            var dtmPayload = {
                type: '', // button or link
                event: '', // Optional, which is defined by Data analyst with a specific eventname 'event73'.
                analyticsText: '', // analytics data
                href: '', // if type is 'link' then provide the link path
                target: 'samepage' // For button, default to 'samepage' and For link, get from target attr
            }

            dtmPayload = $.extend(dtmPayload, payload);

            if (!dtmPayload.analyticsText) {
                return false;
            }

            if (dtmPayload.type === 'button') {
                $fdx.DTM.pushButtonInfo(dtmPayload.analyticsText, dtmPayload.target);
            } else if (dtmPayload.type === 'link' && typeof fdx_setLinkView === 'function') {
                // for link 'internal' - within fedex.com pages
                fdx_setLinkView(dtmPayload.analyticsText);
            } else if (dtmPayload.type === 'link-external' && typeof fdx_logLinkView === 'function') {
                // for link 'external'- going away from fedex.com
                fdx_logLinkView(dtmPayload.analyticsText, dtmPayload.event);
            } else if (dtmPayload.type === 'simulate-click') {
                // 'simulateClick' is for for non existing dom element events
                // It simulates 'button' click for events like onLoad or impressions etc
                $('<button style="display:none"></button>').on('click', function() {
                    $fdx.DTM.pushButtonInfo(dtmPayload.analyticsText, dtmPayload.target);
                }).appendTo(document.body).click().remove();
            }

            return true;
        }

        /**
         * GDL analytics
         *
         * @param {object} payload - analytics data required for GDL analytics.
         * @private
         */
        function pushGDL(payload) {
            // GDL analytics payload format
            var gdlPayload = {
                type: 'event:publish', // GDL event type default value
                category: '', // Component name
                eventName: '', // Event name
                params: {} // Analytics data defined by data team
            }

            gdlPayload = $.extend(gdlPayload, payload);

            // GDL API expects category/component name with valid event and payload
            if (!gdlPayload.category || !gdlPayload.eventName || _.isEmpty(gdlPayload.params)) {
                return false;
            }

            // GDL analytics Service format
            // window.FDX.GDL.push([ 'event:publish', [ Category, EventName, payload ] ]);
            // Trigger GDL analytics
            $fdx.GDL.push([gdlPayload.type, [gdlPayload.category, gdlPayload.eventName, gdlPayload.params]]);

            return true;
        }

        /**
         * check for GDL analytics else push data to Adobe analytics
         *
         * @param {Object} payload - data required to fire GDL or DTM events.
         * @public
         */
        function push(payload) {

            if (!payload) {
                return false;
            }

            // check for GDL analytics else trigger Adobe analytics
            if ($fdx.GDL && payload.gdl) {
                return pushGDL(payload.gdl);
            } else if ($fdx.DTM && payload.dtm) {
                return pushDTM(payload.dtm);
            } else {
                return false;
            }
        }

        // return service
        return {
            init: init,
            push: push
        };

    })();

}(window.jQuery, window, FDX));
/**
 * Fetch Service
 *
 * Fetch url using jQuery ajax method, avoid duplicate requests.
 */

(function($, window) {
    window.FDX.services.fetch = (function() {

        var deferred = {};

        /**
         * Init service
         *
         * @public
         */
        function init() {}

        /**
         * Fetch
         *
         * @public
         */
        function ajax(url, data, _config) {

            // if we have done this request already, then simply return existing request
            if (deferred[url]) return deferred[url];

            // new ajax request
            var defaultConfig = {
                method: 'get',
                dataType: 'json',
                url: url,
                data: data
            }
            var config = $.extend({}, defaultConfig, _config);
            deferred[url] = $.ajax(config);
            return deferred[url];
        }

        // @todo check with Vijay on this
        /*
        var data = {};
        var xhr = {};
        var $get = $.getJSON; // Default is JSON format
        function get(url, type) {
          var _deferred = $.Deferred();

          if (!url) {
            return _deferred.reject();
          }

          // other formats like html.
          if (type) {
            $get = $.get;
          }

          // setup promise if not set allready
          if (!deferred[url]) {
            deferred[url] = _deferred;
          }

          if (data[url]) {
            // When we allready stored data we simply return this
            deferred[url].resolve(data[url]);
            return deferred[url];
          } else if (xhr[url]) {
            // When no data is set but request being made again (page and bar component on same page) we simply return xhr call
            return deferred[url];
          } else {
            // When checkig this service for the first time we will store it to xhr and return promise
            xhr[url] = $get(url)
              .done(function (response) {
                // we did succeed in retrieving any data
                data[url] = response;
                deferred[url].resolve(response);
              })
              .fail(function () {
                // reject on error
                deferred[url].reject();
              });

            return deferred[url];

          }
        }*/

        // return service
        return {
            init: init,
            ajax: ajax
            // deferred: deferred
        };

    })();

})(window.jQuery, window);


/*
Javascript to display current environment on all servers except production 

Created 2019/03/07
*/

if (!FDX) {
    var FDX = {};
}
$(window).load(function() {
    var fxTestEnvs = ["wwwbase", "wwwdev", "wwwdrt", "wwwtest"];
    if (~fxTestEnvs.indexOf(window.location.hostname.split(".")[0])) {
        // ~ makes indexOf truthy
        // Check to make sure this code only run in test environments

        // Environment cookie values set by page @ /etc/systems/aemenv.html
        var fxEnvCookieValues = {
            "aem-f01.test.cloud.fedex.com:80": "Feature 1",
            "aem-f02.test.cloud.fedex.com:80": "Feature 2",
            "aem-f03.test.cloud.fedex.com:80": "Feature 3",
            "aem-f04.test.cloud.fedex.com:80": "Feature 4",
            "c0008603.test.cloud.fedex.com:8080": "Feature 4",
            "c0014466.test.cloud.fedex.com:8080": "Feature 7",
            "c0013368.test.cloud.fedex.com:8080": "Integration 1",
            "c0009816.test.cloud.fedex.com:8080": "User Acceptance 1",
            "c0014387.test.cloud.fedex.com:8080": "User Acceptance 7",
            "qwb80002.sac.fedex.com:80": "PreProd",
            "64": "AEM 6.4 Level 6"
        };
        // Find the cookie aemenv and get its value
        var fxCurrentEnv = fxEnvCookieValues[document.cookie.replace(/(?:(?:^|.*;\s*)aemenv\s*\=\s*([^;]*).*$)|^.*$/, "$1")];
        // Check to make sure there is a value.
        // No value means cookie is "default" and nothing is done
        if (fxCurrentEnv) {
            // Add environment tag to the logo in the upper left corner.
            $(".fxg-header__logo_wrapper").append('<span class="fx-env">' + fxCurrentEnv + '</span>');
            $(".fx-env").css({
                "position": "absolute",
                "left": 0,
                "top": "2px",
                "color": "white",
                "font-weight": "bold",
                "font-size": "8px",
                "text-transform": "uppercase"
            });
        }
    }
});
//Array.from() Polyfill - Production steps of ECMA-262, Edition 6, 22.1.2.1
if (!Array.from) {
    Array.from = (function() {
        var toStr = Object.prototype.toString;
        var isCallable = function(fn) {
            return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
        };
        var toInteger = function(value) {
            var number = Number(value);
            if (isNaN(number)) {
                return 0;
            }
            if (number === 0 || !isFinite(number)) {
                return number;
            }
            return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
        };
        var maxSafeInteger = Math.pow(2, 53) - 1;
        var toLength = function(value) {
            var len = toInteger(value);
            return Math.min(Math.max(len, 0), maxSafeInteger);
        };

        // The length property of the from method is 1.
        return function from(arrayLike /*, mapFn, thisArg */ ) {
            // 1. Let C be the this value.
            var C = this;

            // 2. Let items be ToObject(arrayLike).
            var items = Object(arrayLike);

            // 3. ReturnIfAbrupt(items).
            if (arrayLike == null) {
                throw new TypeError('Array.from requires an array-like object - not null or undefined');
            }

            // 4. If mapfn is undefined, then let mapping be false.
            var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
            var T;
            if (typeof mapFn !== 'undefined') {
                // 5. else
                // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
                if (!isCallable(mapFn)) {
                    throw new TypeError('Array.from: when provided, the second argument must be a function');
                }

                // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
                if (arguments.length > 2) {
                    T = arguments[2];
                }
            }

            // 10. Let lenValue be Get(items, "length").
            // 11. Let len be ToLength(lenValue).
            var len = toLength(items.length);

            // 13. If IsConstructor(C) is true, then
            // 13. a. Let A be the result of calling the [[Construct]] internal method
            // of C with an argument list containing the single item len.
            // 14. a. Else, Let A be ArrayCreate(len).
            var A = isCallable(C) ? Object(new C(len)) : new Array(len);

            // 16. Let k be 0.
            var k = 0;
            // 17. Repeat, while k < len… (also steps a - h)
            var kValue;
            while (k < len) {
                kValue = items[k];
                if (mapFn) {
                    A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                } else {
                    A[k] = kValue;
                }
                k += 1;
            }
            // 18. Let putStatus be Put(A, "length", len, true).
            A.length = len;
            // 20. Return A.
            return A;
        };
    }());
}
// source: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
(function() {
    if (typeof window.CustomEvent === "function") {
        return false;
    }

    function CustomEvent(event, params) {
        params = params || {
            bubbles: false,
            cancelable: false,
            detail: undefined
        };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    }

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
})();
// source: https://github.com/w3c/IntersectionObserver

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */
(function() {
    'use strict';

    // Exit early if we're not running in a browser.
    if (typeof window !== 'object') {
        return;
    }

    // Exit early if all IntersectionObserver and IntersectionObserverEntry
    // features are natively supported.
    if ('IntersectionObserver' in window &&
        'IntersectionObserverEntry' in window &&
        'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

        // Minimal polyfill for Edge 15's lack of `isIntersecting`
        // See: https://github.com/w3c/IntersectionObserver/issues/211
        if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
            Object.defineProperty(window.IntersectionObserverEntry.prototype,
                'isIntersecting', {
                    get: function() {
                        return this.intersectionRatio > 0;
                    }
                });
        }
        return;
    }

    /**
     * Returns the embedding frame element, if any.
     * @param {!Document} doc
     * @return {!Element}
     */
    function getFrameElement(doc) {
        try {
            return doc.defaultView && doc.defaultView.frameElement || null;
        } catch (e) {
            // Ignore the error.
            return null;
        }
    }

    /**
     * A local reference to the root document.
     */
    var document = (function(startDoc) {
        var doc = startDoc;
        var frame = getFrameElement(doc);
        while (frame) {
            doc = frame.ownerDocument;
            frame = getFrameElement(doc);
        }
        return doc;
    })(window.document);

    /**
     * An IntersectionObserver registry. This registry exists to hold a strong
     * reference to IntersectionObserver instances currently observing a target
     * element. Without this registry, instances without another reference may be
     * garbage collected.
     */
    var registry = [];

    /**
     * The signal updater for cross-origin intersection. When not null, it means
     * that the polyfill is configured to work in a cross-origin mode.
     * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}
     */
    var crossOriginUpdater = null;

    /**
     * The current cross-origin intersection. Only used in the cross-origin mode.
     * @type {DOMRect|ClientRect}
     */
    var crossOriginRect = null;


    /**
     * Creates the global IntersectionObserverEntry constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
     * @param {Object} entry A dictionary of instance properties.
     * @constructor
     */
    function IntersectionObserverEntry(entry) {
        this.time = entry.time;
        this.target = entry.target;
        this.rootBounds = ensureDOMRect(entry.rootBounds);
        this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
        this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
        this.isIntersecting = !!entry.intersectionRect;

        // Calculates the intersection ratio.
        var targetRect = this.boundingClientRect;
        var targetArea = targetRect.width * targetRect.height;
        var intersectionRect = this.intersectionRect;
        var intersectionArea = intersectionRect.width * intersectionRect.height;

        // Sets intersection ratio.
        if (targetArea) {
            // Round the intersection ratio to avoid floating point math issues:
            // https://github.com/w3c/IntersectionObserver/issues/324
            this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
        } else {
            // If area is zero and is intersecting, sets to 1, otherwise to 0
            this.intersectionRatio = this.isIntersecting ? 1 : 0;
        }
    }


    /**
     * Creates the global IntersectionObserver constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
     * @param {Function} callback The function to be invoked after intersection
     *     changes have queued. The function is not invoked if the queue has
     *     been emptied by calling the `takeRecords` method.
     * @param {Object=} opt_options Optional configuration options.
     * @constructor
     */
    function IntersectionObserver(callback, opt_options) {

        var options = opt_options || {};

        if (typeof callback != 'function') {
            throw new Error('callback must be a function');
        }

        if (
            options.root &&
            options.root.nodeType != 1 &&
            options.root.nodeType != 9
        ) {
            throw new Error('root must be a Document or Element');
        }

        // Binds and throttles `this._checkForIntersections`.
        this._checkForIntersections = throttle(
            this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

        // Private properties.
        this._callback = callback;
        this._observationTargets = [];
        this._queuedEntries = [];
        this._rootMarginValues = this._parseRootMargin(options.rootMargin);

        // Public properties.
        this.thresholds = this._initThresholds(options.threshold);
        this.root = options.root || null;
        this.rootMargin = this._rootMarginValues.map(function(margin) {
            return margin.value + margin.unit;
        }).join(' ');

        /** @private @const {!Array<!Document>} */
        this._monitoringDocuments = [];
        /** @private @const {!Array<function()>} */
        this._monitoringUnsubscribes = [];
    }


    /**
     * The minimum interval within which the document will be checked for
     * intersection changes.
     */
    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


    /**
     * The frequency in which the polyfill polls for intersection changes.
     * this can be updated on a per instance basis and must be set prior to
     * calling `observe` on the first target.
     */
    IntersectionObserver.prototype.POLL_INTERVAL = null;

    /**
     * Use a mutation observer on the root element
     * to detect intersection changes.
     */
    IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


    /**
     * Sets up the polyfill in the cross-origin mode. The result is the
     * updater function that accepts two arguments: `boundingClientRect` and
     * `intersectionRect` - just as these fields would be available to the
     * parent via `IntersectionObserverEntry`. This function should be called
     * each time the iframe receives intersection information from the parent
     * window, e.g. via messaging.
     * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}
     */
    IntersectionObserver._setupCrossOriginUpdater = function() {
        if (!crossOriginUpdater) {
            /**
             * @param {DOMRect|ClientRect} boundingClientRect
             * @param {DOMRect|ClientRect} intersectionRect
             */
            crossOriginUpdater = function(boundingClientRect, intersectionRect) {
                if (!boundingClientRect || !intersectionRect) {
                    crossOriginRect = getEmptyRect();
                } else {
                    crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
                }
                registry.forEach(function(observer) {
                    observer._checkForIntersections();
                });
            };
        }
        return crossOriginUpdater;
    };


    /**
     * Resets the cross-origin mode.
     */
    IntersectionObserver._resetCrossOriginUpdater = function() {
        crossOriginUpdater = null;
        crossOriginRect = null;
    };


    /**
     * Starts observing a target element for intersection changes based on
     * the thresholds values.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.observe = function(target) {
        var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
            return item.element == target;
        });

        if (isTargetAlreadyObserved) {
            return;
        }

        if (!(target && target.nodeType == 1)) {
            throw new Error('target must be an Element');
        }

        this._registerInstance();
        this._observationTargets.push({
            element: target,
            entry: null
        });
        this._monitorIntersections(target.ownerDocument);
        this._checkForIntersections();
    };


    /**
     * Stops observing a target element for intersection changes.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.unobserve = function(target) {
        this._observationTargets =
            this._observationTargets.filter(function(item) {
                return item.element != target;
            });
        this._unmonitorIntersections(target.ownerDocument);
        if (this._observationTargets.length == 0) {
            this._unregisterInstance();
        }
    };


    /**
     * Stops observing all target elements for intersection changes.
     */
    IntersectionObserver.prototype.disconnect = function() {
        this._observationTargets = [];
        this._unmonitorAllIntersections();
        this._unregisterInstance();
    };


    /**
     * Returns any queue entries that have not yet been reported to the
     * callback and clears the queue. This can be used in conjunction with the
     * callback to obtain the absolute most up-to-date intersection information.
     * @return {Array} The currently queued entries.
     */
    IntersectionObserver.prototype.takeRecords = function() {
        var records = this._queuedEntries.slice();
        this._queuedEntries = [];
        return records;
    };


    /**
     * Accepts the threshold value from the user configuration object and
     * returns a sorted array of unique threshold values. If a value is not
     * between 0 and 1 and error is thrown.
     * @private
     * @param {Array|number=} opt_threshold An optional threshold value or
     *     a list of threshold values, defaulting to [0].
     * @return {Array} A sorted list of unique and valid threshold values.
     */
    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
        var threshold = opt_threshold || [0];
        if (!Array.isArray(threshold)) threshold = [threshold];

        return threshold.sort().filter(function(t, i, a) {
            if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
                throw new Error('threshold must be a number between 0 and 1 inclusively');
            }
            return t !== a[i - 1];
        });
    };


    /**
     * Accepts the rootMargin value from the user configuration object
     * and returns an array of the four margin values as an object containing
     * the value and unit properties. If any of the values are not properly
     * formatted or use a unit other than px or %, and error is thrown.
     * @private
     * @param {string=} opt_rootMargin An optional rootMargin value,
     *     defaulting to '0px'.
     * @return {Array<Object>} An array of margin objects with the keys
     *     value and unit.
     */
    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
        var marginString = opt_rootMargin || '0px';
        var margins = marginString.split(/\s+/).map(function(margin) {
            var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
            if (!parts) {
                throw new Error('rootMargin must be specified in pixels or percent');
            }
            return {
                value: parseFloat(parts[1]),
                unit: parts[2]
            };
        });

        // Handles shorthand.
        margins[1] = margins[1] || margins[0];
        margins[2] = margins[2] || margins[0];
        margins[3] = margins[3] || margins[1];

        return margins;
    };


    /**
     * Starts polling for intersection changes if the polling is not already
     * happening, and if the page's visibility state is visible.
     * @param {!Document} doc
     * @private
     */
    IntersectionObserver.prototype._monitorIntersections = function(doc) {
        var win = doc.defaultView;
        if (!win) {
            // Already destroyed.
            return;
        }
        if (this._monitoringDocuments.indexOf(doc) != -1) {
            // Already monitoring.
            return;
        }

        // Private state for monitoring.
        var callback = this._checkForIntersections;
        var monitoringInterval = null;
        var domObserver = null;

        // If a poll interval is set, use polling instead of listening to
        // resize and scroll events or DOM mutations.
        if (this.POLL_INTERVAL) {
            monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
        } else {
            addEvent(win, 'resize', callback, true);
            addEvent(doc, 'scroll', callback, true);
            if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {
                domObserver = new win.MutationObserver(callback);
                domObserver.observe(doc, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
        }

        this._monitoringDocuments.push(doc);
        this._monitoringUnsubscribes.push(function() {
            // Get the window object again. When a friendly iframe is destroyed, it
            // will be null.
            var win = doc.defaultView;

            if (win) {
                if (monitoringInterval) {
                    win.clearInterval(monitoringInterval);
                }
                removeEvent(win, 'resize', callback, true);
            }

            removeEvent(doc, 'scroll', callback, true);
            if (domObserver) {
                domObserver.disconnect();
            }
        });

        // Also monitor the parent.
        var rootDoc =
            (this.root && (this.root.ownerDocument || this.root)) || document;
        if (doc != rootDoc) {
            var frame = getFrameElement(doc);
            if (frame) {
                this._monitorIntersections(frame.ownerDocument);
            }
        }
    };


    /**
     * Stops polling for intersection changes.
     * @param {!Document} doc
     * @private
     */
    IntersectionObserver.prototype._unmonitorIntersections = function(doc) {
        var index = this._monitoringDocuments.indexOf(doc);
        if (index == -1) {
            return;
        }

        var rootDoc =
            (this.root && (this.root.ownerDocument || this.root)) || document;

        // Check if any dependent targets are still remaining.
        var hasDependentTargets =
            this._observationTargets.some(function(item) {
                var itemDoc = item.element.ownerDocument;
                // Target is in this context.
                if (itemDoc == doc) {
                    return true;
                }
                // Target is nested in this context.
                while (itemDoc && itemDoc != rootDoc) {
                    var frame = getFrameElement(itemDoc);
                    itemDoc = frame && frame.ownerDocument;
                    if (itemDoc == doc) {
                        return true;
                    }
                }
                return false;
            });
        if (hasDependentTargets) {
            return;
        }

        // Unsubscribe.
        var unsubscribe = this._monitoringUnsubscribes[index];
        this._monitoringDocuments.splice(index, 1);
        this._monitoringUnsubscribes.splice(index, 1);
        unsubscribe();

        // Also unmonitor the parent.
        if (doc != rootDoc) {
            var frame = getFrameElement(doc);
            if (frame) {
                this._unmonitorIntersections(frame.ownerDocument);
            }
        }
    };


    /**
     * Stops polling for intersection changes.
     * @param {!Document} doc
     * @private
     */
    IntersectionObserver.prototype._unmonitorAllIntersections = function() {
        var unsubscribes = this._monitoringUnsubscribes.slice(0);
        this._monitoringDocuments.length = 0;
        this._monitoringUnsubscribes.length = 0;
        for (var i = 0; i < unsubscribes.length; i++) {
            unsubscribes[i]();
        }
    };


    /**
     * Scans each observation target for intersection changes and adds them
     * to the internal entries queue. If new entries are found, it
     * schedules the callback to be invoked.
     * @private
     */
    IntersectionObserver.prototype._checkForIntersections = function() {
        if (!this.root && crossOriginUpdater && !crossOriginRect) {
            // Cross origin monitoring, but no initial data available yet.
            return;
        }

        var rootIsInDom = this._rootIsInDom();
        var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

        this._observationTargets.forEach(function(item) {
            var target = item.element;
            var targetRect = getBoundingClientRect(target);
            var rootContainsTarget = this._rootContainsTarget(target);
            var oldEntry = item.entry;
            var intersectionRect = rootIsInDom && rootContainsTarget &&
                this._computeTargetAndRootIntersection(target, targetRect, rootRect);

            var rootBounds = null;
            if (!this._rootContainsTarget(target)) {
                rootBounds = getEmptyRect();
            } else if (!crossOriginUpdater || this.root) {
                rootBounds = rootRect;
            }

            var newEntry = item.entry = new IntersectionObserverEntry({
                time: now(),
                target: target,
                boundingClientRect: targetRect,
                rootBounds: rootBounds,
                intersectionRect: intersectionRect
            });

            if (!oldEntry) {
                this._queuedEntries.push(newEntry);
            } else if (rootIsInDom && rootContainsTarget) {
                // If the new entry intersection ratio has crossed any of the
                // thresholds, add a new entry.
                if (this._hasCrossedThreshold(oldEntry, newEntry)) {
                    this._queuedEntries.push(newEntry);
                }
            } else {
                // If the root is not in the DOM or target is not contained within
                // root but the previous entry for this target had an intersection,
                // add a new record indicating removal.
                if (oldEntry && oldEntry.isIntersecting) {
                    this._queuedEntries.push(newEntry);
                }
            }
        }, this);

        if (this._queuedEntries.length) {
            this._callback(this.takeRecords(), this);
        }
    };


    /**
     * Accepts a target and root rect computes the intersection between then
     * following the algorithm in the spec.
     * TODO(philipwalton): at this time clip-path is not considered.
     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
     * @param {Element} target The target DOM element
     * @param {Object} targetRect The bounding rect of the target.
     * @param {Object} rootRect The bounding rect of the root after being
     *     expanded by the rootMargin value.
     * @return {?Object} The final intersection rect object or undefined if no
     *     intersection is found.
     * @private
     */
    IntersectionObserver.prototype._computeTargetAndRootIntersection =
        function(target, targetRect, rootRect) {
            // If the element isn't displayed, an intersection can't happen.
            if (window.getComputedStyle(target).display == 'none') return;

            var intersectionRect = targetRect;
            var parent = getParentNode(target);
            var atRoot = false;

            while (!atRoot && parent) {
                var parentRect = null;
                var parentComputedStyle = parent.nodeType == 1 ?
                    window.getComputedStyle(parent) : {};

                // If the parent isn't displayed, an intersection can't happen.
                if (parentComputedStyle.display == 'none') return null;

                if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {
                    atRoot = true;
                    if (parent == this.root || parent == document) {
                        if (crossOriginUpdater && !this.root) {
                            if (!crossOriginRect ||
                                crossOriginRect.width == 0 && crossOriginRect.height == 0) {
                                // A 0-size cross-origin intersection means no-intersection.
                                parent = null;
                                parentRect = null;
                                intersectionRect = null;
                            } else {
                                parentRect = crossOriginRect;
                            }
                        } else {
                            parentRect = rootRect;
                        }
                    } else {
                        // Check if there's a frame that can be navigated to.
                        var frame = getParentNode(parent);
                        var frameRect = frame && getBoundingClientRect(frame);
                        var frameIntersect =
                            frame &&
                            this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
                        if (frameRect && frameIntersect) {
                            parent = frame;
                            parentRect = convertFromParentRect(frameRect, frameIntersect);
                        } else {
                            parent = null;
                            intersectionRect = null;
                        }
                    }
                } else {
                    // If the element has a non-visible overflow, and it's not the <body>
                    // or <html> element, update the intersection rect.
                    // Note: <body> and <html> cannot be clipped to a rect that's not also
                    // the document rect, so no need to compute a new intersection.
                    var doc = parent.ownerDocument;
                    if (parent != doc.body &&
                        parent != doc.documentElement &&
                        parentComputedStyle.overflow != 'visible') {
                        parentRect = getBoundingClientRect(parent);
                    }
                }

                // If either of the above conditionals set a new parentRect,
                // calculate new intersection data.
                if (parentRect) {
                    intersectionRect = computeRectIntersection(parentRect, intersectionRect);
                }
                if (!intersectionRect) break;
                parent = parent && getParentNode(parent);
            }
            return intersectionRect;
        };


    /**
     * Returns the root rect after being expanded by the rootMargin value.
     * @return {ClientRect} The expanded root rect.
     * @private
     */
    IntersectionObserver.prototype._getRootRect = function() {
        var rootRect;
        if (this.root && !isDoc(this.root)) {
            rootRect = getBoundingClientRect(this.root);
        } else {
            // Use <html>/<body> instead of window since scroll bars affect size.
            var doc = isDoc(this.root) ? this.root : document;
            var html = doc.documentElement;
            var body = doc.body;
            rootRect = {
                top: 0,
                left: 0,
                right: html.clientWidth || body.clientWidth,
                width: html.clientWidth || body.clientWidth,
                bottom: html.clientHeight || body.clientHeight,
                height: html.clientHeight || body.clientHeight
            };
        }
        return this._expandRectByRootMargin(rootRect);
    };


    /**
     * Accepts a rect and expands it by the rootMargin value.
     * @param {DOMRect|ClientRect} rect The rect object to expand.
     * @return {ClientRect} The expanded rect.
     * @private
     */
    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
        var margins = this._rootMarginValues.map(function(margin, i) {
            return margin.unit == 'px' ? margin.value :
                margin.value * (i % 2 ? rect.width : rect.height) / 100;
        });
        var newRect = {
            top: rect.top - margins[0],
            right: rect.right + margins[1],
            bottom: rect.bottom + margins[2],
            left: rect.left - margins[3]
        };
        newRect.width = newRect.right - newRect.left;
        newRect.height = newRect.bottom - newRect.top;

        return newRect;
    };


    /**
     * Accepts an old and new entry and returns true if at least one of the
     * threshold values has been crossed.
     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
     *    particular target element or null if no previous entry exists.
     * @param {IntersectionObserverEntry} newEntry The current entry for a
     *    particular target element.
     * @return {boolean} Returns true if a any threshold has been crossed.
     * @private
     */
    IntersectionObserver.prototype._hasCrossedThreshold =
        function(oldEntry, newEntry) {

            // To make comparing easier, an entry that has a ratio of 0
            // but does not actually intersect is given a value of -1
            var oldRatio = oldEntry && oldEntry.isIntersecting ?
                oldEntry.intersectionRatio || 0 : -1;
            var newRatio = newEntry.isIntersecting ?
                newEntry.intersectionRatio || 0 : -1;

            // Ignore unchanged ratios
            if (oldRatio === newRatio) return;

            for (var i = 0; i < this.thresholds.length; i++) {
                var threshold = this.thresholds[i];

                // Return true if an entry matches a threshold or if the new ratio
                // and the old ratio are on the opposite sides of a threshold.
                if (threshold == oldRatio || threshold == newRatio ||
                    threshold < oldRatio !== threshold < newRatio) {
                    return true;
                }
            }
        };


    /**
     * Returns whether or not the root element is an element and is in the DOM.
     * @return {boolean} True if the root element is an element and is in the DOM.
     * @private
     */
    IntersectionObserver.prototype._rootIsInDom = function() {
        return !this.root || containsDeep(document, this.root);
    };


    /**
     * Returns whether or not the target element is a child of root.
     * @param {Element} target The target element to check.
     * @return {boolean} True if the target element is a child of root.
     * @private
     */
    IntersectionObserver.prototype._rootContainsTarget = function(target) {
        var rootDoc =
            (this.root && (this.root.ownerDocument || this.root)) || document;
        return (
            containsDeep(rootDoc, target) &&
            (!this.root || rootDoc == target.ownerDocument)
        );
    };


    /**
     * Adds the instance to the global IntersectionObserver registry if it isn't
     * already present.
     * @private
     */
    IntersectionObserver.prototype._registerInstance = function() {
        if (registry.indexOf(this) < 0) {
            registry.push(this);
        }
    };


    /**
     * Removes the instance from the global IntersectionObserver registry.
     * @private
     */
    IntersectionObserver.prototype._unregisterInstance = function() {
        var index = registry.indexOf(this);
        if (index != -1) registry.splice(index, 1);
    };


    /**
     * Returns the result of the performance.now() method or null in browsers
     * that don't support the API.
     * @return {number} The elapsed time since the page was requested.
     */
    function now() {
        return window.performance && performance.now && performance.now();
    }


    /**
     * Throttles a function and delays its execution, so it's only called at most
     * once within a given time period.
     * @param {Function} fn The function to throttle.
     * @param {number} timeout The amount of time that must pass before the
     *     function can be called again.
     * @return {Function} The throttled function.
     */
    function throttle(fn, timeout) {
        var timer = null;
        return function() {
            if (!timer) {
                timer = setTimeout(function() {
                    fn();
                    timer = null;
                }, timeout);
            }
        };
    }


    /**
     * Adds an event handler to a DOM node ensuring cross-browser compatibility.
     * @param {Node} node The DOM node to add the event handler to.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to add.
     * @param {boolean} opt_useCapture Optionally adds the even to the capture
     *     phase. Note: this only works in modern browsers.
     */
    function addEvent(node, event, fn, opt_useCapture) {
        if (typeof node.addEventListener == 'function') {
            node.addEventListener(event, fn, opt_useCapture || false);
        } else if (typeof node.attachEvent == 'function') {
            node.attachEvent('on' + event, fn);
        }
    }


    /**
     * Removes a previously added event handler from a DOM node.
     * @param {Node} node The DOM node to remove the event handler from.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to remove.
     * @param {boolean} opt_useCapture If the event handler was added with this
     *     flag set to true, it should be set to true here in order to remove it.
     */
    function removeEvent(node, event, fn, opt_useCapture) {
        if (typeof node.removeEventListener == 'function') {
            node.removeEventListener(event, fn, opt_useCapture || false);
        } else if (typeof node.detatchEvent == 'function') {
            node.detatchEvent('on' + event, fn);
        }
    }


    /**
     * Returns the intersection between two rect objects.
     * @param {Object} rect1 The first rect.
     * @param {Object} rect2 The second rect.
     * @return {?Object|?ClientRect} The intersection rect or undefined if no
     *     intersection is found.
     */
    function computeRectIntersection(rect1, rect2) {
        var top = Math.max(rect1.top, rect2.top);
        var bottom = Math.min(rect1.bottom, rect2.bottom);
        var left = Math.max(rect1.left, rect2.left);
        var right = Math.min(rect1.right, rect2.right);
        var width = right - left;
        var height = bottom - top;

        return (width >= 0 && height >= 0) && {
            top: top,
            bottom: bottom,
            left: left,
            right: right,
            width: width,
            height: height
        } || null;
    }


    /**
     * Shims the native getBoundingClientRect for compatibility with older IE.
     * @param {Element} el The element whose bounding rect to get.
     * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.
     */
    function getBoundingClientRect(el) {
        var rect;

        try {
            rect = el.getBoundingClientRect();
        } catch (err) {
            // Ignore Windows 7 IE11 "Unspecified error"
            // https://github.com/w3c/IntersectionObserver/pull/205
        }

        if (!rect) return getEmptyRect();

        // Older IE
        if (!(rect.width && rect.height)) {
            rect = {
                top: rect.top,
                right: rect.right,
                bottom: rect.bottom,
                left: rect.left,
                width: rect.right - rect.left,
                height: rect.bottom - rect.top
            };
        }
        return rect;
    }


    /**
     * Returns an empty rect object. An empty rect is returned when an element
     * is not in the DOM.
     * @return {ClientRect} The empty rect.
     */
    function getEmptyRect() {
        return {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        };
    }


    /**
     * Ensure that the result has all of the necessary fields of the DOMRect.
     * Specifically this ensures that `x` and `y` fields are set.
     *
     * @param {?DOMRect|?ClientRect} rect
     * @return {?DOMRect}
     */
    function ensureDOMRect(rect) {
        // A `DOMRect` object has `x` and `y` fields.
        if (!rect || 'x' in rect) {
            return rect;
        }
        // A IE's `ClientRect` type does not have `x` and `y`. The same is the case
        // for internally calculated Rect objects. For the purposes of
        // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`
        // for these fields.
        return {
            top: rect.top,
            y: rect.top,
            bottom: rect.bottom,
            left: rect.left,
            x: rect.left,
            right: rect.right,
            width: rect.width,
            height: rect.height
        };
    }


    /**
     * Inverts the intersection and bounding rect from the parent (frame) BCR to
     * the local BCR space.
     * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.
     * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.
     * @return {ClientRect} The local root bounding rect for the parent's children.
     */
    function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
        var top = parentIntersectionRect.top - parentBoundingRect.top;
        var left = parentIntersectionRect.left - parentBoundingRect.left;
        return {
            top: top,
            left: left,
            height: parentIntersectionRect.height,
            width: parentIntersectionRect.width,
            bottom: top + parentIntersectionRect.height,
            right: left + parentIntersectionRect.width
        };
    }


    /**
     * Checks to see if a parent element contains a child element (including inside
     * shadow DOM).
     * @param {Node} parent The parent element.
     * @param {Node} child The child element.
     * @return {boolean} True if the parent node contains the child node.
     */
    function containsDeep(parent, child) {
        var node = child;
        while (node) {
            if (node == parent) return true;

            node = getParentNode(node);
        }
        return false;
    }


    /**
     * Gets the parent node of an element or its host element if the parent node
     * is a shadow root.
     * @param {Node} node The node whose parent to get.
     * @return {Node|null} The parent node or null if no parent exists.
     */
    function getParentNode(node) {
        var parent = node.parentNode;

        if (node.nodeType == /* DOCUMENT */ 9 && node != document) {
            // If this node is a document node, look for the embedding frame.
            return getFrameElement(node);
        }

        // If the parent has element that is assigned through shadow root slot
        if (parent && parent.assignedSlot) {
            parent = parent.assignedSlot.parentNode
        }

        if (parent && parent.nodeType == 11 && parent.host) {
            // If the parent is a shadow root, return the host element.
            return parent.host;
        }

        return parent;
    }

    /**
     * Returns true if `node` is a Document.
     * @param {!Node} node
     * @returns {boolean}
     */
    function isDoc(node) {
        return node && node.nodeType === 9;
    }


    // Exposes the constructors globally.
    window.IntersectionObserver = IntersectionObserver;
    window.IntersectionObserverEntry = IntersectionObserverEntry;

}());

//This javascript adds  polyfills .includes() for ie11
if  (!String.prototype.includes)  {    
    String.prototype.includes  =   function(search,  start)  {      
        if  (typeof  start  !==  'number')  {        
            start  =  0;      
        }      
        if  (start  +  search.length  >  this.length)  {        
            return  false;      
        } 
        else  {        
            return  this.indexOf(search,  start)  !==  -1;      
        }    
    };  
}
/* This is the FedEx.com utility navigation component javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-03-13
 */

if (!FDX) {
    var FDX = {};
}

FDX.UTILNAV = {
    searchClass: 'fxg-user-options__search',
    searchBtnClass: 'fxg-user-options__search-btn',
    headerOpenClass: 'fxg-header--search-open',
    headerCloseClass: 'fxg-header--search-close',
    searchBoxClass: 'fxg-search-js',
    searchResultsClass: 'fxg-search-results',
    searchResultsShowClass: 'fxg-search-results--show',
    headerClass: 'fxg-header',
    searchCloseBtnClass: 'fxg-close-btn',
    searchCloseAnchorClass: 'fxg-search-close-btn',
    searchFieldClass: 'fxg-user-options__search-field',
    wrapperClass: 'fxg-nav',
    wrapperOpenClass: 'fxg-nav--search-open',
    defaultSignInText: '',
    unAuthenticatedMarkupPath: '',
    authenticatedMarkupPath: '',
    rewardMemberClass: '.fxg-rewards-link-member',
    rewardNonMemberClass: '.fxg-rewards-link-non-member',
    rewardPointsClass: '.fxg-link__reward-points',
    rewardDetailClass: '.fxg-rewards-link-member .fxg-link__detail',

    openSearchBox: function() {
        $('.' + FDX.UTILNAV.wrapperClass).addClass(FDX.UTILNAV.wrapperOpenClass);
        $('.' + FDX.UTILNAV.wrapperClass).find('.' + FDX.UTILNAV.searchBoxClass).focus();
    },

    closeSearchBox: function(elem) {
        $(elem).prev('.' + FDX.UTILNAV.searchFieldClass).val('');
        $('.' + FDX.UTILNAV.wrapperClass).removeClass(FDX.UTILNAV.wrapperOpenClass);
        $('.' + FDX.UTILNAV.wrapperClass).addClass(FDX.UTILNAV.headerCloseClass);
        //Wait .25 seconds so that the slide animation from the close class finishes, then remove.
        setTimeout(function() {
            $('.' + FDX.UTILNAV.wrapperClass).removeClass(FDX.UTILNAV.headerCloseClass);
        }, 250);

        // Change item focus on search close
        if ($('.fxg-breadcrumbs__link').length > 0) {
            setTimeout(function() {
                $('.fxg-breadcrumbs__link')[0].focus();
            }, 250);
        } else if ($("#cubeOnePar").length > 0) {
            setTimeout(function() {
                $("#cubeOnePar").focus();
            }, 250);
        } else if ($(".fxg-main-content .root .responsivegrid a").length > 0) {
            setTimeout(function() {
                // fix for shipping page template
                if ($(".fxg-main-content .root .responsivegrid a span")[0] != undefined) {
                    var len = $(".fxg-main-content .root .responsivegrid a").filter(":visible").parents("li").length;
                    $(".fxg-main-content .root .responsivegrid a").filter(":visible").parents("li")[len - 1].focus();
                } else {
                    $(".fxg-main-content .root .responsivegrid a").filter(":visible")[0].focus();
                }
            }, 250);
        } else if ($(".fxg-main-content a").length > 0) {
            setTimeout(function() {
                $(".fxg-main-content a").filter(":visible")[0].focus();
            }, 250);
        }

        FDX.UTILNAV.hideResults();
    },

    showResults: function() {

        if (typeof(fdx) !== 'undefined' && fdx.isBrand !== 'undefined' && fdx.isBrand == "true") {

        } else {
            $('.' + FDX.UTILNAV.searchResultsClass).addClass(FDX.UTILNAV.searchResultsShowClass);
            FDX.DROPDOWN.showOverlay();
        }

    },

    hideResults: function() {
        $('.' + FDX.UTILNAV.searchResultsClass).removeClass(FDX.UTILNAV.searchResultsShowClass);
    },

    mobileCloseSearch: function(mq) {
        if (mq.matches) {
            if ($('.' + FDX.UTILNAV.wrapperClass).hasClass(FDX.UTILNAV.wrapperOpenClass)) {
                FDX.UTILNAV.closeSearchBox($('.' + FDX.UTILNAV.searchClass + ' .' + FDX.UTILNAV.searchCloseBtnClass));
            }
        }
    },
    search: function() {
        // STUB METHOD TO FIRE SEARCH CALL
        // FDX.UTILNAV.search();
    },

    // Upon logout (FDX.LOGIN.doLogout), this method is used to show the default "Sign In" text
    hideContactName: function() {
        $('.fxg-user-options__sign-in a span').text(FDX.UTILNAV.defaultSignInText + " "); // leave a space after text
    },

    // Upon login (FDX.LOGIN.doLogin), this method is used to show the contact name in place of the "Sign In" text
    showContactName: function() {
        $('.fxg-user-options__sign-in a span').text(FDX.SESSION.getContactName() + " "); // leave a space after name
    },
    showShippingContactName: function(contactname) {
        $('.fxg-user-options__sign-in a span').text(contactname + " "); // leave a space after name
    },

    // Upon login (FDX.LOGIN), this method is used to show the authenticated state dropdown links of the utility nav
    showAuthenticatedState: function() {
        // swap out the markup
        $.ajax({
            url: FDX.UTILNAV.authenticatedMarkupPath,
            success: function(result) {
                $('.utility-nav-dropdown__sub-menu').html(result);
                FDX.UTILNAV.toggleRewardPointsLink();
            }
        });
    },

    showUnAuthenticatedState: function() {
        // swap out the markup
        $.ajax({
            url: FDX.UTILNAV.unAuthenticatedMarkupPath,
            success: function(result) {
                $('.utility-nav-dropdown__sub-menu').html(result);
                $(FDX.LOGIN.loginFormID).off("submit");
                $(FDX.LOGIN.loginFormID + ':not(.bound)').addClass('bound').submit(function(e) {
                    e.preventDefault();
                    FDX.DTM.pushButtonInfo("hdr|Login", "samePage");
                    FDX.LOGIN.doLogin($(this));
                });
                FDX.LOGIN.setRememberMeState();
                $("#NavLoginPassword_show").hide();
                FDX.LOGIN.onPasswordClick();
                FDX.LOGIN.onPasswordShowKeyPress();
                FDX.LOGIN.onPasswordKeyUp();
                FDX.LOGIN.onPasswordShowclick();
            }
        });
    },

    showWlgnState: function() {
        var wlgnDiv = JSON.parse(localStorage.getItem('wlgndiv'));
        if (wlgnDiv !== "undefined") {
            $('.utility-nav-dropdown__sub-menu').html(wlgnDiv);
        }
    },

    toggleRewardPointsLink: function() {
        var rewardCookie = FDX.SESSION.getRewardCookie();
        var rewardCookieType = typeof rewardCookie;
        var isCookieNull = false;
        if (rewardCookieType === 'string') {
            if (rewardCookie === 'null') {
                isCookieNull = true;
            }
        } else {
            if (rewardCookie === null) {
                isCookieNull = true;
            }
        }
        if (FDX.SESSION && !isCookieNull) {
            // set reward points
            $(FDX.UTILNAV.rewardPointsClass).text(Number(FDX.SESSION.userRewards).toLocaleString());

            // determine which tier the reward member is in
            if (FDX.SESSION.userRewardsTier != "BASE") {
                $(FDX.UTILNAV.rewardDetailClass).text(FDX.SESSION.userRewardsTier);
            } else {
                if (typeof(FDX.SESSION.rewardsAPIGEnabled) != 'undefined' &&
                    FDX.SESSION.rewardsAPIGEnabled === 'true' && document.getElementById('mfxr-basepath') != null) {
                    var baseMemberLink = document.getElementById('mfxr-basepath').value;
                    var link = $('.fxg-rewards-link-member').find('a');
                    $(link).attr('href', baseMemberLink);
                }
                // Do not display points for base members
                $(FDX.UTILNAV.rewardPointsClass).text("");
            }
            // show reward points
            $(FDX.UTILNAV.rewardMemberClass).show();
            $(FDX.UTILNAV.rewardNonMemberClass).hide();
        } else {

            // show join link
            // $(FDX.UTILNAV.rewardMemberClass).hide();
            // $(FDX.UTILNAV.rewardNonMemberClass).show();

            // Show or hide the Join My Rewards Link based on Business Profile
            // of Non link Member

            $(FDX.UTILNAV.rewardMemberClass).hide();

            // Non-Link member with business profile
            if (FDX.SESSION.userModel != null &&
                FDX.SESSION.userModel.userProfileAddress.contact.companyName) {
                $(FDX.UTILNAV.rewardNonMemberClass).show();

            } else {
                // Non-Link member with out business profile
                $(FDX.UTILNAV.rewardNonMemberClass).hide();

            }


        }
    },

    init: function() {
        // save the initial content as variables, so we can put it back on
        // logout
        localStorage.setItem('wlgndiv', JSON.stringify($('.wlgnlink-class').html()));
        FDX.UTILNAV.defaultSignInText = $('.fxg-user-options__sign-in a').attr('data-default-signInText');
        FDX.UTILNAV.unAuthenticatedMarkupPath = $('.utility-nav-dropdown__sub-menu').attr('data-util-nav-jcr-path') + '/login_module.html';
        FDX.UTILNAV.authenticatedMarkupPath = $('.utility-nav-dropdown__sub-menu').attr('data-util-nav-jcr-path') + '/authenticated_links.html';
        FDX.UTILNAV.toggleRewardPointsLink();
    }
}

$(document).ready(function() {
    $('.' + FDX.UTILNAV.searchBtnClass).on('click', function() {
        FDX.UTILNAV.openSearchBox();
    });

    if ($('.fdx-utilityWrap').attr('data-showUtilityNav') == 'no') {
        $("#global-login-wrapper").hide();
        $(".fxg-user-options__option.fxg-user-options__search-btn").hide();
    }

    var $root = $('.js-fxg-search');
    var $searchInputBtn = $root.find('.js-fxg-search-btn');

    // hover effect on touch device
    $searchInputBtn.on('touchstart touchend', function(e) {
        $root.toggleClass('is-hovered');
    });

    // hover effect
    $searchInputBtn.hover(function() {
        $root.addClass('is-hovered');
    }, function() {
        $root.removeClass('is-hovered');
    });

    $('.' + FDX.UTILNAV.searchBoxClass).keyup(function() {
        if ($(this).val().length > 0) {
            FDX.UTILNAV.showResults();
        } else {
            FDX.UTILNAV.hideResults();
        }
    });

    $('.' + FDX.UTILNAV.searchClass + ' .' + FDX.UTILNAV.searchCloseBtnClass + ', .' + FDX.UTILNAV.searchCloseAnchorClass).on('click keydown', function(e) {
        if (e.type === 'keydown' && e.which !== 13) {
            return;
        }
        FDX.UTILNAV.closeSearchBox(this);
    })

    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.UTILNAV.mobileCloseSearch);

    FDX.UTILNAV.init();
});

if (!FDX) {
    var FDX = {};
}

var WTRK = {
    landingComponent: null
}

FDX.TRACKINGLANDING = {

    mobileViewQuery: window.matchMedia("(max-width: " + "767" + "px)"),
    extScripts: null,
    host: window.location.origin,

    loadTrackingLandingScripts: function() {
        var loadTrkLandingWeb = (document.getElementById("trk-landingModule-webCheck") != null) ? document
            .getElementById("trk-landingModule-webCheck").value :
            "false";
        if (loadTrkLandingWeb != undefined && loadTrkLandingWeb === "true") {
            FDX.TRACKINGLANDING.loadTrackingLandingWeb();
        } else {
            FDX.TRACKINGLANDING.extScripts = JSON.parse(document
                .getElementById("track-module-script").value);
            var scriptTag = [];
            if (FDX.TRACKINGLANDING.extScripts != null) {
                for (var i = 0; i < FDX.TRACKINGLANDING.extScripts.length; i++) {
                    var scriptID = 'dep' + [i];
                    scriptTag[i] = document.createElement('script');
                    scriptTag[i].src = '//' + window.location.hostname +
                        FDX.TRACKINGLANDING.extScripts[i];
                    scriptTag[i].id = scriptID;
                    scriptTag[i].async = true;
                    // console.log(scriptTag[i].src);
                    var headTag = document.getElementsByTagName('head')[0];
                    headTag.appendChild(scriptTag[i]);
                }
            }
        }
    },

    loadTrackingLandingWeb: function() {
        var trkLandingDiv = document.getElementById("trk-LandingModule-div");
        var trkLandingExtApp = document.getElementById("trk-landingModule-html").value;

        jQuery.ajax({
            type: "GET",
            url: FDX.TRACKINGLANDING.host + trkLandingExtApp,
            cache: false,
            crossDomain: true,
            success: function(result) {
                try {
                    // console.log(result);
                    jQuery('html').find(trkLandingDiv).html(result);
                } catch (e) {
                    console.error(e);
                }
            },
        });
    },
};

if ((typeof(FDX) !== "undefined") && !FDX.TRACKINGLANDING.mobileViewQuery.matches &&
    FDX.DATALAYER.page.category.pageType === "trackingpage" &&
    (FDX.SESSION.getCookie('wcmmode') === null)) {
    if (WTRK.landingComponent == null &&
        !$("#trk-LandingModule-div").hasClass("trk_landing_loaded")) {
        //console.log("111In load......");
        $("#trk-LandingModule-div").addClass("trk_landing_loaded");
        FDX.TRACKINGLANDING.loadTrackingLandingScripts();
    }
} else if ((typeof(FDX) !== "undefined") && FDX.TRACKINGLANDING.mobileViewQuery.matches && FDX.DATALAYER.page.category.pageType === "trackingpage" &&
    (document.getElementById("show-track-module").value === "true") && (FDX.SESSION.getCookie('wcmmode') === null)) {
    if (WTRK.landingComponent == null &&
        !$("#trk-LandingModule-div").hasClass("trk_landing_loaded")) {
        //console.log("222In load......");
        $("#trk-LandingModule-div").addClass("trk_landing_loaded");
        FDX.TRACKINGLANDING.loadTrackingLandingScripts();
    }
}
/* This is the FedEx.com tracking module javascript file (used in global nav).
 The global FDX object must already be defined.

 Author: joey.dukeminier@vml.com
 Created: 2017-05-01
 */
if (!FDX) {
    var FDX = {};
}

FDX.TRACK = {

    trackFailedClass: "fxg-tracking-error",
    trackFailedMessage: "An undefined error occurred.",
    trackingNumFieldName: "trackingNumber",
    headerTrackingModuleID: "#HeaderTrackingModule",
    homeTrackingAppID: "#HomeTrackingApp",

    doTrackModule: function() {
        // This is the stub method to perform the track for the header module
        // FedEx IT should pickup from here.
        // Should also return error message to populate error placeholder.

        // Remove any existing error message.
        FDX.TRACK.removeErrorMessage();

        var k = $(FDX.TRACK.headerTrackingModuleID + " input[name='" + FDX.TRACK.trackingNumFieldName + "']");
        var v = k.val();
        var locale = FDX.SESSION.getLocale();
        var cc = FDX.SESSION.getCountryPath();
        var dataAnalytics = document.getElementById("dataAnalyticsTrackModule").value;
        var trackURL = document.getElementById("trackURL").value;
        var trackArray = [];
        FDX.DATALAYER.track.trackInfo = [];

        FDX.DTM.pushButtonInfo(dataAnalytics, "newPage");

        if (FDX.TRACK.validateField(k, v)) {

            //DTM update

            if (v.indexOf(',') > 0) {
                trackArray = v.split(',');
                for (var i = 0; i < trackArray.length; i++) {
                    FDX.DATALAYER.trackData = {
                        track: "",
                        from: "",
                        to: "",
                        status: "",
                        keyX: ""
                    };
                    FDX.DATALAYER.trackData.track = trackArray[i];
                    FDX.DATALAYER.track.trackInfo.push(FDX.DATALAYER.trackData);
                    FDX.DATALAYER.track.isSingleTrack = false;
                    FDX.DATALAYER.track.trackQuantity = trackArray.length;
                }

            } else {
                FDX.DATALAYER.trackData.track = v;
                FDX.DATALAYER.track.isSingleTrack = true;
                FDX.DATALAYER.track.trackQuantity = 1;
                FDX.DATALAYER.track.trackInfo.push(FDX.DATALAYER.trackData);

            }

            /*
             * For Cloud apps and other apps not running on the assumed host
             * If normal host is not used FDX_HOSTNAME will need to be set before including the header.
             * Usecase - Cloud apps development environments.
             */
            var FDX_HOSTNAME = FDX_HOSTNAME || "",
                host = window.location.host;
            if (FDX_HOSTNAME !== "") {
                host = FDX_HOSTNAME;
            }

            // default url works if track url is not configured  
            var urlStr = encodeURI("https://" + host + trackURL + "?action=track&tracknumbers=" + v + "&locale=" + locale + "&cntry_code=" + cc);
            if (trackURL == "" || trackURL == "#") {
                window.location = encodeURI("https://" + host + "/apps/fedextrack/?action=track&tracknumbers=" + v + "&locale=" + locale + "&cntry_code=" + cc);
            } else {
                window.location = urlStr;
            }
        } else {
            // Failed
            // Reset error message.
            FDX.TRACK.trackFailedMessage = "Tracking number not valid. This placeholder error will be replaced later. TBD.";
            FDX.TRACK.showErrorMessage();
        }
    },

    doTrackApp: function() {
        // This is the stub method to perform the track for the main tracking application in the body
        // FedEx IT should pick up from here and inject state 2 markup into the app container

        if (FDX.CUBE) {
            FDX.CUBE.openApp();
        }
    },

    validateField: function(k, v) {
        // Add custom validation here if needed.
        // k is the field name
        // v is the field value

        // no current validation, just return true for now.
        return true;
    },

    removeErrorMessage: function() {
        $('.' + FDX.TRACK.trackFailedClass).remove();
    },

    showErrorMessage: function() {
        // This has not been completed yet and will change!
        // Error placeholder TBD.
        $(FDX.TRACK.trackingFormID).prepend('<div class="' + FDX.TRACK.trackFailedClass + '">' + FDX.TRACK.trackFailedMessage + '</div>');
    }
};


$(document).ready(function() {

    $(window).bind('resize', function(e, data) {
        if ($('#trackingModuleTrackingNum').is(":focus") && direction != "back") {
            var k = document.activeElement;
            setTimeout(function() {
                k.focus();
            }, 0)
        }


    });
    // Below code id fix for only cursor issues in IOS11. Please do check on new version, and remove the code if Apple made a fix.
    // console.log("document load",$('input#trackingModuleTrackingNum').html())
    var userAgent = navigator.userAgent;
    var userAgentM = userAgent.match(/(opera|chrome|safari|firefox|msie|trident)\s?\/*(\d+)/i) || [];
    var browserTypeIosFix = userAgentM.join(' ').toString().split(" ")[0].toLowerCase();
    var mobilePattCheck = /mobile/i;
    var isMobileCheck = mobilePattCheck.test(userAgent);
    if (isMobileCheck && browserTypeIosFix.indexOf('safari') === 0) {
        var nowCursor = new Date().getTime();
        // Focus on any input field inside wrapper will scroll the screen Up and set positin fixed to body.
        // Delay is important as Mobile browsers takes somes ms to pop up the keypad. We want to move screen at top position
        // once the screen is scrolled by browser.
        $(".fxg-wrapper input").bind('focus', function(e) {
            setTimeout(function() {
                if ($('.fxg-overlay').length === 1 && $(window).scrollTop() != 0) {
                    $('html, body').animate({
                        scrollTop: 0,
                        scrollLeft: 0
                    }, 'fast');
                    if ($('html,body').css('position') != 'fixed') {
                        $('html,body').css('position', 'fixed');
                    }
                }
                nowCursor = new Date().getTime();
            }, 200);
        });

        // If user scrolls, we are bluring the field and removing fixed position to body.
        $(window).scroll(function() {
            setTimeout(function() {
                if ($(window).scrollTop() != 0) {
                    if (new Date().getTime() - nowCursor > 800) {
                        if ($('.fxg-overlay').length === 1 && $(window).scrollTop() != 0) {
                            //  alert($(window).scrollTop());
                            if ($('input').is(':focus')) {
                                $('input:focus').blur();
                                $('html, body').css('position', '');
                            }
                        }
                        nowCursor = new Date().getTime();
                    }
                }
            }, 300);
        });

        // Here checking the scroll behaviour inside the dropdown.
        $('.fxg-dropdown').scroll(function() {
            if (window.pageYOffset > $(window).scrollTop() - 10) {
                if (new Date().getTime() - nowCursor > 1000) {
                    if ($('.fxg-overlay').length === 1) {
                        if ($('input').is(':focus')) {
                            $('input:focus').blur();
                            $('html, body').css('position', '');
                        }
                    }
                    nowCursor = new Date().getTime();
                }
            }
        });
    }
    // Until above line, the code is fix for cursor issues on IOS11.

    // Bind to the track form in the header
    $(FDX.TRACK.headerTrackingModuleID).submit(function(e) {
        e.preventDefault();
        FDX.TRACK.doTrackModule();
    });

    // Bind to the track form in the body
    $(FDX.TRACK.homeTrackingAppID).submit(function(e) {
        e.preventDefault();
        FDX.TRACK.doTrackApp();
    });
});
/* This is the FedEx.com tracking app component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-05-01
 */

if (!FDX) {
    var FDX = {};
}
// CHANGE: VMLNAFEDEXW-676 Add classes for LP Tracking Apps
FDX.TRACKING = {
    watchListBtnClass: "fxg-tracking-app__watch-list-btn",
    watchListSelectedClass: "fxg-tracking-app__watch-list-btn--selected",
    singleTrackingClass: "fxg-app__single-tracking",
    multiTrackingClass: "fxg-tracking-app__multi-tracking",
    singleTrackingLandingPageClass: "fxg-landing-tracking-app__single-tracking",
    multiTrackingLandingPageClass: "fxg-landing-tracking-app__multi-tracking",
    state1Class: "fxg-tracking-app__state1",
    state2Class: "fxg-tracking-app__state2",
    state1LandingPageClass: "fxg-landing-tracking-app__state1",
    state2LandingPageClass: "fxg-landing-tracking-app__state2",
    resultsPlaceholder: $(".fxg-tracking-app__results"),
    resultsPlaceholderLandingPage: $(".fxg-landing-tracking-app__results"),
    resultsDataPlaceholderLandingPage: $(".fxg-landing-tracking-app__results-data"),
    seeFullDetailsLink: "#SeeFullTrackingDetailsLink",
    seeFullDetailsLinkText: "SEE FULL DETAILS",
    executed: false,
    fromMultiTrack: false,
    singleTrackFromMulti: null,
    trackCookieStartsWith: "tss-",
    trackLinks: $(".fxg-tracking-app__links-par"),
    viewWatchList: false,
    pathName: encodeURI(window.location.pathname),
    multipleTrackingNumberAltText: '',
    proofOfDeliveryTrackingNumberAltText: '',
    trackModuleViewState: '',

    submit: function() {
        //Stubbed function where app logic will go
        // 1) Make ajax request to get tracking results
        // 2) Parse response
        // 3) Populate FDX.TRACKING.resultsPlaceholder with content
        // 4) Set See Full Details link with proper href
        FDX.DATALAYER.track.trackInfo = [];
        var trackingnumberField = $('#HomeTrackingApp input[name="trackingnumber"]');
        var trackingnumber = trackingnumberField.val();
        var locale = FDX.SESSION.getLocale();
        var cc = FDX.SESSION.getCountryPath();
        var dataAnalytics = document.getElementById("dataAnalyticsTracking").value;

        if (FDX.TRACKING.fromMultiTrack) {
            trackingnumber = FDX.TRACKING.singleTrackFromMulti;
            FDX.TRACKING.showSingleTracking();
            trackingnumberField.val(trackingnumber);
            var valueChange = $.Event('keyup');
            valueChange.keyCode = 13;
            $('input').trigger(valueChange);
        }
        //DTM update
        FDX.DATALAYER.trackData.track = trackingnumber;
        FDX.DATALAYER.track.isSingleTrack = true;
        FDX.DATALAYER.track.trackQuantity = 1;
        FDX.DATALAYER.track.trackInfo.push(FDX.DATALAYER.trackData);

        //FDX.DTM.pushButtonInfo(dataAnalytics,"samePage");

        $('html').find('.' + FDX.TRACKING.state1Class).addClass("fxg-tracking-app__submitted");
        $('html').find(FDX.TRACKING.seeFullDetailsLink).html(FDX.TRACKING.seeFullDetailsLinkText);
        // Per requirements (MPV1) authors should not be able to edit the bottom links on state 2. These are handled by FedEx IT in data response because they change based on status.
        // Get dummy response for testing layout

        /*
         * Nitin - Commenting out the following line to hide the mockcontent loading on click on track button.
         */
        //FDX.TRACKING.resultsPlaceholder.html(FDX.TRACKING.MOCKDATA.status + FDX.TRACKING.MOCKDATA.watchlist + FDX.TRACKING.MOCKDATA.details + FDX.TRACKING.MOCKDATA.bottomLinks);
        //WTRK.homepageComponentLite.req.trackByTrackingNumberList(trackingnumber);

        //Call to resize the hero so that results will fit
        //This just adds an open class and adds calculated height to hero

        if (trackingnumber != '') {
            FDX.DTM.pushButtonInfo(dataAnalytics, "samePage");
            /*On back button page load when user does not click text field and there is track number entered already 
             in text field and hit Track
             */
            // For New App 
            if (!FDX.TRACKING.executed && FDX.APPBASE.isWebComponent) {
                $.ajax({
                    context: FDX.TRACKING.loadWebComponent()

                }).done(function(data) {
                    if (FDX.CUBE) {
                        FDX.CUBE.openApp();
                    }
                });
                //console.log('After AppJS load!!');

            } else if (!FDX.TRACKING.executed && !FDX.APPBASE.isWebComponent) {
                /*On back button page load when user does not click text field and there is track number entered already 
           	 in text field and hit Track
           	 */
                // For Old  App 
                $.ajax({
                    context: FDX.TRACKING.loadTrackScripts()
                }).done(function(data) {
                    $.ajax({
                        context: FDX.TRACKING.resultsPlaceholder.html(WTRK.homepageComponentLite.req.trackByTrackingNumberList(trackingnumber))

                    }).done(function(data) {
                        if (FDX.CUBE) {
                            FDX.CUBE.openApp();
                        }
                        var trackInterval1 = setInterval(function() {
                            if ($('.redesignSnapshotTVC .fxg-tracking-app__more-detail')[0] !== undefined) {
                                clearInterval(trackInterval1);
                                setTimeout(function() {
                                    if (FDX.CUBE) {
                                        FDX.CUBE.openApp();
                                    }
                                }, 50);
                            }
                        }, 100);
                    });
                    //console.log('After AppJS load!!');
                });

            } else {
                //On page load when user first clicks on text field and hit Track
                // for old app 
                if (!FDX.APPBASE.isWebComponent) {

                    $.ajax({
                        context: FDX.TRACKING.resultsPlaceholder.html(WTRK.homepageComponentLite.req.trackByTrackingNumberList(trackingnumber))

                    }).done(function(data) {
                        if (FDX.CUBE) {
                            FDX.CUBE.openApp();

                        }
                        var trackInterval2 = setInterval(function() {
                            if ($('.redesignSnapshotTVC .fxg-tracking-app__more-detail')[0] !== undefined) {
                                clearInterval(trackInterval2);
                                setTimeout(function() {
                                    if (FDX.CUBE) {
                                        FDX.CUBE.openApp();
                                        //FDX.CUBE.openApp();

                                    }
                                }, 50);
                            }
                        }, 100);

                    });

                } else {
                    // for new app 
                    if (FDX.CUBE) {
                        FDX.CUBE.openApp();
                    }
                }

            }
        } else {
            FDX.DTM.pushButtonInfo("", "");
        }
    },

    submitMulti: function() {
        //Stubbed function where app logic will go
        // 1) Make ajax request to get tracking results
        // 2) Parse response
        // 3) Populate FDX.TRACKING.resultsPlaceholder with content
        FDX.DATALAYER.track.trackInfo = [];
        var locale = FDX.SESSION.getLocale();
        var cc = FDX.SESSION.getCountryPath();
        var dataAnalytics = document.getElementById("dataAnalyticsTracking").value;
        var trackArray = [];
        $('#HomeMultiTrackingApp input[name^="trackingnumber"]').each(function() {
            if ($(this).val() != '') {
                if (trackArray.indexOf($(this).val()) < 0) {
                    trackArray.push($(this).val());
                }
            }

        });

        //DTM track object update
        for (var i = 0; i < trackArray.length; i++) {
            FDX.DATALAYER.trackData = {
                track: "",
                from: "",
                to: "",
                status: "",
                keyX: ""
            };
            FDX.DATALAYER.trackData.track = trackArray[i];
            FDX.DATALAYER.track.trackInfo.push(FDX.DATALAYER.trackData);

        }
        FDX.DATALAYER.track.isSingleTrack = false;
        FDX.DATALAYER.track.trackQuantity = trackArray.length;
        FDX.DTM.pushButtonInfo(dataAnalytics, "newPage");


        if (trackArray.length > 1) {
            if (!FDX.APPBASE.isWebComponent) {
                if (!FDX.TRACKING.executed) {
                    $.ajax({
                        context: FDX.TRACKING.loadTrackScripts()

                    }).done(function(data) {
                        WTRK.homepageComponentLite.req.trackByTrackingNumberList(trackArray);
                        //console.log('After AppJS load!!');
                    });
                } else {
                    WTRK.homepageComponentLite.req.trackByTrackingNumberList(trackArray);
                }
            }


        } else if (trackArray.length == 1) {
            FDX.TRACKING.fromMultiTrack = true;
            FDX.TRACKING.singleTrackFromMulti = trackArray;
            FDX.TRACKING.submit();
        }
    },
    // CHANGE: VMLNAFEDEXW-676 Add form submit handler for LP Tracking Apps
    submitTrackByNumberSingleLandingPage: function() {
        //Stubbed function where app logic will go
        // 1) Make ajax request to get tracking results
        // 2) Parse response
        // 3) Populate FDX.TRACKING.resultsDataPlaceholderLandingPage with content
        // 4) Set See Full Details link with proper href

        var trackingnumberField = $('#LandingPageTrackByNumberSingleApp input[name="trackingnumber"]');
        var trackingnumber = trackingnumberField.val();
        var locale = FDX.SESSION.getLocale();
        var cc = FDX.SESSION.getCountryPath();

        if (trackingnumber !== '') {


            $('html').find('.' + FDX.TRACKING.state1LandingPageClass).addClass("fxg-tracking-app__submitted");

            // Per requirements (MPV1) authors should not be able to edit the bottom links on state 2. These are handled by FedEx IT in data response because they change based on status.
            // Get dummy response for testing layout
            $('html').find('.' + FDX.TRACKING.state2LandingPageClass).show();
            FDX.TRACKING.resultsDataPlaceholderLandingPage.html(FDX.TRACKING.MOCKDATA.status + FDX.TRACKING.MOCKDATA.watchlist + FDX.TRACKING.MOCKDATA.details + FDX.TRACKING.MOCKDATA.bottomLinks);
            $('html').find(FDX.TRACKING.seeFullDetailsLink).html(FDX.TRACKING.seeFullDetailsLinkText);
        }
    },

    submitTrackByNumberMulitpleLandingPage: function() {
        //Stubbed function where app logic will go
        // 1) Make ajax request to get tracking results
        // 2) Parse response
        // 3) Console log input's values

        var locale = FDX.SESSION.getLocale();
        var cc = FDX.SESSION.getCountryPath();
        var trackArray = [];
        $('#LandingPageTrackByNumberMultipleApp input[name^="trackingnumber"]').each(function() {
            if ($(this).val() != '') {
                trackArray.push($(this).val());
            }
        });
        if (trackArray.length > 0) {

        }
    },

    showMultiTracking: function() {
        $('.' + FDX.TRACKING.multiTrackingClass).show();
        $('.' + FDX.TRACKING.singleTrackingClass).hide();
        FDX.APPBASE.loadAppData();
        FDX.APPBASE.loadAppBaseData();
        if (!FDX.APPBASE.isWebComponent) {
            FDX.TRACKING.loadTrackScripts();
            if (FDX.CUBE)
                FDX.CUBE.openApp();
        }
        if (FDX.APPBASE.isWebComponent) {
            FDX.TRACKING.loadWebComponent();
            if (FDX.CUBE) {
                FDX.CUBE.openApp();
            }

        }

    },
    // CHANGE: VMLNAFEDEXW-676 Add form submit handlers for LP Tracking Apps
    showMultiTrackingLandingPage: function() {
        $('.' + FDX.TRACKING.multiTrackingLandingPageClass).show();
        $('.' + FDX.TRACKING.singleTrackingLandingPageClass).hide();
    },

    submitTrackByReferenceLandingPage: function() {
        // Stubbed function where app logic will go
        // 1) Make ajax request to get tracking results
        // 2) Parse response
        // 3) Populate FDX.TRACKING.resultsPlaceholderLandingPage with content
        var trackArray = [];
        $('#LandingPageTrackByReferenceApp input').each(function() {
            if ($(this).val() != '') {
                trackArray.push($(this).val());
            }
        });
        $('#LandingPageTrackByReferenceApp .dropdown li.active').each(function() {
            if ($(this).data("value")) {
                trackArray.push($(this).data("value"));
            }
        });
        if (trackArray.length > 0) {

            FDX.TRACKING.resultsPlaceholderLandingPage.show();
            FDX.TRACKING.resultsPlaceholderLandingPage.html("Track By Reference - Search Results go here");
        }
    },

    submitProofOfDeliveryLandingPage: function() {
        // Stubbed function where app logic will go
        // 1) Make ajax request to get tracking results
        // 2) Parse response
        // 3) Populate FDX.TRACKING.resultsPlaceholderLandingPage with content
        var trackArray = [];
        $('#LandingProofOfDeliveryApp input').each(function() {
            if ($(this).val() != '') {
                trackArray.push($(this).val());
            }
        });
        $('#LandingProofOfDeliveryApp .dropdown li.active').each(function() {
            if ($(this).data("value")) {
                trackArray.push($(this).data("value"));
            }
        });
        if (trackArray.length > 0) {

            FDX.TRACKING.resultsPlaceholderLandingPage.show();
            FDX.TRACKING.resultsPlaceholderLandingPage.html("Proof of delivery - Search Results go here");
        }
    },

    submitViewBillOfLadingLandingPage: function() {
        // Stubbed function where app logic will go
        // 1) Make ajax request to get tracking results
        // 2) Parse response
        // 3) Populate FDX.TRACKING.resultsPlaceholderLandingPage with content
        var trackArray = [];
        $('#LandingViewBillOfLadingApp input').each(function() {
            if ($(this).val() != '') {
                trackArray.push($(this).val());
            }
        });
        $('#LandingViewBillOfLadingApp .dropdown li.active').each(function() {
            if ($(this).data("value")) {
                trackArray.push($(this).data("value"));
            }
        });
        if (trackArray.length > 0) {

            FDX.TRACKING.resultsPlaceholderLandingPage.show();
            FDX.TRACKING.resultsPlaceholderLandingPage.html("View Bill of Lading - Search Results go here");
        }
    },

    showSingleTracking: function() {
        $('html').find('.' + FDX.TRACKING.multiTrackingClass).hide();
        $('html').find('.' + FDX.TRACKING.singleTrackingClass).show();

        // Removed --open class to align the track button in default state always
        if (FDX.CUBE) {
            FDX.CUBE.closeApp();
        }

        //Return to top so that single is is in view.
        var singleOffset = $('html').find('.' + FDX.TRACKING.singleTrackingClass).offset().top - 75;
        if ($('html').scrollTop() > singleOffset) {
            $("html, body").animate({
                scrollTop: singleOffset
            });
        }

        var singleTrackingInputField = $('#HomeTrackingApp div.fxg-field input.fxg-field__input-text');
        singleTrackingInputField.focus(); //focus tracking field on single track screen
    },

    showSingleTrackingLandingPage: function() {
        $('.' + FDX.TRACKING.multiTrackingLandingPageClass).hide();
        $('.' + FDX.TRACKING.singleTrackingLandingPageClass).show();

        //Return to top so that single is is in view.
        var singleOffset = $('.' + FDX.TRACKING.singleTrackingLandingPageClass).offset().top - 75;
        if ($(window).scrollTop() > singleOffset)
            $("html, body").animate({
                scrollTop: singleOffset
            });
    },

    getTrackingCookie: function() {
        var watchlistFlag = false;
        var cookieArray = [];

        var trackCookieList = document.cookie.split(';').filter(function(c) {

            return c.trim().indexOf(FDX.TRACKING.trackCookieStartsWith) === 0;
        });
        if (trackCookieList.length > 0 && !FDX.APPBASE.isWebComponent) {
            setTimeout(function() {
                FDX.TRACKING.loadTrackScripts();
            }, 200);

            trackCookieList.map(function(c) {


                var cookieVal = decodeURIComponent(c.trim());
                var cookieDateStamp = cookieVal.slice(cookieVal.indexOf('=') + 1, cookieVal.length);
                watchlistFlag = cookieDateStamp.slice(cookieDateStamp.indexOf(':') + 2, cookieDateStamp.lastIndexOf(':') - 1);


                //$(".fxg-tracking-app__links-par .link:nth-child(2)").css("display","inline");

                cookieArray.push(watchlistFlag);
                if (cookieArray.indexOf('true') !== -1) {
                    FDX.TRACKING.showHideViewWatchList(true);
                } else {
                    FDX.TRACKING.showHideViewWatchList(false);
                }
            });
        } else {
            FDX.TRACKING.showHideViewWatchList(watchlistFlag);
        }

    },

    showHideViewWatchList: function(watchFlag) {
        var watchLink = $(".fxg-tracking-app__links-par .link:nth-child(2)");
        if (watchLink.length === 0) {
            watchLink = $(".fxg-tracking-app__links-par .button_v1:nth-child(2)");
        }
        if (!watchFlag) {
            $(watchLink).css("display", "none");
        } else {
            $(watchLink).css("display", "inline");
            if (!FDX.APPBASE.isWebComponent) {
                setTimeout(function() {
                    $(watchLink).click(WTRK.homepageComponentLite.req.viewWatchListShipments);
                }, 5000);
            }
        }

    },

    loadWebComponent: function() {
        FDX.APPBASE.loadAppData();
        FDX.APPBASE.loadAppBaseData();


        if (!FDX.TRACKING.executed) {
            var scriptTag = [];
            var webComponentDivId = document.getElementById("trk-module-div");
            if ((typeof(webComponentDivId) !== "undefined") && webComponentDivId !== null) {

                try {

                    jQuery.ajax({
                        type: "GET",
                        url: "https://" + FDX.APPBASE.domainName + FDX.APPBASE.extAppHTML,
                        cache: false,
                        crossDomain: true,
                        success: function(result) {
                            try {
                                //console.log(result);
                                jQuery(webComponentDivId).html(result);
                                /*$.when(jQuery(webComponentDivId).html(result))
                                		.then(function() {
                                			setTimeout(function() {
                                				FDX.CUBE.openApp();
                                			}, 300);
                                		});*/
                            } catch (e) {
                                console.error(e);
                            }
                        },

                    });
                } catch (e) {
                    console.error(e);
                }
            }

            FDX.TRACKING.executed = true;
        }
        FDX.TRACKING.fromMultiTrack = false;
    },

    loadTrackScripts: function() {
        FDX.APPBASE.loadAppData();
        FDX.APPBASE.loadAppBaseData();

        if (!FDX.TRACKING.executed) {
            var scriptTag = [];
            for (var i = 0; i < FDX.APPBASE.dependentScripts.length; i++) {
                var scriptID = 'dep' + [i];
                scriptTag[i] = document.createElement('script');
                scriptTag[i].src = '//' + FDX.APPBASE.domainName + FDX.APPBASE.dependentScripts[i];
                scriptTag[i].id = scriptID;
                scriptTag[i].async = true;

                var headTag = document.getElementsByTagName('head')[0];
                headTag.appendChild(scriptTag[i]);
            }

            $.ajax({
                context: FDX.TRACKING.loadAppJS()
            }).done(function(data) {

            });

            FDX.TRACKING.executed = true;
        }
        FDX.TRACKING.fromMultiTrack = false;
    },


    loadAppJS: function() {

        if (FDX.APPBASE.appJSpath != null) {
            var scriptTag = document.createElement('script');
            scriptTag.src = '//' + FDX.APPBASE.domainName + FDX.APPBASE.appJSpath;
            scriptTag.async = true;
            var headTag = document.getElementsByTagName('head')[0];
            headTag.appendChild(scriptTag);

        }
    },

    // Loading the scripts for WTRK if user presses back button and track input has content
    browserBackJSload: function() {
        if ($('#HomeTrackingApp input[name="trackingnumber"]').val() !== '') {
            setTimeout(function() {
                $.ajax({
                    context: FDX.TRACKING.loadTrackScripts()
                }).done(function(data) {

                });
            }, 300)

        }
    },

    resizeTrackContent: function() {
        console.warn('resizeTrackContent() is obsolete, and will be removed in future.');
    },


    showTrackState: function() {
        if (FDX.TRACKING.trackModuleViewState === "multi-track-state") {
            setTimeout(function() {
                if (FDX.CUBE) {
                    $('html').find('.' + FDX.TRACKING.singleTrackingClass).hide();
                    $('html').find('.' + FDX.TRACKING.multiTrackingClass).show();
                    FDX.CUBE.openApp();
                }
            }, 1000)
        }
        if (FDX.TRACKING.trackModuleViewState === "results-state") {
            setTimeout(function() {
                if (FDX.CUBE) {
                    FDX.TRACKING.resultsPlaceholder.html('<div style="background:#FAFAFA; border:1px solid #ccc; padding:120px 0; text-align: center; color:#007ab7;">Results Placeholder</div>');
                    $('html').find('.' + FDX.TRACKING.state1Class).hide();
                    $('html').find('.' + FDX.TRACKING.state2Class).show();
                    FDX.CUBE.openApp();
                }
            }, 1000);
        }
    }

};


$(document).ready(function() {
    //Moved below from page load to document ready for tracking web component
    if ((typeof(FDX) !== "undefined") && (FDX.SESSION.getCookie('wcmmode') === null) && (FDX.DATALAYER.page.category.pageType === "homepage" || FDX.DATALAYER.page.category.pageType === "home-page")) {
        FDX.APPBASE.loadAppData();
        FDX.APPBASE.loadAppBaseData();
        if (!FDX.APPBASE.isWebComponent) {
            FDX.TRACKING.browserBackJSload();

        }
        FDX.TRACKING.getTrackingCookie();
    }
    var firstInputField = $('#HomeMultiTrackingApp div.row.fxg-form__row div.fxg-field.fxg-field--full input').filter(':first');
    var firstInputFieldAltTxt;
    firstInputField.on('focus', function() {
        var inputField = $(this);
        inputField.attr('aria-live', 'polite');
        firstInputFieldAltTxt = inputField.attr('aria-label');
        var ariaVal = firstInputFieldAltTxt + ' 1 Enter up to 30 FedEx tracking numbers';
        inputField.attr('aria-label', ariaVal);
    });

    firstInputField.keydown(function() {
        var inputField = $(this);
        inputField.removeAttr('aria-live');
    });

    firstInputField.focusout(function() {
        var inputField = $(this);
        inputField.attr('aria-label', firstInputFieldAltTxt);
    });

    if (document.getElementById("multipleTrackingNumberAltText") !== null &&
        document.getElementById("seeFullDetailsLinkText") !== null &&
        document.getElementById("trackModuleViewState") !== null) {
        FDX.TRACKING.multipleTrackingNumberAltText = document.getElementById("multipleTrackingNumberAltText").value;
        FDX.TRACKING.seeFullDetailsLinkText = document.getElementById("seeFullDetailsLinkText").value;
        FDX.TRACKING.trackModuleViewState = document.getElementById("trackModuleViewState").value;
        FDX.TRACKING.showTrackState();
    }


    //Stubbed submit on click
    $('#HomeTrackingApp').on('submit', function(e) {
        e.preventDefault();
        FDX.TRACKING.submit();
    });

    $('#HomeMultiTrackingApp').on('submit', function(e) {
        e.preventDefault();
        FDX.TRACKING.submitMulti();
    });
    // CHANGE: VMLNAFEDEXW-676 Add form submit listeners for LP Tracking Apps
    $('#LandingPageTrackByNumberSingleApp').on('submit', function(e) {
        e.preventDefault();
        FDX.TRACKING.submitTrackByNumberSingleLandingPage();
    });

    $('#LandingPageTrackByNumberMultipleApp').on('submit', function(e) {
        e.preventDefault();
        FDX.TRACKING.submitTrackByNumberMulitpleLandingPage();
    });

    $('#LandingPageTrackByTcnApp').on('submit', function(e) {
        e.preventDefault();
        var trackArray = [];
        $('#LandingPageTrackByTcnApp input').each(function() {
            if ($(this).val() != '') {
                trackArray.push($(this).val());
            }
        });
        if (trackArray.length === 2) {

            FDX.TRACKING.resultsPlaceholderLandingPage.show();
            FDX.TRACKING.resultsPlaceholderLandingPage.html("Track By TCN - Search Results go here");
        }
    });

    $('#LandingPageTrackByReferenceApp').on('submit', function(e) {
        e.preventDefault();
        FDX.TRACKING.submitTrackByReferenceLandingPage();
    });

    $('#LandingProofOfDeliveryApp').on('submit', function(e) {
        e.preventDefault();
        FDX.TRACKING.submitProofOfDeliveryLandingPage();
    });

    $('#LandingViewBillOfLadingApp').on('submit', function(e) {
        e.preventDefault();
        FDX.TRACKING.submitViewBillOfLadingLandingPage();
    });

    //On click of watch list 
    $('.' + FDX.TRACKING.watchListBtnClass).on('click', function(e) {
        e.preventDefault();
        $(this).toggleClass(FDX.TRACKING.watchListSelectedClass);
    });

    //Start initial load by hiding multi tracking
    $('.' + FDX.HERO.heroClass + ' .' + FDX.TRACKING.multiTrackingClass).hide();
    // CHANGE: VMLNAFEDEXW-676 Set multitracking initial state
    $('.' + FDX.TRACKING.multiTrackingLandingPageClass).hide();
    FDX.TRACKING.resultsPlaceholderLandingPage.hide();

    // CHANGE: VMLNAFEDEXW-676 Add tab-change listeners for LP Tracking Apps
    // clear results area on landing pages - tracking apps
    if (FDX.TABS) {
        $('.' + FDX.TABS.tabsNavClass + ' a').on('shown.bs.tab', function(e) {
            FDX.TRACKING.resultsPlaceholderLandingPage.empty();
            FDX.TRACKING.resultsPlaceholder.empty();
        });
    }

});

FDX.TRACKING.MOCKDATA = {
    status: '<div class="fxg-tracking-app__status"><span class="fxg-title fxg-tracking-app--status-color">Out for Delivery</span><span class="fxg-text" id="fxg-sub-status">Chicago, IL</span><img class="fxg-tracking-app__status-icon fxg-tracking-app__status-icon__label-created" src="/content/dam/fedex-com/common/sprite-placeholder.png"/></div>',
    watchlist: '<div class="fxg-tracking-app__watch-list"><span class="fxg-tracking-app__watch-list-btn"><svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" class="fxg-tracking-app__watch-icon"><g class="fxg-tracking-app__watch-icon"><g stroke="#09C"><path d="M3.8 14.6L4.6 10 4.6 9.7 4.4 9.5 1.1 6.3 5.7 5.6 6 5.5 6.1 5.3 8.1 1.1 10.2 5.3 10.3 5.5 10.6 5.6 15.2 6.3 11.9 9.5 11.7 9.7 11.7 10 12.5 14.6 8.4 12.4 8.1 12.3 7.9 12.4 3.8 14.6Z"/></g></g></svg>Add to Watch list</span></div>',
    details: '<div class="fxg-tracking-app__details"><div class="row"><div class="fxg-col col-sm-6"><span class="fxg-tracking-app__sub-title">From:</span><span class="fxg-tracking-app__detail-info" id="fxg-from-city">Los Angeles, CA</span></div><div class="fxg-col col-sm-6"><span class="fxg-tracking-app__sub-title">To:</span><span class="fxg-tracking-app__detail-info" id="fxg-to-city">Washington, DC</span></div></div> <div class="row"><div class="fxg-col col-sm-6"><span class="fxg-tracking-app__sub-title">SHIP DATE:</span><span class="fxg-tracking-app__detail-info" id="fxg-ship-date">Mon 03/03/2017</span> <span class="fxg-tracking-app__detail-info fxg-tracking-app__detail-info--time" id="fxg-ship-time">7:30 pm</span> <div class="fxg-help"><div class="fxg-help__title"> <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 3 15 15" class="fxg-icon"><style>.a{fill:#FFF;}</style><desc>  Created with Sketch.</desc><g fill="none"><path d="M15 10.5C15 14.6 11.6 18 7.5 18 3.4 18 0 14.6 0 10.5 0 6.4 3.4 3 7.5 3 11.6 3 15 6.4 15 10.5" fill="#09C"/><path d="M7.1 11.8L7.1 11.6C7.1 11.5 7.1 10.6 7.9 10.1 8.6 9.7 8.5 9 8.5 9L8.5 9C8.5 8.8 8.5 8 7.5 8 6.5 8 6.5 8.9 6.5 9L6.5 9C6.5 9.2 6.3 9.4 6.1 9.4 5.9 9.4 5.7 9.2 5.7 9L5.7 9C5.8 8.4 6.2 7.3 7.5 7.3 8.9 7.3 9.3 8.4 9.3 9 9.3 9.1 9.3 10.2 8.3 10.7 7.8 11 7.8 11.6 7.8 11.6L7.8 11.6 7.8 11.8 7.1 11.8Z" class="a"/><path d="M8 12.8C8 13.1 7.8 13.4 7.5 13.4 7.2 13.4 6.9 13.1 6.9 12.8 6.9 12.5 7.2 12.3 7.5 12.3 7.8 12.3 8 12.5 8 12.8" class="a"/></g></svg> Help</div> <div class="fxg-help__message">Ship date reflects date and time of origin time zone.<div class="fxg-help__message-close"> <svg xmlns="http://www.w3.org/2000/svg" width="19" height="19" viewBox="250 30 19 19"><style>.a{stroke-width:2;}</style><desc>  Created with Sketch.</desc><g fill="none"><g stroke="#333333"><path d="M251.7 31.8L267.5 47.5" class="a"/><path d="M267.5 31.8L251.7 47.5" class="a"/></g></g></svg> </div></div></div></div><div class="fxg-col col-sm-6"><span class="fxg-tracking-app__sub-title">SCHEDULED DELIVERY:</span> <span class="fxg-tracking-app__detail-info" id="fxg-delivery-date">Wed 03/12/2017</span> <span class="fxg-tracking-app__detail-info fxg-tracking-app__detail-info--time" id="fxg-delivery-time">12:00pm - 2:00pm</span> <div class="fxg-help"> <div class="fxg-help__title"><svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 3 15 15" class="fxg-icon"><style>.a{fill:#FFF;}</style><desc>  Created with Sketch.</desc><g fill="none"><path d="M15 10.5C15 14.6 11.6 18 7.5 18 3.4 18 0 14.6 0 10.5 0 6.4 3.4 3 7.5 3 11.6 3 15 6.4 15 10.5" fill="#09C"/><path d="M7.1 11.8L7.1 11.6C7.1 11.5 7.1 10.6 7.9 10.1 8.6 9.7 8.5 9 8.5 9L8.5 9C8.5 8.8 8.5 8 7.5 8 6.5 8 6.5 8.9 6.5 9L6.5 9C6.5 9.2 6.3 9.4 6.1 9.4 5.9 9.4 5.7 9.2 5.7 9L5.7 9C5.8 8.4 6.2 7.3 7.5 7.3 8.9 7.3 9.3 8.4 9.3 9 9.3 9.1 9.3 10.2 8.3 10.7 7.8 11 7.8 11.6 7.8 11.6L7.8 11.6 7.8 11.8 7.1 11.8Z" class="a"/><path d="M8 12.8C8 13.1 7.8 13.4 7.5 13.4 7.2 13.4 6.9 13.1 6.9 12.8 6.9 12.5 7.2 12.3 7.5 12.3 7.8 12.3 8 12.5 8 12.8" class="a"/></g></svg> Help</div><div class="fxg-help__message">Ship date reflects date and time of origin time zone.<div class="fxg-help__message-close"><svg xmlns="http://www.w3.org/2000/svg" width="19" height="19" viewBox="250 30 19 19"><style>.a{stroke-width:2;}</style><desc>  Created with Sketch.</desc><g fill="none"><g stroke="#333333"><path d="M251.7 31.8L267.5 47.5" class="a"/><path d="M267.5 31.8L251.7 47.5" class="a"/></g></g></svg></div></div></div></div></div></div>',
    bottomLinks: '<div class="fxg-tracking-app__more"><div class="fxg-tracking-app__more-links"><div class="link"><a href="#" class="fxg-link fxg-link--blue">SCHEDULE DELIVERY</a></div><span class="fxg-link__separator fxg-mobile--hide"> | </span><div class="link"><a href="#" class="fxg-link fxg-link--blue">HOLD AT LOCATION</a></div><span class="fxg-link__separator fxg-mobile--hide"> | </span><div class="link"><a href="#" class="fxg-link fxg-link--blue">SET NOTIFICATION</a></div></div><div class="fxg-tracking-app__more-detail"><div class="link"><a href="#" class="fxg-link fxg-link--blue fxg-link--carrot" id="SeeFullTrackingDetailsLink">SEE FULL DETAILS</a></div> </div></div>'
};
/*
 Author: franco.bonecco@vml.com
 Created: 2017-09-22
 */
if (!FDX) {
    var FDX = {};
}

FDX.TOPIC_LIST = {
    idSuffix: 'fxg-topic_',
    // the div containing the whole component
    componentClass: '.fxg-topic-list',
    // each topic is contained inside a row
    topicEntryClass: '.fxg-topic-list__row',
    topicThumbnailClass: '.fxg-topic-list__thumbnail',
    topicVideoClass: '.fxg-topic-list__video',
    loadMoreClass: '.fxg-topic-list__load-more',
    loadingClass: '.fxg-topic-list__loading',
    loadMoreWrapper: '.fxg-topic-list__load-more-wrapper',
    topicThumbnail: '.fxg-img',
    topicTitle: '.fxg-title',
    topicSynopsis: '.fxg-topic-synopsis',
    topicLink: '.fxg-link',
    // page size
    limit: 10,
    // default offset
    offset: -1,
    // max number of topic loaded at once
    maxLoad: 5,
    // holds instances of this component
    components: [],

    // values below are used to build video-players dynamically
    videoTplId: 'id#fxg-topic-video-tpl',
    videoTplImg: 'img#fxg-topic-video-tpl',

    init: function() {
        // register topic components in the page
        $(FDX.TOPIC_LIST.componentClass).each(function() {
            // the path of the JCR resource using this component
            var componentPath = $(this).data('resourcePath'),
                // the base path of this page (ie: /content/fedex-com/global/en_us)
                searchingPath = $(this).data('searchingPath'),
                resultsPage = parseInt($(this).data('resultsPage')),
                sections = [],
                id = FDX.TOPIC_LIST.idSuffix + new Date().getTime();

            if (resultsPage) {
                FDX.TOPIC_LIST.maxLoad = resultsPage;
            }

            $(this).attr('id', id);

            // each section matches one of the possible source of topics:
            // paths: selected manually
            sections.paths = {
                key: 'paths',
                offset: FDX.TOPIC_LIST.offset,
                limit: FDX.TOPIC_LIST.limit,
                hasMore: true
            };
            // folder: pages under a given path
            sections.folder = {
                key: 'folder',
                offset: FDX.TOPIC_LIST.offset,
                limit: FDX.TOPIC_LIST.limit,
                hasMore: true
            };
            // tags: pages matching one or more topic-tags
            sections.tags = {
                key: 'tags',
                offset: FDX.TOPIC_LIST.offset,
                limit: FDX.TOPIC_LIST.limit,
                hasMore: true
            };

            var component = {
                id: id,
                path: componentPath,
                searchingPath: searchingPath,
                sections: sections,
                buffer: []
            };
            // register this component globally
            FDX.TOPIC_LIST.components.push(component);

            FDX.TOPIC_LIST.load(component);
        });
    },

    sortFn: function(a, b) {
        return b.created - a.created || b.key > a.key;
    },

    // handles the load-more scenario
    load: function(component) {
        var doQuery = false;
        // check if there is any section containing more topics
        for (var key in component.sections) {
            if (component.sections[key].hasMore) {
                doQuery = true;
                if (component.sections[key].offset < 0) {
                    component.sections[key].offset = 0;
                } else {
                    component.sections[key].offset += FDX.TOPIC_LIST.limit;
                }
            }
        }

        if (doQuery) {
            // get + update topics
            FDX.TOPIC_LIST.query(component, function(data, component) {

                for (var key in component.sections) {
                    if (data[key]) {
                        component.sections[key].hasMore = data[key].hasMore;
                        _.each(data[key].topics, function(v, k) {
                            v.key = key;
                        });

                        data[key].topics.sort(FDX.TOPIC_LIST.sortFn);

                        var newest = _.first(data[key].topics);
                        if ((newest && newest.created > component.sections[key].newest) || (newest && !component.sections[key].newest)) {
                            component.sections[key].newest = newest.created;
                        }
                        var oldest = _.last(data[key].topics);
                        if ((oldest && oldest.created < component.sections[key].oldest) || (oldest && !component.sections[key].oldest)) {
                            component.sections[key].oldest = oldest.created;
                        }
                        component.buffer = component.buffer.concat(data[key].topics);
                    } else {
                        component.sections[key].hasMore = false;
                    }
                }

                component.buffer.sort(FDX.TOPIC_LIST.sortFn);

                var i = 0,
                    count = 0;

                for (var i = 0; i < component.buffer.length; i++) {
                    if (count < FDX.TOPIC_LIST.maxLoad) {
                        var topic = component.buffer[i];
                        if (i + 1 < component.buffer.length) {
                            var nextTopic = component.buffer[i + 1];
                            if (topic.key !== nextTopic.key) {
                                if (component.sections[topic.key].hasMore && component.sections[topic.key].oldest >= topic.created) {
                                    // there might be results in thet server that should be considered first.
                                    return FDX.TOPIC_LIST.load(component);
                                }
                            } else {
                                count++;
                            }
                        }
                    } else {
                        break;
                    }
                }

                FDX.TOPIC_LIST.renderResults(component);
            });
        } else {
            // simply update topics
            FDX.TOPIC_LIST.renderResults(component);
        }
    },


    // updates the list of topics
    // check the property 'maxLoad' to limit the number of topics loaded at once
    renderResults: function(component) {
        var hasMore = false,
            loaded = 0,
            $node = $('#' + component.id);

        while (loaded < FDX.TOPIC_LIST.maxLoad && component.buffer.length > 0) {
            // get and remove the topic from the buffer
            var topic = component.buffer.shift();
            // fill the HTML with this topic
            FDX.TOPIC_LIST.insertTopic($node, topic);
            loaded++;
        }

        if (loaded > 0) {
            $node.removeClass('fxg-hidden');
        }

        for (s in component.sections) {
            if (component.sections[s].hasMore) {
                hasMore = true;
            }
        }
        hasMore = hasMore || component.buffer.length;

        if (hasMore) {
            $node.find(FDX.TOPIC_LIST.loadingClass).hide();
            $node.find(FDX.TOPIC_LIST.loadMoreWrapper).show();
            $node.find(FDX.TOPIC_LIST.loadMoreClass).show();
        } else {
            $node.find(FDX.TOPIC_LIST.loadMoreWrapper).hide();
        }
    },

    // inserts a new topic in the HTML.
    // there is a base skeleton in this page,
    // containing the base HTML structure that's used
    // to instantiate videos and images
    insertTopic: function($node, topic) {
        // get the skeleton row
        var $row,
            // the topic HTML
            $topicHtml,
            $discard;

        $row = $node.find(FDX.TOPIC_LIST.topicEntryClass).eq(0).clone();
        if (topic.videoID) {

            $topicHtml = $row.find(FDX.TOPIC_LIST.topicVideoClass).eq(0);
            $discard = $row.find(FDX.TOPIC_LIST.topicThumbnailClass).eq(0);

            // create an exclusive id for the video
            var id = 'fxg-topic-' + new Date().getTime(),
                $player = $topicHtml.find(FDX.OOYALA.playerClass);

            // set video properties
            $player.attr('id', id);
            $player.attr('data-container-id', id);
            $player.attr('data-video-id', topic.videoID);
            $player.attr('data-thumbnail', topic.thumbnail);
            $player.removeClass('fxg-hidden');
            // adjust video style
            var style = $topicHtml.find('style').html();
            style = style.replace(FDX.TOPIC_LIST.videoTplId, id);
            style = style.replace(FDX.TOPIC_LIST.videoTplImg, topic.thumbnail);
            $topicHtml.find('style').html(style);
            // init player
            FDX.OOYALA.bindAll($player);
        } else {
            $topicHtml = $row.find(FDX.TOPIC_LIST.topicThumbnailClass).eq(0);
            $discard = $row.find(FDX.TOPIC_LIST.topicVideoClass).eq(0);
        }
        // shared behavior on videos and images
        $row.find(FDX.TOPIC_LIST.topicThumbnail).attr({
            src: topic.thumbnail,
            alt: topic.title
        });
        $row.find(FDX.TOPIC_LIST.topicThumbnail).css({
            "height": topic.thumbnailHeight,
            "width": topic.thumbnailWidth
        });
        $row.find(FDX.TOPIC_LIST.topicTitle).html(topic.title);
        $row.find(FDX.TOPIC_LIST.topicSynopsis).html(topic.synopsis);
        $row.find(FDX.TOPIC_LIST.topicLink).attr('data-analytics', topic.analytics);
        $row.find(FDX.TOPIC_LIST.topicLink).attr('href', topic.path);

        $discard.remove();
        $node.find(FDX.TOPIC_LIST.topicEntryClass).last().after($row);
        $row.show();

    },

    // performs an AJAX call to get topics from JCR
    // the request is made to a resource using this component
    // each of the sections is mapped to a Sling 'selector'
    query: function(component, callback) {
        var uri = component.path,
            searchingPath = component.searchingPath,
            selectors = "",
            paginationInfo = [],
            paramIndex = 0;
        // for each of the sections: 'path', 'folder' and 'tags'
        for (var key in component.sections) {
            var sections = component.sections[key];
            // append a selector to the URI
            // pagination are included at the end
            if (sections.hasMore) {
                selectors += "." + sections.key;

                var offset = parseInt(sections.offset),
                    limit = parseInt(sections.limit);
                if (offset) {
                    paginationInfo.push('o' + paramIndex + '=' + offset);
                }
                if (limit) {
                    paginationInfo.push('l' + paramIndex + '=' + limit);
                }
                paramIndex++;
            }
        }

        if (selectors.length > 0) {
            uri = FDX.contextPath + uri + selectors + '.json?';

            if (searchingPath) {
                uri += 'searchingPath=' + searchingPath + '&';
            }

            if (paginationInfo.length > 0) {
                uri += paginationInfo.join('&');
            }

            $.ajax({
                url: uri,
                beforeSend: function() {
                    $('#' + component.id).find(FDX.TOPIC_LIST.loadingClass).show();
                    $('#' + component.id).find(FDX.TOPIC_LIST.loadMoreClass).hide();
                },
                success: function(data) {
                    callback(data, component);
                }
            });
        }
    },

    // handles the load-more scenario
    handleLoadMore: function(e) {
        e.preventDefault();
        var $component = $(e.target).closest(FDX.TOPIC_LIST.componentClass),
            componentPath = $component.data('resourcePath');
        for (var y = 0; y < FDX.TOPIC_LIST.components.length; y++) {
            if (componentPath === FDX.TOPIC_LIST.components[y].path) {
                FDX.TOPIC_LIST.load(FDX.TOPIC_LIST.components[y]);
            }
        }
    }
}

$(document).ready(function() {
    FDX.TOPIC_LIST.init();

    $(FDX.TOPIC_LIST.loadMoreClass).click(FDX.TOPIC_LIST.handleLoadMore);
});

/* This is the FedEx.com toggle component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-05-01
 */
if (!FDX) {
    var FDX = {};
}

FDX.TOGGLE = {
    toggleClass: "fxg-toggle",
    togglePanelClass: "fxg-toggle__panel",
    toggleActivePanelClass: "fxg-toggle__panel--active",
    toggleSelectorClass: "fxg-toggle__selector",
    toggleContentClass: "fxg-toggle__content",

    setActiveTogglePane: function(pane) {
        $("." + FDX.TOGGLE.toggleActivePanelClass).removeClass(FDX.TOGGLE.toggleActivePanelClass).css('height', '');
        $(pane).addClass(FDX.TOGGLE.toggleActivePanelClass);
        FDX.TOGGLE.setActivePaneHeight(pane);
    },

    setActivePaneHeight: function(pane) {
        var childrenHeight = $(pane).children("." + FDX.TOGGLE.toggleContentClass).outerHeight(true);
        var height = $(pane).css('height', '').height() + childrenHeight;
        $(pane).height(height);
    }
};

$(document).ready(function() {
    $('.' + FDX.TOGGLE.toggleSelectorClass).on('click keydown', function(e) {
        if (e.type === 'keydown' && e.which !== 13) {
            return;
        }
        var pane = $(this).closest("." + FDX.TOGGLE.togglePanelClass);
        if (!$(pane).hasClass(FDX.TOGGLE.toggleActivePanelClass))
            FDX.TOGGLE.setActiveTogglePane(pane);
    });

    FDX.TOGGLE.setActivePaneHeight($('.' + FDX.TOGGLE.toggleActivePanelClass));

    //set height after tab change
    if (FDX.TABS) {
        $('.' + FDX.TABS.tabsNavClass + ' a').on('shown.bs.tab', function(e) {
            FDX.TOGGLE.setActivePaneHeight($('.' + FDX.TOGGLE.toggleActivePanelClass));
        });
    }
});
/*code for adding css only to SM service mark*/

$(document).ready(function() {
    var subscript = /[\u2120]/;

    var target = $(".fxg-supscript").text();
    var op = target.match(subscript);
    if (op) {
        var first = op[0];
        $(".fxg-supscript sup").css({
            "font-family": "Calibri, sans-serif"
        });
        $(".fxg-supscript sup").css({
            "top": "-.15em"
        });
        $(".fxg-supscript sup").css({
            "font-size": "inherit"
        });
        $(".fxg-supscript sup").css({
            "font-weight": "200"
        });
    }
});

/* This is the FedEx.com Timer component javascript file.

 Author: troy.gottier.osv@fedex.com
 Created: 2018-04-17
 */
if (!FDX) {
    var FDX = {};
}
$(document).ready(function() {
    var fxTimerComponents = $(".fxg-timer");
    if (fxTimerComponents.length > 0) {
        var currentDateTime = new Date();

        $.each(fxTimerComponents, function() {
            var thisData = $(this).find(".fxg-timer__data");
            initTimer($(this), currentDateTime, thisData);

        });
    }
});

function initTimer(element, now, data) {
    var timeZone = $.trim(data.find(".td_timeZone").html()),
        start = $.trim(data.find(".td_startDate").html()).slice(0, -6) + timeZone, // replace time zone with the one the author chooses
        end = $.trim(data.find(".td_endDate").html()).slice(0, -6) + timeZone, // replace time zone with the one the author chooses 
        timerContainer = element.find(".timer_js");

    var endDate = new Date(end),
        startDate = new Date(start);

    endDate.setDate(endDate.getDate());

    if (now.getTime() - startDate.getTime() > 0) {
        // start time is past or present
        timer = setInterval(function() {
            countdown(endDate, timerContainer, element);
        }, 1000);
    } else {
        // start time is in the future
        // check every 30 seconds if the future has come to the present 
        element.find(".editmode_message").html("This component is not currently scheduled to show on page. It is scheduled to show on " +
            startDate);
        future_watcher = setInterval(function() {
            silentCountdown(startDate, element, data);
        }, 30000);
    }


}

function silentCountdown(startDate, element, data) {
    var now = new Date();

    if (now.getTime() >= startDate.getTime()) {
        // The future is now
        clearInterval(future_watcher);
        initTimer(element, now, data);
    }
}

function countdown(toDate, timerContainer, component) {
    var dateEntered = toDate;
    var now = new Date();
    var difference = dateEntered.getTime() - now.getTime();


    if (difference <= 0) {
        if (!component.hasClass("isExpired")) {
            // Timer is done hide the component
            var message1 = "This component is currently expired on page ",
                message2 = "and will not show to site users. ";

            if (component.hasClass("alwaysOn")) {
                message2 = 'and will be shown to site users because of it\'s "Keep expired component visible" setting.'
            }
            component.find(".editmode_message").html(message1 + message2 + " This component should be deleted. It expired on " +
                toDate);
            //clearInterval($(this));
            component.removeClass("isInit").addClass("isExpired");
        }
    } else {
        if (component.hasClass("toInit")) {
            component.find(".editmode_message").html("This component is scheduled to be shown to site users. It expires on " +
                toDate);
            component.removeClass("toInit").addClass("isInit");
        }

        var seconds = Math.floor(difference / 1000);
        var minutes = Math.floor(seconds / 60);
        var hours = Math.floor(minutes / 60);
        var days = Math.floor(hours / 24);
        hours %= 24;
        minutes %= 60;
        seconds %= 60;

        if (minutes.toString().length == 1) {
            minutes = "0" + minutes;
        }
        if (seconds.toString().length == 1) {
            seconds = "0" + seconds;
        }

        var dayCont = timerContainer.find(".timer_js__days"),
            hourCont = timerContainer.find(".timer_js__hours"),
            minCont = timerContainer.find(".timer_js__minutes"),
            secCont = timerContainer.find(".timer_js__seconds");

        //update the containers 
        $(dayCont).text(days);
        $(dayCont).attr("aria-label", days + " days");

        $(hourCont).text(hours);
        $(hourCont).attr("aria-label", hours + " hours");

        $(minCont).text(minutes);
        $(minCont).attr("aria-label", minutes + " minutes");

        $(secCont).text(seconds);
        $(secCont).attr("aria-label", seconds + " seconds");

        if (seconds % 15 == 0) {
            // update screen readers every 15 seconds with a live reading of the timer.
            var thisTitle = timerContainer.siblings(".timer_ada").attr("data-title");
            timerContainer.siblings(".timer_ada").html(days + " days, " + hours + " hours, " + minutes + " minutes, " + seconds + " seconds." + thisTitle);
        }
    }
}

/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * Tagged Pages
         *
         * Renders a feed of pages
         */
        (function($, _, window, $components) {
            window.FDX.components.taggedpages = function() {
                /**
                 * @type {Object[]} list of instances
                 */
                var instances = [];
                /**
                 * @type {string} root selector
                 */

                var selector = '.fxg-taggedpages';
                /**
                 * Create component instance
                 *
                 * @public
                 * @return {Object} instance
                 */

                function create() {
                    /**
                     * @type {Object} configuration
                     */
                    var config = {};
                    /**
                     * @type {Object} jQuery DOM root element
                     */

                    var $root = null;
                    /**
                     * @type {Object} accordion instance
                     */

                    var accordion = null;
                    /**
                     * Set configuration
                     *
                     * @public
                     * @param {Object} _config - key/value pair
                     * @return {Object} instance
                     */

                    function setConfig(_config) {
                        var defaultConfig = {
                            view: 'list'
                        };
                        config = $.extend({}, defaultConfig, _config);
                    }

                    ;
                    /**
                     * Render HTML
                     *
                     * @private
                     * @return {Promise<string>} A promise that resolves with rendered HTML
                     */

                    function render(data) {
                        var promise = $.Deferred();
                        var html = "\n            <button class=\"fxg-taggedpages__navigation-button js-taggedpages-faq-navigation-button cc-aem-u-width--100 cc-aem-u-cursor--pointer cc-aem-u-border--none cc-aem-u-px--4 cc-aem-u-py--4 cc-aem-u-flex--inline cc-aem-u-flex-align-items--center cc-aem-u-flex-justify-content--space-between cc-aem-u-bg-color--grey-10 fxg-desktop--hide fxg-tablet--hide\">\n            <span class=\"cc-aem-u-fontweight--bold\">".concat(data.menuLabel, "</span>\n              <fdx-icon class=\"cc-aem-c-button__icon cc-aem-u-color--blue cc-aem-u-fontsize--h5\">\n                  <svg class=\"cc-aem-c-icon\" aria-hidden=\"true\" focusable=\"false\" role=\"presentation\">\n                      <use xlink:href=\"#dots\"></use>\n                  </svg>\n              </fdx-icon>\n            </button>\n        ");
                        return promise.resolve(html);
                    }
                    /**
                     * Initialize component instance
                     *
                     * @public
                     * @param {Object} [_$root] compnent root element (optional)
                     * @return {Promise} A promise that resolves when instance is initiated
                     */


                    function init(_$root) {
                        var promise = $.Deferred();
                        $root = _$root; // initialized

                        $root.data('initialized', true);
                        var isNavigation = $root.find('.js-taggedpages-faq-navigation').length > 0;
                        var navigationButton = document.querySelector('.js-taggedpages-faq-navigation-button');

                        if (isNavigation && !navigationButton) {
                            var navigationElement = $('.js-taggedpages-faq-navigation', $root);
                            var data = {
                                menuLabel: navigationElement.data('faqMenuLabel') || 'Menu'
                            };
                            render(data).then(function(html) {
                                navigationElement.before(html);
                                $('.js-taggedpages-faq-navigation-button', $root).on('click', function() {
                                    $('.js-taggedpages-faq-navigation').each(function() {
                                        $(this).toggleClass('fxg-mobile--hide');
                                    });
                                });
                                promise.resolve();
                            });
                        }

                        var $accordionElement = $components.accordion ? $root.find($components.accordion.selector) : null;

                        if ($accordionElement && $accordionElement.length) {
                            // initialize the Accordion component
                            accordion = $components.accordion.create();
                            accordion.init($accordionElement).then(function() {
                                promise.resolve();
                            });
                        } else {
                            promise.resolve();
                        }

                        return promise;
                    }
                    /**
                     * Get component element
                     *
                     * @public
                     * @return {Object} jQuery DOM element
                     */


                    function getElement() {
                        return $root;
                    } // add and return instance


                    var instance = {
                        setConfig: setConfig,
                        init: init,
                        getElement: getElement
                    };
                    instances.push(instance);
                    return instance;
                }
                /**
                 * Create instances
                 *
                 * @public
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function createInstances() {
                    var promise = $.Deferred();
                    var initPromises = []; // find all related elements

                    $(selector).each(function() {
                        // skip already initialized elements
                        var $element = $(this);
                        if ($element.data('initialized')) return; // create instance

                        var instance = window.FDX.components.taggedpages.create(); // Set configuration

                        var $config = $('[data-config="js-taggedpages-config"]', $element);

                        if ($config.length) {
                            instance.setConfig($.parseJSON($config.html().trim()));
                        } // initialize instance


                        var initPromise = instance.init($element);
                        initPromises.push(initPromise);
                    }); // resolve after all inits

                    $.when.apply($, initPromises).then(function() {
                        promise.resolve();
                    });
                    return promise;
                } // return component


                return {
                    create: create,
                    instances: instances,
                    createInstances: createInstances
                };
            }();
        })(window.jQuery, window._, window, FDX.components);

        /***/
    }),
    /* 2 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // extracted by mini-css-extract-plugin


        /***/
    })
    /******/
]);

/* This is the FedEx.com tabs component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-05-01
 */
if (!FDX) {
    var FDX = {};
}

FDX.TABS = {
    tabsClass: "fxg-tabs",
    tabsNavClass: "nav-tabs",
    toggleNavClass: "nav-toggles",
    initialLoad: false,
    // returns the correct 'location' object
    getLocation: function() {
        if ((typeof(FDX) !== "undefined") && (FDX.SESSION.getCookie('wcmmode') !== null)) {
            // in EDIT mode, edit/read actions should be 
            // performed over parent's location object
            return window.parent.location;
        }
        return window.location;

    },
    // scrolls & select a tab if the current location
    // contains a valid hash
    focusTab: function() {
        var location = FDX.TABS.getLocation(),
            hash = location.hash;
        if (hash && hash.length !== 0) {
            hash = hash.split('?')[0];
            var selector = 'a[role="tab"][href="' + hash + '"]';
            if ($(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
                selector = 'a[data-hash="' + hash + '"]';

            }
            var $element = $("html").find(selector);
            if ($element.length) {
                FDX.TABS.initialLoad = true;
                $element.click();
                var offset = $element.offset().top - 75;
                $("html, body").animate({
                    scrollTop: offset
                });
            }
        }
    },

    setHashLocation: function(newHash) {
        FDX.TABS.getLocation().hash = newHash;
    },
    showSelectedTab: function() {
        if ($(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
            var tabsDropDown = $('.' + FDX.TABS.tabsClass + ' .' + FDX.DROPDOWN.bootstrapDropdownClass);
            var selectedTab = tabsDropDown.find("li.active a");
            $(selectedTab).each(function(e) {
                $(this).closest("div").find(".dropdown-toggle").html($(this).html() + "<span class='fxg-icon'></span>");
            });
        }
    },
    removeActiveOnFirstTab: function(mq) {
        if (mq.matches) {
            if ($('.fxg-tabs').hasClass('cmp-tabs')) {
                $('.cmp-tabs.fxg-tabs').each(function() {
                    if ($(this).find('ul.cmp-tabs__tablist > li').length <= 2) {
                        $('.nav-toggles .cmp-tabs__tab').on('click', function() {
                            $(this).parents('.toggle-view').siblings('.tab-content').find('#\\' + $(this).siblings('.active').attr('id') + '').removeClass('active');
                        })
                    }
                })
            }
        }
    },
    scrollToContent: function(elem) {
        var offset = $(elem).offset().top - 75;
        $("html, body").animate({
            scrollTop: offset
        });
    }
};

$(document).ready(function() {
    $('.' + FDX.TABS.tabsClass + ' .' + FDX.DROPDOWN.bootstrapDropdownClass + ' a').click(function(e) {
        e.preventDefault();
        $('.' + FDX.TABS.tabsNavClass + ' a[href^="' + $(this).data('hash') + '"]').click();
        $('.' + FDX.TABS.toggleNavClass + ' a[href^="' + $(this).data('hash') + '"]').click();

        if ($(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
            var ddItem = $('.' + FDX.TABS.tabsClass + ' .' + FDX.DROPDOWN.bootstrapDropdownClass + ' a[data-hash="' + $(this).data('hash') + '"]');
            $(ddItem).parent().siblings().removeClass('active');
            $(ddItem).parent().addClass('active');
            var active = $(ddItem).parent().parent().parent().find('.dropdown-toggle')
            $(active).html($(this).html() + '<span class="fxg-icon"></span>');
            if (!FDX.TABS.initialLoad) {
                FDX.PODS.destroyCarousel();
                FDX.PODS.initCarousel();
            } else {
                FDX.TABS.initialLoad = false;
            }
        }
    });

    $('.' + FDX.TABS.tabsNavClass + ' a').on('click', function(e) {
        var activeTab = $(this).parents('.' + FDX.TABS.tabsNavClass).siblings('.tab-content').children('.tab-pane.active');
        var videoControl = $(activeTab).find('button.vjs-play-control');
        $(videoControl).each(function() {
            if ($(this).hasClass('vjs-playing')) {
                $(this).click();
            }
        });
        e.preventDefault();
        FDX.TABS.setHashLocation($(this).attr('href'));
        if ($(document).width() > FDX.BREAKPOINTS.MobileMediaQuery) {
            var preTab = $($(this).closest('.' + FDX.TABS.tabsNavClass).find('li.active a')).attr('href');
            $(preTab).fadeOut(500);
            $(this.hash).fadeIn(500);
        }

    });
    $('.fxg-tabs .richtext a[href*="#"]').on('click', function(e) {
        if ($(document).width() >= FDX.BREAKPOINTS.MobileMediaQuery) {
            e.preventDefault();
            e.stopPropagation();
            var getHrefFromAnchor = $(this).attr('href'),
                extractIdFromHref = getHrefFromAnchor.substring(getHrefFromAnchor.lastIndexOf("#") + 1),
                getTabPaneId = '',
                getTabPanes = $(this).closest('.tab-content').children();
            $(getTabPanes).each(function() {
                if ($(this).find('.fxg-rte a').attr('id') == extractIdFromHref) {
                    getTabPaneId = $(this).attr('id');
                    //Legacy Tab
                    if ($(this).parents().hasClass('fxg-wrapper')) {
                        var tabElm = $(this).parents('.tab-content').siblings('.nav.nav-tabs').find('li a[href=' + "'#" + getTabPaneId + "'" + ']');
                        $(tabElm).click();
                        FDX.TABS.scrollToContent($("#" + extractIdFromHref + ""));
                        return false;
                    }
                    //Core Tab
                    if ($(this).parents().hasClass('cmp-wrapper')) {
                        var tabElm = $(this).parents('.tab-content').siblings('.tabs-view').find('li[id=' + "'" + getTabPaneId + "'" + ']');
                        $(tabElm).click();
                        var that = $(tabElm);
                        var preTab = $($(that).closest('.cmp-wrapper .' + FDX.CORETABS.tabsNavClass + " ").find('li.cmp-tabs__tab--active')),
                            preTabContent = $(that).closest('.cmp-wrapper').find('.tab-content div[id="' + $(preTab).attr('id') + '"]'),
                            currTabContent = $(that).closest('.cmp-wrapper').find('.tab-content div[id="' + $(this).attr('id') + '"]');
                        $(preTab).removeClass('cmp-tabs__tab--active active');
                        $(preTabContent).removeClass('cmp-tabs__tabpanel--active');
                        $(that).addClass('cmp-tabs__tab--active active');
                        $(currTabContent).addClass('cmp-tabs__tabpanel--active');
                        FDX.TABS.scrollToContent($("#" + extractIdFromHref + ""));
                        return false;
                    }
                }
            });
        }
    });
    $('.' + FDX.TABS.toggleNavClass + ' a').on('click', function(e) {
        var activeTab = $(this).parents('.' + FDX.TABS.toggleNavClass).siblings('.tab-content').children('.tab-pane.active');
        var videoControl = $(activeTab).find('button.vjs-play-control');
        $(videoControl).each(function() {
            if ($(this).hasClass('vjs-playing')) {
                $(this).click();
            }
        });
        e.preventDefault();
        FDX.TABS.setHashLocation($(this).attr('href'));
        if ($(document).width() > FDX.BREAKPOINTS.MobileMediaQuery) {
            var preTab = $($(this).closest('.' + FDX.TABS.toggleNavClass).find('li.active a')).attr('href');
            $(preTab).fadeOut(500);
            $(this.hash).fadeIn(500);
        }
    });


    FDX.TABS.showSelectedTab();
    // set the focus on the correct tab
    FDX.TABS.focusTab();
    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.TABS.removeActiveOnFirstTab);
});
/* This is the FedEx.com hero component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com, joey.dukeminier@vml.com
 Created: 2017-10-30
 */

if (!FDX) {
    var FDX = {};
}

FDX.ADVTABLE = {
    tableClass: "table.fxg-table",
    advTableClass: ".fxg-table--stackable"
}

$(document).ready(function() {
    $(FDX.ADVTABLE.advTableClass).find(FDX.ADVTABLE.tableClass).each(function(i, e) {
        $(e).stacktable();
    });
});
/* 
This File fixes tables in RTE. 
The AEM 6.2 version of the RTE builds tables that are not valid in terms of HTML5 specifications.
As such, authors can configure table options but those options do not apply to the tables or apply only in some browsers.
This version of RTE was created before HTML5 and it's method of building tables was valid at 1 time, but not now. 
This file is meant as a hot fix. 
To fix the HTML the RTE creates would be a deep rewrite of much of the RTE and since it is core to AEM and many components,
	it was determined that to do so would be too dangerous at this time.
This solution is the easiest way to fix these tables to be valid and to accept author configuration. 

The fixes addressed here. 
> Table width and height attributes - invalid mark up. These attributes are removed and not replaced with css.
> cell padding - invalid mark up. Replaced by setting css padding on all the <td> elements, overrides FX global css.
> cell spacing - invalid mark up. Replaced by setting css border-spacing on the <table> element, overrides FX global css. 
> border - not valid mark up. Replaced with setting border on <table>,<td>,<th> elements
> headers - not valid mark up. only valid on cells and this is on <table>. Just removing it.

 Author: troy.gottier.osv@fedex.com
 Created: 5/3/2018
 */
if (!FDX) {
    var FDX = {};
}

$(document).ready(function() {
    // Advanced tables have a separate script that copies the table and creates mobile cards
    // add table fixer to only the desktop advanced table tables.
    $(".fxg-table.large-only").addClass("tableFixerJS");
    // move tableFixerJS class from the wrapper to the table on basic tables
    // makes it easier to select basic and advanced tables to be fixed without touching advanced mobile tables
    $(".fxg-table-wrapper.tableFixerJS").removeClass("tableFixerJS").find(".fxg-table").addClass("tableFixerJS");
    var tables_to_fix = $(".fxg-table.tableFixerJS");

    //Getting to know if the page is RTL.
    var rightToLeftValue = $('#tableRtl').val();

    $.each(tables_to_fix, function() {
        applyTableFixes($(this));
    });

    function applyTableFixes(table) {
        removeWidthHeight(table);
        removeHeaders(table);
        cellPadding(table);
        cellSpacing(table);
        border(table);
        if (rightToLeftValue === "true") {
            indentRtl(table);
        }
    }

    function removeHeaders(table) {
        // headers attribute is valid on header cells.
        // RTE sets headers="top" to the <table>.
        // Not valid - removed
        table.removeAttr("headers");
    }

    function indentRtl(table) {
        var eachTd = table.find("td,th");
        $.each(eachTd, function() {
            var alignedValue = $(this).css("text-align");
            if (alignedValue === "right") {
                $(this).css("text-align", "left");
            }
            if (alignedValue === "left") {
                $(this).css("text-align", "right");
            }
        });
    }

    function removeWidthHeight(table) {
        // these attributes are invalid for HTML5
        // Height doesn't work at all so it's removed
        // Width works but is overridden by global css so it doesn't even work and is removed. 
        // Width could be applied with css but there is no use case to override this global css property
        table.removeAttr("width");
        table.removeAttr("height");
    }

    function border(table) {
        // table border property sets outside border to a px value of set value
        // table inside borders are always set to 1 px.
        // tables assume 1 value, the 1st value. 10 20 = 10, 20 10 30 20 = 20.
        // we will replicate this in css with the exception of units will be author choice.
        // border colors are unchanged from default border colors. Tables before this did not use default FX colors and this changes nothing.
        // table borders use grooved border style. this is buggy looking if no cellspacing is set so we are using solid instead.
        var border = table.attr("border");
        if (border != 0 && border != "" && border != undefined) {
            border = border.split(/\ +/);
            table.css("border", applyUnits(border, 1) + " solid #8e8e8e");
            table.find("td, th").css("border", "1px solid #8e8e8e");
        }
        table.removeAttr("border");
    }

    function cellPadding(table) {
        // cellpadding is not valid in HTML
        // global css overrides this anyway so setting cellpadding won't work
        // remove this attribute and set the value to css on each <td>
        // author can write anything in this area. there are no instructions on what this area expects.
        // we will assume css style of "n" or "n n" or "n n n" or "n n n n" 
        // px will be assumed value if a unit is not specified or we will use the unit specified
        // RTE defaults cellpadding to 1 so ignore 1. If author sets 1 it will ignored. 2+ is only valid options. "1 1" would also work
        var padding = table.attr("cellpadding");
        if (padding != 0 && padding != 1 && padding != "" && padding != undefined) {
            padding = padding.split(/\ +/);
            table.find("td, th").css("padding", applyUnits(padding, 4));
        }
        table.removeAttr("cellpadding");
    }

    function cellSpacing(table) {
        // cellspacing is not valid in HTML
        // global css overrides this anyway so setting cellspacing won't work
        // remove this attribute and set the value to css on <table>
        // author can write anything in this area. there are no instructions on what this area expects.
        // we will assume css style of "n" or "n n"
        // px will be assumed value if a unit is not specified or we will use the unit specified
        // this can make ugly tables but it's a default option to authors.
        var margin = table.attr("cellspacing");
        if (margin != 0 && margin != "" && margin != undefined) {
            margin = margin.split(/\ +/);
            table.css("border-collapse", "separate");
            table.css("border-spacing", applyUnits(margin, 2));
        }

        table.removeAttr("cellspacing");
    }

    function applyUnits(array, n) {
        var string = "";
        // slice array to n items
        // Max number of items for padding is 4 values.
        // Max number of items for boreder-spacing is 2 values
        // if there is more than n, the author has errored. 
        $.each(array.slice(0, n), function(i, element) {
            // check if element is numeric. This means no unit has been specified.
            // assumption here is if author specified a unit that they specified a correct unit and not a random string.
            if ($.isNumeric(element)) {
                // apply px as the default unit
                element = element + "px";
            }

            string += element + " ";
        });
        return string;
    }
});
/* This is the FedEx.com swipe javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-04-11
 */

if (!FDX) {
    var FDX = {};
}

FDX.SWIPE = {
    instances: [],
    init: function(carousel, callback, options) {
        if (options) {
            window.mySwipe = $(carousel).Swipe(options).data('Swipe');
        } else {
            window.mySwipe = $(carousel).Swipe({
                auto: 0,
                draggable: true,
                autoRestart: false,
                disableScroll: false,
                callback: function(index, element) {
                    if (callback)
                        callback(index, element);
                    if (typeof(FDX.OOYALA) !== 'undefined') {
                        if (FDX.OOYALA.players.length > 0) {
                            FDX.CAROUSEL.checkVideosInCarousel(element.parentNode, element.parentNode);
                        }
                    }
                }
            }).data('Swipe');
        }
        FDX.SWIPE.instances.push(window.mySwipe);
    },

    destroy: function() {
        $.each(FDX.SWIPE.instances, function(key, item) {
            item.kill();
        });
    }
};
/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * Smartbanner
         *
         * Banner promoting a native app on iOS or Android
         */
        try {
            (function($, _, window, $fdx, $utils, $session, $analytics) {
                window.FDX.components.smartbanner = function() {
                    /**
                     * @type {Object[]} list of instances
                     */
                    var instances = [];
                    /**
                     * @type {string} root selector
                     */

                    var selector = '';
                    /**
                     * Create instance
                     *
                     * @public
                     * @return {Object} instance
                     */

                    function create() {
                        /**
                         * @type {Object} configuration
                         */
                        var config = {};
                        /**
                         * @type {Object} jQuery DOM element
                         */

                        var $root = null;
                        /**
                         * @type {Object} gdl params
                         */

                        var gdl_os = {
                            'android': 'Android',
                            'ios': 'iOS',
                            'desktop': 'desktop'
                        };
                        /**
                         * @type {string} current device type
                         */

                        var deviceType = $utils.deviceType().toLowerCase();
                        /**
                         * Set configuration
                         *
                         * @public
                         * @param {Object} _config - key/value pair
                         * @return {Object} instance
                         */

                        function setConfig(_config) {
                            var defaultConfig = {
                                "title": "",
                                "description": "",
                                "buttonText": "",
                                "android_enabled": false,
                                "android_image": "",
                                "android_url": "",
                                "android_instore": "",
                                "ios_enabled": false,
                                "ios_image": "",
                                "ios_url": "",
                                "ios_instore": ""
                            };
                            config = $.extend({}, defaultConfig, _config); // use the config corresponding to the current device

                            config.deviceType = deviceType;
                            config.enabled = config[deviceType + '_enabled'] || false;
                            config.image = config[deviceType + '_image'] || '';
                            config.url = config[deviceType + '_url'] || '';
                            config.instore = config[deviceType + '_instore'] || '';
                        }

                        ;
                        /**
                         * Render HTML
                         *
                         * @public
                         * @return {Promise<string>} A promise that resolves with rendered HTML
                         */

                        function render() {
                            // please be cautious that following classes are used within QA:
                            // - fxg-smartbanner
                            // - fxg-smartbanner__title
                            // - fxg-smartbanner__description
                            // - fxg-smartbanner__instore
                            var promise = $.Deferred();
                            var html = "\n            <div class=\"fxg-smartbanner cc-aem-u-bg-color--grey--light-1 cc-aem-u-color--text cc-aem-u-flex cc-aem-u-flex-align-items--center\n            cc-aem-u-py--2 cc-aem-u-px--4 cc-aem-u-font-size--default cc-aem-u-elevation--z2 cc-aem-u-z-index--low cc-aem-u-position--relative\">\n              <button class=\"fxg-smartbanner__close cc-aem-c-button cc-aem-c-button--icon cc-aem-u-color--grey--dark-1\"\n                  aria-label=\"close\">\n                <svg class=\"cc-aem-c-icon cc-aem-c-icon--super-small\" aria-hidden=\"true\">\n                  <use href=\"#cross\"></use>\n                </svg>\n              </button>\n              <img class=\"fxg-smartbanner__icon cc-aem-u-mx--2\" src=\"<%= image %>\" />\n              <div class=\"cc-aem-u-flex--1\">\n                <div class=\"fxg-smartbanner__title cc-aem-u-fontsize--h5 cc-aem-u-fontweight--bold cc-aem-u-fontsize--small cc-aem-u-line-height--large\">\n                    <%= title %>\n                </div>\n                <div class=\"cc-aem-u-color--grey--dark-3 cc-aem-u-fontsize--extra-small\">\n                  <div class=\"fxg-smartbanner__description\"><%= description %></div>\n                  <div class=\"fxg-smartbanner__instore\"><%= instore %></div>\n                </div>\n              </div>\n              <a class=\"fxg-smartbanner__view cc-aem-c-button cc-aem-u-fontsize--extra-small cc-aem-c-button--condensed\" aria-label=\"view\"\n                 href=\"<%= url %>\" data-analytics=\"link|smartbanner:view in <%= deviceType %>\">\n                <%= buttonText %>\n              </a>\n            </div>\n          ";

                            var rendered = _.template(html)(config);

                            return promise.resolve(rendered);
                        }
                        /**
                         * Initialize component instance
                         *
                         * @public
                         * @param {Object} _$root - compnent root element (optional)
                         * @return {Promise} A promise that resolves when instance is initiated
                         */


                        function init(_$root) {
                            var promise = $.Deferred(); // can it be shown ?

                            var deviceMatch = deviceType === 'ios' || deviceType === 'android';
                            var bannerClosed = $session.getCookie('fdx_smartbanner');

                            if (!deviceMatch || !config.enabled || bannerClosed) {
                                promise.reject();
                                return promise;
                            } // create DOM element


                            render().then(function(html) {
                                $root = $(html); // bind close

                                $('.fxg-smartbanner__close', $root).on('click', function() {
                                    close();
                                }); // bind view

                                $('.fxg-smartbanner__view', $root).on('click', function() {
                                    // let's close the banner and track the view
                                    close(true); // Analytics

                                    var payload = {
                                        gdl: {
                                            category: 'smartbanner',
                                            eventName: 'view',
                                            params: {
                                                'os': gdl_os[deviceType]
                                            }
                                        }
                                        /*,
                                        dtm: {
                                        type: 'link-external',
                                        event: '',
                                        href: this.getAttribute('href') || '',
                                        analyticsText: 'link|smartbanner:view in '+ deviceType,
                                        target: this.getAttribute('target') || ''
                                        }*/

                                    };
                                    $analytics.push(payload);
                                });
                                promise.resolve();
                            });
                            return promise;
                        }
                        /**
                         * Get element
                         *
                         * @public
                         * @return {Object} jQuery DOM element
                         */


                        function getElement() {
                            return $root;
                        }
                        /**
                         * Open the banner
                         *
                         * @param {Object} $container - jQuery DOM container element
                         * @public
                         */


                        function open($container) {
                            // add to DOM
                            $container.append($root);
                            $(document.body).addClass('has-smartbanner');
                            $fdx.HEADER.calcHeight(); // tracking - we need to bind below analytics to a button click
                            // and trigger with 5 seconds delay or else analytics won't be triggered

                            setTimeout(function() {
                                var payload = {
                                    gdl: {
                                        category: 'smartbanner',
                                        eventName: 'impression',
                                        params: {
                                            'os': gdl_os[deviceType]
                                        }
                                    },
                                    dtm: {
                                        type: 'simulate-click',
                                        // 'simulateClick' is for for non existing dom element events.
                                        event: '',
                                        analyticsText: 'smartbanner:impression ' + deviceType,
                                        target: 'samePage'
                                    }
                                };
                                $analytics.push(payload);
                            }, 5000);
                        }
                        /**
                         * Close the banner
                         *
                         * @param {boolean} noTracking - if true skips tracking
                         * @public
                         */


                        function close(noTracking) {
                            // remember the user's decision in a cookie
                            $session.setCookie('fdx_smartbanner', 'force', 7); // remove from DOM

                            $root.remove();
                            $(document.body).removeClass('has-smartbanner'); // re-calculate header height + cookie consent

                            $fdx.HEADER.calcHeight();
                            $fdx.CookieConsent().setPosition($('.fxg-cookie-consent__wrapper')); // tracking

                            if (!noTracking) {
                                var payload = {
                                    gdl: {
                                        category: 'smartbanner',
                                        eventName: 'close',
                                        params: {
                                            'os': gdl_os[deviceType]
                                        }
                                    },
                                    dtm: {
                                        type: 'button',
                                        event: '',
                                        analyticsText: 'smartbanner:close ' + deviceType,
                                        target: 'samePage'
                                    }
                                };
                                $analytics.push(payload);
                            }
                        } // add and return instance


                        var instance = {
                            setConfig: setConfig,
                            render: render,
                            init: init,
                            getElement: getElement,
                            open: open,
                            close: close
                        };
                        instances.push(instance);
                        return instance;
                    }
                    /**
                     * Create instances
                     *
                     * @public
                     * @return {Promise} A promise that resolves when all instances are initiated
                     */


                    function createInstances() {
                        var promise = $.Deferred(); // get config

                        var $config = $.trim($('html').find('[data-config="js-smartbanner-config"]').html());
                        var $container = $('fedex-smart-banner');
                        if (!$config || !$container.length) return;
                        var config = $.parseJSON($config); // create instance

                        var instance = window.FDX.components.smartbanner.create();
                        instance.setConfig(config);
                        instance.init().then(function() {
                            instance.open($container);
                            promise.resolve();
                        });
                        return promise;
                    } // return component


                    return {
                        create: create,
                        instances: instances,
                        createInstances: createInstances,
                        selector: selector
                    };
                }();
            })(window.jQuery, _, window, FDX, FDX.services.utils, FDX.services.session, FDX.services.analytics);
        } catch (e) {
            console.error(e);
        }

        /***/
    }),
    /* 2 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // extracted by mini-css-extract-plugin


        /***/
    })
    /******/
]);
/* This is the FedEx.com Simple Login Wall component javascript file.

 Author: troy.gottier.osv@fedex.com
 Created: 2018-03-27
 */
if (!FDX) {
    var FDX = {};
}
$(document).ready(function() {
    "use strict";
    var form = $(".fx-simple_login_wall"),
        submitButton = $("a.fx-slf_submit_button"),
        inputToValidateL = form.find("[data-validation='list']").find('.to_validate'),
        inputToValidateN = form.find("[data-validation='numeric']").find('.to_validate'),
        errorContainer = '<div role="alert" class="fxg-field__validation"></div>',
        storedValue,
        formIsValid = false;

    function displayError(input, reason) {
        //remove the previous error and display the new error.
        input.siblings(".fxg-field__validation").remove();
        input.addClass("fxg-field__input--error").attr("aria-invalid", "true");
        input.after(errorContainer);
        input.siblings(".fxg-field__validation").text(reason);
    }

    function validateList(value, list) {
        // remove spaces after comma and spit into an array and search for the value
        if ($.inArray(value, list.replace(/,\s+/g, ',').split(',')) >= 0) {
            // Value Found
            return true;
        }
        return false;
    }

    function checkEmpty(fieldContainer) {
        var field = fieldContainer.find("input")
        // Check for empty field submit
        if (field.val() == "") {
            return false;
        }
        return true;
    }
    // On submit of the form. 
    submitButton.on("click", function(e) {
        var thisForm = $(this).closest("form"),
            listValidator = thisForm.find("[data-validation='list']"),
            numberValidator = thisForm.find("[data-validation='numeric']"),
            inputId = thisForm.find(".to_validate").attr('id');

        // On submit if the validation type is list match the value of the input to the list.
        if (listValidator.length) {
            // Send value of the input to be validated to the validateList function
            var value = listValidator.find("input").val();
            formIsValid = validateList(value, FX_VL[inputId]);
        } else if (numberValidator.length) {
            if (checkEmpty(numberValidator) == false) {
                // List type validated nothing against it's list number type needs to check for empty.
                displayError(numberValidator.find("input"), "This field requires a value. It looks like you have entered nothing.");
                return false;
            }
            // This type is mostly validated while typing. if it got this far then it is ok to submit
            formIsValid = true;
        }

        if (formIsValid) {
            // Fix for hitting enter in when in a form field will populate get[] but thats ok.
            thisForm.attr("action", $(this).attr("href"));
            thisForm.submit();
        } else {
            if (listValidator.length) {
                if (checkEmpty(listValidator) == false) {
                    displayError(listValidator.find("input"), "This field requires a value. It looks like you have entered nothing.");
                } else {
                    displayError(listValidator.find("input"), "Sorry, the value specified is incorrect");
                }
            } else {
                // should never get to this. Here in case something went wrong
                displayError(listValidator.find("input"), "An undetermined error has occured. Try Again.");
            }
            e.preventDefault();
        }
    });

    //Pressing enter will use default form submit. Catch it and use custom submit
    form.on("submit", function(e) {
        $(this).find(submitButton).trigger("click");
        return false;
    });

    //Validate numeric fields live while typing
    inputToValidateN.bind('input propertychange', function() {
        var thisInput = $(this),
            thisInputVal = thisInput.val();
        // allow blank in the true statement so people can backspace the first character. they can now put spaces but it won't validate future numbers and they can put as much trailing spaces as they want. it won't harm anything.
        if ($.isNumeric(thisInputVal) || thisInputVal === "") {
            //if value is a number make the storedValue the value
            storedValue = thisInputVal;
            // remove the error container if there is no error to show
            thisInput.removeClass("fxg-field__input--error").attr("aria-invalid", "false");
            thisInput.siblings(".fxg-field__validation").remove();
        } else {
            // if the key pressed is not numeric then reset the value to the stored numeric value. 
            thisInput.val(storedValue);
            displayError(thisInput, "Sorry, this field only accepts valid numbers.");
        }
    });
});
/* Script for show-hide component */
(function($, _, window) {

    /*  //sample show-hide markup can be used any other component
    <div class="fxg-show-hide js-show-hide-init" data-show-more="Show more" data-show-less="Show less">
      <div class="fxg-show-hide__panel js-show-hide-panel" data-collapsed="true" aria-expanded="false" aria-hidden="true">
        {show-hide content}
      </div>

      <div class="fxg-show-hide__trigger js-show-hide-trigger" aria-expanded="false">
        <span class="fxg-show-hide__trigger__icon fxg-plus-minus"></span>
        <span class="fxg-show-hide__trigger__text js-show-hide-trigger-text">{text}</span>
      </div>
    </div>
    */

    if (!window.FDX) {
        window.FDX = {};
    }

    // Module for show-hide Module functionality
    function showHideModule() {

        var Module = function($element, $data) {
            if ($data.initDone === true) {
                // do Nothing if the current element is already initiated
                return true;
            }

            // CONFIG
            var IS_ACTIVE = 'is-active';
            var showMoreLabel = $data.showMore || '';
            var showLessLabel = $data.showLess || '';
            var $showHidePanel = $element.find('.js-show-hide-panel');
            var $showHideTrigger = $element.find('.js-show-hide-trigger');

            $element.attr('data-init-done', true);

            // default to collapse
            $showHidePanel.css('height', '0');

            // function to collapse the showHide-panel
            function collapseSection($el) {
                var element = $el[0];
                var sectionHeight = $el.prop('scrollHeight');

                var elementTransition = element.style.transition;
                $el.css('transition', '');

                // browser call's requestAnimationFrame method to update an animation before the next repaint
                requestAnimationFrame(function() {
                    $el.css('height', sectionHeight + 'px');
                    $el.css('transition', elementTransition);

                    requestAnimationFrame(function() {
                        $el.css('height', '0');
                    });
                });

                $el.data('collapsed', 'true');

            }

            // function to expand the showHide-panel
            function expandSection($el) {

                var element = $el[0];
                var sectionHeight = $el.prop('scrollHeight');
                $el.css('height', sectionHeight + 'px');

                element.addEventListener('transitionend', function transitionendHanlder(e) {
                    element.removeEventListener('transitionend', transitionendHanlder);
                    $el.css('height', '');
                });


                $el.data('collapsed', 'false');

            }

            function showHideHandler(e) {
                e.preventDefault();

                var $showHide = $(e.currentTarget);
                var isCollapsed = $showHidePanel.data('collapsed');
                var $showHideText = $showHide.find('.js-show-hide-trigger-text');

                if (isCollapsed === true || isCollapsed === 'true') {
                    $showHidePanel.data('collapsed', 'false');
                    $showHide.addClass(IS_ACTIVE);
                    $showHideText[0].innerText = showLessLabel;
                    expandSection($showHidePanel);
                    $showHidePanel.attr({
                        'aria-expanded': 'true',
                        'aria-hidden': 'false'
                    });
                    $showHideTrigger.attr({
                        'aria-expanded': 'true'
                    });
                } else {
                    collapseSection($showHidePanel);
                    $showHide.removeClass(IS_ACTIVE);
                    $showHideText[0].innerText = showMoreLabel;
                    $showHidePanel.attr({
                        'aria-expanded': 'false',
                        'aria-hidden': 'true'
                    });
                    $showHideTrigger.attr({
                        'aria-expanded': 'false'
                    });
                }
            }

            // showHide panel for Fuel surcharge component
            function initShowHide() {
                $element.on('click', '.js-show-hide-trigger', function(e) {
                    showHideHandler(e);
                });
            }

            initShowHide();
        };

        var initModule = function($element, $data) {
            Module($element, $data);
        };

        return {
            init: initModule
        };
    }

    // $eles - can be wrapper component or show-hide itself
    var initShowHideComponents = function($eles) {
        var $eles = $eles || $(document);
        if ($eles.length > 0) {
            var SHModule = showHideModule();

            var $elements = $eles.find('.js-show-hide-init').length > 0 ? $eles.find('.js-show-hide-init') : $eles;

            // Process only if any show-hide component found
            if ($elements.length > 0) {
                $.each($elements, function(index, element) {
                    var $element = $(element);
                    var $data = {
                        'showMore': $element.data('showMore') || '',
                        'showLess': $element.data('showLess') || '',
                        'initDone': $element.data('initDone') || ''
                    };

                    // INIT the showHide behaviour
                    SHModule.init($element, $data);
                });
            }
        }
        return true;
    };

    // initiate all the show-hide components on the DOM.
    var $els = $(document);
    initShowHideComponents($els);

    // PUBLIC API, can be used to initiate the SHOW-HIDE component which are added during runtime or for manual trigger.
    // window.FDX.SHOWHIDE.initiate($(document));
    window.FDX.SHOWHIDE = {
        initiate: initShowHideComponents
    };

}(window.jQuery, _, window));

/* This is the FedEx.com SenseAware Powered Google Map component javascript file.

 Author: troy.gottier.osv@fedex.com
 Created: 2018-03-27
 */
if (!FDX) {
    var FDX = {};
}

FDX.SENSEAWAREMAP = {

    mapContainersWrap: $(".fx-senseaware_map_container"),



    initFDX_SA_Map: function() {
        // if the component exists continue to build the map and all it's pins
        var mapContainers = FDX.SENSEAWAREMAP.mapContainersWrap.length > 0;
        if (mapContainers) {
            var mapContainer = FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-senseaware_map"),
                saData = $.trim(FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-sa_data").text()),
                maxHistoryDays = FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-sa_max_days").text(),
                locationsArray = [],
                currentLocation = FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-sa_current_loc"),
                deviceName = FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-sa_device_name").text(),
                startCenter = {
                    lat: 35.0327266,
                    lng: -89.7223417
                }; // default location is FedEx WTC

            var map = new google.maps.Map(mapContainer[0], {
                // These could be made to be dynamically set via AEM dialog.
                // Not currently to keep dialog simple.
                center: startCenter,
                zoom: 6,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                panControl: true,
                zoomControl: true,
                mapTypeControl: true,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.TOP_RIGHT
                },
                scaleControl: true,
                streetViewControl: false,
                overviewMapControl: true,
                rotateControl: true
            });

            // Get data from the SenseAware Device. Data is in XML format
            $.get(saData, function(data) {
                var xmldoc = $("html").find(data).find("markers:first");
                var markerItems = xmldoc.children("marker");
                var dateCutoff = new Date();
                // Exclude the time component and subtract the day range
                dateCutoff = new Date(dateCutoff.getFullYear(), dateCutoff.getMonth(), dateCutoff.getDate() - maxHistoryDays);

                markerItems.each(function() {
                    var latlng = new google.maps.LatLng(parseFloat($(this).attr("lat")), parseFloat($(this).attr("lng")));
                    var date = $(this).attr("date");
                    var type = $(this).attr("type");

                    // SenseAware device gives tim ein zulu/GMT
                    // date converted to local time instead of displaying zulu/GMT time
                    var convert_date = new Date(date + ' UTC').toLocaleString("en-US", {
                            year: 'numeric',
                            month: 'numeric',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: 'numeric',
                            localeMatcher: 'lookup'
                        }),
                        additionalPinInfo = "";

                    // Add in additional info to the location of the device
                    // User set device name, current address.
                    if (type == "present") {
                        var currentAddress = FDX.SENSEAWAREMAP.getCurrentLocation($(this).attr("lat"), $(this).attr("lng"));
                        additionalPinInfo = deviceName + "</br>" + currentAddress + "</br>";
                        // sets the current address in a area for screen readers to read when viewing the map
                        currentLocation.html(currentAddress)
                    }
                    if (new Date(date) >= dateCutoff) FDX.SENSEAWAREMAP.createMarker(additionalPinInfo + convert_date, latlng, type, map);

                });
            }, "xml");

            FDX.SENSEAWAREMAP.buildLocationsArray(locationsArray);

            for (var i = 0, len = locationsArray.length; i < len; i++) {
                // [0] = pin info text, [1] = lat, [2] = lng
                FDX.SENSEAWAREMAP.createStaticMarker(locationsArray[i][0], locationsArray[i][1], locationsArray[i][2], map);
            }
        }
    },

    // ADA - reverse geocode the SenseAware Device to give City, State info for screen readers.
    getCurrentLocation: function(lat, lng) {
        var key = FDX.SENSEAWAREMAP.mapContainersWrap.data('google-api-key'), // FedEx Key
            googleUrl = "https://maps.googleapis.com/maps/api/geocode/json?key=" + key + "&latlng=" + lat + "," + lng + "&sensor=true",
            address;
        // Fetch Address from a lat/lng
        $.ajax({
            url: googleUrl,
            async: false,
            success: function(data) {
                // data.results[n]: n will give various values.
                // 0 will give a full address and is a little too specific and could be a privacy issue.
                // 1 gives City, State Zipcode Country.
                // visit the googleUrl and see more options.
                if (data.results.lenght > 0) {
                    address = data.results[1].formatted_address;
                }
            },
            error: function() {}
        });
        return address;
    },

    // Creates Static Locations Markers
    createStaticMarker: function(pinInfo, latCoord, longCoord, map) {
        var latlng = new google.maps.LatLng(latCoord, longCoord);
        FDX.SENSEAWAREMAP.createMarker("<div style='color: #000000';>" + pinInfo + "</div>", latlng, "static", map);
    },

    buildLocationsArray: function(locationsArray) {
        var locations = FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-sa_location");

        $.each(locations, function() {
            var infoBlock = [],
                name = $(this).find(".fx-sa_location_name").text(),
                street = $(this).find(".fx-sa_street_address").text(),
                csz = $(this).find(".fx-sa_city_state_zip").text(),
                info = $(this).find(".fx-sa_additional_info").text(),
                lat = parseFloat($(this).find(".fx-sa_lat").text()),
                lng = parseFloat($(this).find(".fx-sa_lng").text()),
                formattedInfo;

            if (name) {
                infoBlock.push(name);
            }
            if (street) {
                infoBlock.push(street);
            }
            if (csz) {
                infoBlock.push(csz);
            }
            if (info) {
                infoBlock.push(info);
            }
            // location info formatted for the pin popup
            formattedInfo = infoBlock.join("</br>");

            // add locations to the locationsArray
            locationsArray.push([formattedInfo, lat, lng]);
        });
    },

    // Creates All Marker types
    createMarker: function(infoWindowContent, latlng, type, map) {
        var iconUrl = "";
        var zIndex = 1;
        var pastPin = FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-sa_past_pin").text();
        var staticPin = FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-sa_static_pin").text();
        var presentPin = FDX.SENSEAWAREMAP.mapContainersWrap.find(".fx-sa_present_pin").text();
        var infowindow;

        if (type == "past") {
            iconUrl = pastPin; // not user editable
            zIndex = 5;
        } else if (type == "present") {
            iconUrl = presentPin; // User editable
            zIndex = 100;
        } else if (type == "static") {
            iconUrl = staticPin; // not user editable
            zIndex = 6;
        }

        var marker = new google.maps.Marker({
            position: latlng,
            map: map,
            title: 'FedEx SenseAware Map Marker',
            icon: iconUrl,
            zIndex: zIndex
        });

        google.maps.event.addListener(marker, "click", function() {
            if (infowindow) infowindow.close();
            infowindow = new google.maps.InfoWindow({
                content: infoWindowContent
            });
            infowindow.open(map, marker);
        });

        // Re-center the map on the device's current location
        if (type == "present") map.setCenter(latlng);

        return marker;
    }

};

$(window).load(function() {
    // Make sure google maps api is loaded.
    if (typeof google === 'object' && typeof google.maps === 'object') {
        google.maps.event.addDomListener(window, 'load', FDX.SENSEAWAREMAP.initFDX_SA_Map());
    }
});
/* This is the FedEx.com breadcrumbs component javascript file.
 The global FDX object must already be defined

 */

if (!FDX) {
    var FDX = {};
}

FDX.LOGINCONTAINER = {

    hideContainer: function() {
        var isAuthenticated = FDX.SESSION.userAuthenticated;

        if (isAuthenticated) {
            $(".fxg-loginContainer").show();
            $(".notSecure").hide();
        } else {
            $(".fxg-loginContainer").hide();
            $(".notSecure").show();
        }
        if ($(window).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
            var secureSwipe = $(".securecontainer .fxg-swipe")
            if (secureSwipe.length > 0) {
                FDX.PODS.destroyCarousel();
                FDX.PODS.initCarousel();
                $('.' + FDX.PODS.carouselIndecatorClass).on('click', function() {
                    FDX.PODS.slideOnIndecatorClick(this, $(this).attr('data-index'), $(this).parent().find('.' + FDX.PODS.carouselIndecatorClass + '.active').attr('data-index'));
                });
            }
        }
    }
};

$(document).ready(function() {
    FDX.LOGINCONTAINER.hideContainer();
});
/* This is the FedEx.com submenu component javascript file.
 The global FDX object must already be defined.

 Author: joey.dukeminier@vml.com
 Created: 2017-03-30
 */
if (!FDX) {
    var FDX = {};
}

FDX.SECONDARYMEMU = {
    ActiveItemClass: 'fxg-secondary-menu__item--active',
    linkClass: 'fxg-secondary-menu__link',
    DropdownClass: 'fxg-secondary-menu__dropdown',
    ActiveDropdownClass: 'fxg-secondary-menu__dropdown--active',
    closeBtnClass: 'fxg-secondary-menu__close-btn',
    nextBtnClass: 'fxg-secondary-menu__nav-next',
    prevBtnClass: 'fxg-secondary-menu__nav-prev',
    navClass: 'fxg-secondary-menu__nav',
    activeNavClass: 'fxg-secondary-menu__nav--active',
    navWrapperClass: 'fxg-secondary-menu__nav-wrapper',
    mobileMenuClass: 'fxg-secondary-menu__mobile-toggle',
    activeMobileMenuClass: 'fxg-secondary-menu__mobile-toggle--active',
    aemItemClass: "secondary-menu-item",
    socialBtnClass: "fxg-secondary-menu__social-btn",
    mobileSecondaryMenuCloseId: "fxg-mobile-secondary-icon-close",
    mobileSecondaryMenuIconId: "fxg-mobile-secondary-icon",
    socialDropdownClass: "fxg-secondary-menu__social-dropdown",
    socailLink: "fxg-secondary-menu__social-link",
    isRTL: $('html').attr('dir') === 'rtl' ? true : false,
    clickCounter: 0,
    shrunkClass: "fxg-secondary-header--shrunk",
    secondaryMenu: "fxg-secondary-menu",
    secondaryWrapper: "fxg-secondary-wrapper",
    aria_expanded: 'false',

    linkItemClick: function(link) {
        FDX.SECONDARYMEMU.checkBoldFont();
        var isLinkItemActive = $(link).parent().hasClass(FDX.SECONDARYMEMU.ActiveItemClass);
        var isMobile = FDX.BREAKPOINTS.getMobileMediaQuery().matches;
        if (isMobile) {

            $("a.fxg-linkNoDirect").css({
                'background-color': '',
                'font-weight': 'inherit'
            }); //to reset the background-color from grey to white
            $(link).css({
                'background-color': '',
                'font-weight': '700'
            });
        }

        FDX.SECONDARYMEMU.closeAllDropdowns();
        $('.' + FDX.SECONDARYMEMU.socialDropdownClass).hide();

        var dropdown = $(link).parent().children('.' + FDX.SECONDARYMEMU.DropdownClass);
        dropdown.addClass(FDX.SECONDARYMEMU.ActiveDropdownClass);
        FDX.SECONDARYMEMU.isRTL ? dropdown.css('right', Math.abs($('.' + FDX.SECONDARYMEMU.navClass).css('right').replace(/[^-\d\.]/g, '')) + 'px') : dropdown.css('left', Math.abs($('.' + FDX.SECONDARYMEMU.navClass).css('left').replace(/[^-\d\.]/g, '')) + 'px');

        $(link).parent().addClass(FDX.SECONDARYMEMU.ActiveItemClass);
        if (!isMobile)
            $(link).attr('aria-expanded', 'true');
        $('.' + FDX.SECONDARYMEMU.navClass).addClass(FDX.SECONDARYMEMU.activeNavClass);

        if (isLinkItemActive && !isMobile) {
            dropdown.removeClass(FDX.SECONDARYMEMU.ActiveDropdownClass);
            $(link).parent().removeClass(FDX.SECONDARYMEMU.ActiveItemClass);
            $('.' + FDX.SECONDARYMEMU.navClass).removeClass(FDX.SECONDARYMEMU.activeNavClass);
            $(link).toggleClass('secondary-item-active');
        }

        if (isMobile && isLinkItemActive) {

            $(link).parent().removeClass(FDX.SECONDARYMEMU.ActiveItemClass);
            $(link).css({
                'background-color': '#FAFAFA',
                'font-weight': '700'
            });
        }
    },
    checkBoldFont: function() {
        var directLinks = $(".fxg-linkDirect");
        directLinks.each(function() {
            if ($(this).hasClass('fxg-secNavLinkBold')) {
                $(this).removeClass('fxg-secNavLinkBold');
            }
        });

    },

    saveClickedLinkInfo: function(lnk, txt) {
        var linkInfo = [lnk, txt];
        localStorage.setItem("secNavLink", JSON.stringify(linkInfo));
    },

    getClickedLinkInfo: function() {
        if (localStorage.getItem("secNavLink") === null) {
            return false;
        } else {
            var ItemClicked = localStorage.getItem("secNavLink");
            var getParsedITem = JSON.parse(ItemClicked);
            $(".fxg-secondary-menu a.fxg-linkDirect").each(
                function() {
                    if ($(this).html() == getParsedITem[1] &&
                        $(this).attr('href') == getParsedITem[0]) {
                        $(this).addClass("fxg-secNavLinkBold");
                    };
                })
            localStorage.removeItem("secNavLink");
        }
    },

    closeAllDropdowns: function() {
        $('.' + FDX.SECONDARYMEMU.ActiveItemClass + ' ' + '.fxg-linkNoDirect').removeClass("fxg-secNavLinkBold");
        $('.' + FDX.SECONDARYMEMU.ActiveItemClass).removeClass(FDX.SECONDARYMEMU.ActiveItemClass);
        $('.' + FDX.SECONDARYMEMU.ActiveDropdownClass).removeClass(FDX.SECONDARYMEMU.ActiveDropdownClass);
        $('.' + FDX.SECONDARYMEMU.navClass).removeClass(FDX.SECONDARYMEMU.activeNavClass);
        $('#' + FDX.SECONDARYMEMU.mobileSecondaryMenuCloseId).hide();
        $('#' + FDX.SECONDARYMEMU.mobileSecondaryMenuIconId).show();
    },

    menuNavPrev: function() {
        var nav = $('.' + FDX.SECONDARYMEMU.navClass),
            transitionClass = "transitioning";

        // Prevent clicks from being tracked while transition is sliding the nav 
        if (!nav.hasClass(transitionClass)) {
            nav.addClass(transitionClass);
            // Count how many clicks have been made. + for next - for prev
            FDX.SECONDARYMEMU.clickCounter = FDX.SECONDARYMEMU.clickCounter - 1;

            FDX.SECONDARYMEMU.closeAllDropdowns();


            var wrapper = $('.' + FDX.SECONDARYMEMU.navWrapperClass),
                windowWidth = $(window).width(),
                wrapperWidth = wrapper.width(),
                items = [].reverse.call(nav.children().children()),
                perClickVal = 192,
                sign = FDX.SECONDARYMEMU.isRTL ? '+' : '-';

            nav.css("left", sign + (Math.abs(nav.css('left').replace(/[^-\d\.]/g, '')) - perClickVal) + "px");

            if (FDX.SECONDARYMEMU.isRTL) {
                if (nav.css("left").replace(/[^-\d\.]/g, '') <= perClickVal) {
                    $('.' + FDX.SECONDARYMEMU.prevBtnClass).hide();
                    nav.css("left", "0px");
                }
            } else {
                if (nav.css("left").replace(/[^-\d\.]/g, '') >= -perClickVal) {
                    $('.' + FDX.SECONDARYMEMU.prevBtnClass).hide();
                    nav.css("left", "0px");
                }
            }
            $('.' + FDX.SECONDARYMEMU.nextBtnClass).show();
        }

        // remove transition class once it has been detected that the css transition has ended.
        nav.on('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function() {
            nav.removeClass(transitionClass);
        });
    },

    menuNavNext: function() {
        var nav = $('.' + FDX.SECONDARYMEMU.navClass),
            transitionClass = "transitioning";

        // Prevent clicks from being tracked while transition is sliding the nav 
        if (!nav.hasClass(transitionClass)) {
            nav.addClass(transitionClass);

            // Count how many clicks have been made. + for next - for prev
            FDX.SECONDARYMEMU.clickCounter = FDX.SECONDARYMEMU.clickCounter + 1;

            FDX.SECONDARYMEMU.closeAllDropdowns();

            var wrapper = $('.' + FDX.SECONDARYMEMU.navWrapperClass),
                wrapperWidth = wrapper.width(),
                items = nav.children().children(),
                totalWidth = 0,
                perClickVal = 192,
                sign = FDX.SECONDARYMEMU.isRTL ? '+' : '-',
                lastElement = items.last(),
                windowWidth = $(window).width(),
                wrapperLeft = wrapper.offset().left;

            items.each(function(i) {
                // total width of all items including margin.
                totalWidth += parseInt($(this).outerWidth(true), 10);
            });
            $('.' + FDX.SECONDARYMEMU.prevBtnClass).css('display', 'inline-block');

            nav.css("left", sign + (Math.abs(nav.css('left').replace(/[^-\d\.]/g, '')) + perClickVal) + "px");

            var widthTraveled = Math.abs(nav.css('left').replace(/[^-\d\.]/g, '')) + wrapperWidth - lastElement.outerWidth(true) + (perClickVal * 2);

            if (widthTraveled > totalWidth) {
                $('.' + FDX.SECONDARYMEMU.nextBtnClass).hide();
            }

            if (widthTraveled > totalWidth) {
                nav.css("left", sign + (totalWidth - wrapperWidth) + "px")
            }
        }

        // remove transition class once it has been detected that the css transition has ended.
        nav.on('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function() {
            nav.removeClass(transitionClass);
        });
    },

    showNextButton: function() {
        if (FDX.BREAKPOINTS.getMobileMediaQuery().matches) {
            $('.' + FDX.SECONDARYMEMU.nextBtnClass).hide();
            return false;
        }

        var childrenWidth = 0;
        var childs = $('.' + FDX.SECONDARYMEMU.navClass).children().children();
        childs.each(function(i, e) {
            // Code to calculate widths of element to determine next button
            var outer = parseInt($(this).outerWidth(true), 10);
            childrenWidth += outer;

        });

        if (childrenWidth > $('.' + FDX.SECONDARYMEMU.secondaryWrapper).width()) {
            $('.' + FDX.SECONDARYMEMU.nextBtnClass).css('display', 'inline-block');
        } else if ((childrenWidth > $('.' + FDX.SECONDARYMEMU.navWrapperClass).width()) && !$('.' + FDX.SECONDARYMEMU.navWrapperClass).hasClass('fxg-nosocial')) {
            $('.' + FDX.SECONDARYMEMU.nextBtnClass).css('display', 'inline-block');
        } else {
            $('.' + FDX.SECONDARYMEMU.nextBtnClass).hide();
        }
    },

    showHiddenItem: function(item) {
        var nav = $('.' + FDX.SECONDARYMEMU.navClass),
            transitionClass = "transitioning",
            wrapper = $('.' + FDX.SECONDARYMEMU.navWrapperClass),
            itemOffset = $(item).offset().left + ($(item).width() / 2),
            distanceFromLeftEdge = ($(window).width() - wrapper.width()) / 2,
            rightEdge = wrapper.width() + distanceFromLeftEdge;
        var childrenWidth = 0;
        var itemsWidthCheck = false;
        var childs = $('.' + FDX.SECONDARYMEMU.navClass).children().children();
        childs.each(function(i, e) {
            var outer = $(this).outerWidth(true);
            childrenWidth += outer;
        });
        if (childrenWidth > $('.' + FDX.SECONDARYMEMU.secondaryWrapper).width()) {
            itemsWidthCheck = true;
        }
        if (!FDX.SECONDARYMEMU.isRTL) {
            // normal page configuration logic
            if (itemOffset < 0) {
                nav.css("left", "0px");
                $('.' + FDX.SECONDARYMEMU.prevBtnClass).hide();
                $('.' + FDX.SECONDARYMEMU.nextBtnClass).show();
            } else if (itemOffset > (distanceFromLeftEdge + wrapper.width() / 2) + 100 && itemsWidthCheck) {
                FDX.SECONDARYMEMU.menuNavNext();
            } else if (itemOffset < (distanceFromLeftEdge + wrapper.width() / 2) - 100 && itemsWidthCheck) {
                FDX.SECONDARYMEMU.menuNavPrev();
            }
        } else {
            // Right to Left logic
            if (itemOffset > rightEdge && itemsWidthCheck) {
                nav.css("left", "0px");
                $('.' + FDX.SECONDARYMEMU.prevBtnClass).hide();
                $('.' + FDX.SECONDARYMEMU.nextBtnClass).show();
            } else if (itemOffset < distanceFromLeftEdge + (wrapper.width() / 2) - 100 && itemsWidthCheck) {
                FDX.SECONDARYMEMU.menuNavNext();
            } else if (itemOffset > (distanceFromLeftEdge + wrapper.width() / 2) + 100 && itemsWidthCheck) {
                FDX.SECONDARYMEMU.menuNavPrev();
            }
        }
        nav.removeClass(transitionClass);
    },

    resetBoldForLinks: function() {
        $(".secondary-menu-item").each(function() {
            $(this).find('.fxg-link.bottom-line').removeClass('secondary-item-active').css('font-weight', '');
        });
    },

    resetState: function() {
        FDX.SECONDARYMEMU.closeAllDropdowns();
        $('.' + FDX.SECONDARYMEMU.socialDropdownClass).hide();
        $('.' + FDX.SECONDARYMEMU.activeMobileMenuClass).removeClass(FDX.SECONDARYMEMU.activeMobileMenuClass);
        $('.' + FDX.SECONDARYMEMU.navWrapperClass).css('display', '');
        $('.' + FDX.SECONDARYMEMU.navClass).css('left', '');
        $('.' + FDX.SECONDARYMEMU.prevBtnClass).hide();
        FDX.SECONDARYMEMU.showNextButton();
        FDX.SECONDARYMEMU.resetBoldForLinks();
    },

    toggleSocialMenu: function() {
        FDX.SECONDARYMEMU.closeAllDropdowns();
        $('.' + FDX.SECONDARYMEMU.socialDropdownClass).toggle();
    },

    socialShare: function(site) {
        var siteUrl = encodeURIComponent(window.location.href);

        var winTop = (screen.height / 2) - (400 / 2),
            winLeft = (screen.width / 2) - (600 / 2);
        var strParam = 'width=' + 600 + ',height=' + 400 + ',resizable=' + 'no,' + 'top=' + winTop + ',left=' + winLeft;

        switch (site) {
            case "twitter":
                var objWindow = window.open("http://twitter.com/intent/tweet?&text=" + encodeURIComponent($('head').find('meta[name="twitter:description"]').attr('content')) + "&url=" + siteUrl + "&hashtags=", "", strParam).focus();
                break;
            case "linkedin":
                var objWindow = window.open("http://www.linkedin.com/shareArticle?mini=true&url=" + siteUrl, '', strParam).focus();
                break;
            case "facebook":
                var objWindow = window.open("https://www.facebook.com/sharer/sharer.php?u=" + siteUrl, '', strParam).focus();
                break;
        }
    },

    shrink: function() {
        $('.' + FDX.SECONDARYMEMU.secondaryMenu).addClass(FDX.SECONDARYMEMU.shrunkClass);
    },

    grow: function() {
        $('.' + FDX.SECONDARYMEMU.secondaryMenu).removeClass(FDX.SECONDARYMEMU.shrunkClass);
    },

    scrollCheck: function() {
        if (($(window).scrollTop() > 1) && !$('.' + FDX.SECONDARYMEMU.secondaryMenu).hasClass(FDX.SECONDARYMEMU.shrunkClass)) {
            FDX.SECONDARYMEMU.shrink();
        } else if ($(window).scrollTop() <= 1) {
            FDX.SECONDARYMEMU.grow();
        }
    },

    activeItem: function() {
        $('.secondary-menu-item .fxg-secondary-menu__link').on('click', function() {
            $('.secondary-menu-item .fxg-secondary-menu__link').removeClass('secondary-item-active');
            $(this).addClass('secondary-item-active');
            $(this).attr('aria-expanded', 'true');
        });

    },

    stickyNav: function() {
        if ($("#stickyMenu").val() == "true") {
            var headerHeight = $(".fxg-header").outerHeight(true);
            var ALERT_SHOW = FDX.ALERT.showAlertClass + '.js-alert-header' || 'fxg-alert--show.js-alert-header';
            var WIKI_HEADER = FDX.HEADER.headerWikiClass || 'fxg-wiki-header';
            var gHeights = {
                alerts: 0,
                wikiHeader: 0
            };
            $(window).on('scroll', function() {
                var secMenu = $(".js-secondary-menu");
                var secondaryMenuTopPos = secMenu.offset().top;
                FDX.SECONDARYMEMU.scrollCheck();
                var scrollTop = $(this).scrollTop();
                gHeights.alerts = $('.' + ALERT_SHOW).outerHeight() || 0;
                gHeights.wikiHeader = $('.' + WIKI_HEADER).height() || 0;
                scrollTop = scrollTop + gHeights.alerts + gHeights.wikiHeader + headerHeight;
                if (scrollTop >= secondaryMenuTopPos) {
                    var divHeights = gHeights.alerts + gHeights.wikiHeader + headerHeight;
                    $(".fxg-secondary-menu").addClass("stickyNavigation").css('top', divHeights);
                } else if (scrollTop < secondaryMenuTopPos) {
                    $(".fxg-secondary-menu").removeClass("stickyNavigation").css('top', 0);
                    $(".fxg-secondary-menu").removeClass("fxg-secondary-header--shrunk");
                }
            });
        }
    }
}

$(document).ready(function() {
    FDX.SECONDARYMEMU.activeItem();
    FDX.SECONDARYMEMU.stickyNav();
    FDX.SECONDARYMEMU.showNextButton();
    $('#' + FDX.SECONDARYMEMU.mobileSecondaryMenuIconId).show();
    $('.' + FDX.SECONDARYMEMU.linkClass).on('click', function(e) {
        e.preventDefault();
        FDX.SECONDARYMEMU.linkItemClick(this);
    });
    $(".fxg-secondary-menu__nav ul").clone(true).appendTo("#secnav");

    $(window).keyup(function(e) {
        var code = (e.keyCode ? e.keyCode : e.which);
        if (code == 9 && $('.' + FDX.SECONDARYMEMU.aemItemClass + ' > .' + FDX.LINK.linkClass + ':focus ').length) {
            FDX.SECONDARYMEMU.showHiddenItem($('.' + FDX.SECONDARYMEMU.aemItemClass + ' .' + FDX.LINK.linkClass + ':focus'));
        }
    });

    if ($('.fxg-secondary-menu').find('.fxg-secondary-menu__social').length == 0) {
        $('.fxg-secondary-menu__nav-wrapper').addClass('fxg-nosocial');
    }


    $('.' + FDX.SECONDARYMEMU.closeBtnClass).on('click blur', function(e) {
        e.preventDefault();
        $('.secondary-menu-item .fxg-secondary-menu__link').removeClass('secondary-item-active');
        $('.secondary-menu-item .fxg-secondary-menu__link').attr('aria-expanded', 'false');
        FDX.SECONDARYMEMU.closeAllDropdowns();
        if (e.type == "click") {
            $('.' + FDX.SECONDARYMEMU.socialDropdownClass).hide();
        }
    });

    $('.' + FDX.SECONDARYMEMU.nextBtnClass).on('click', function(e) {
        e.preventDefault();
        FDX.SECONDARYMEMU.menuNavNext();
    });

    $('.' + FDX.SECONDARYMEMU.prevBtnClass).on('click', function(e) {
        e.preventDefault();
        FDX.SECONDARYMEMU.menuNavPrev();
    });

    $('.' + FDX.SECONDARYMEMU.socialBtnClass).on('click', function(e) {
        e.preventDefault();
        FDX.SECONDARYMEMU.toggleSocialMenu();
    });

    $('.' + FDX.SECONDARYMEMU.mobileMenuClass).on('click', function(e) {
        e.preventDefault();
        $('.' + FDX.SECONDARYMEMU.navWrapperClass).hide();
        $(this).toggleClass(FDX.SECONDARYMEMU.activeMobileMenuClass);
    });

    $('.' + FDX.SECONDARYMEMU.socailLink).on('click', function(e) {
        e.preventDefault();
        FDX.SECONDARYMEMU.socialShare($(this).data().site);
    });

    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.SECONDARYMEMU.resetState);

    if ($(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
        $(".fxg-linkNoDirect").keydown(function(e) {
            if (e.which == 9 || e.keyCode == 9) {
                if (($(this).parent().hasClass('fxg-secondary-menu__item--active'))) {
                    $(this).addClass("fxg-secNavLinkBold");
                } else {
                    $(this).css({
                        'background-color': '',
                        'font-weight': 'inherit'
                    });
                }
            }
        })

        $('.fxg-linkNoDirect').on('blur', function(e) {
            $(this).css({
                'background-color': '',
                'font-weight': 'inherit'
            });
        });

        $(".secondary-menu-item").each(function() {
            $(this).find(' a.fxg-link.js-fxgc-init').last().keydown(function(e) {
                if (e.which == 9 || e.keyCode == 9) {
                    $(this).parents('.secondary-menu-item').children().first().removeClass("fxg-secNavLinkBold").addClass("fxg-secNavLinkRegular");
                }
            })
        })
    }

    $(".fxg-linkDirect").on('click', function() {
        FDX.SECONDARYMEMU.saveClickedLinkInfo($(this).attr('href'), $(this).text());
    });

    FDX.SECONDARYMEMU.getClickedLinkInfo();

});

/*Reset the component to initial state when viewport is changed*/
window.addEventListener('orientationchange', function() {
    var nav = $('.' + FDX.SECONDARYMEMU.navClass);

    if ($(nav).length) {

        nav.css("left", "0px");
        var childrenWidth = 0;
        var childs = $('.' + FDX.SECONDARYMEMU.navClass).children().children();
        childs.each(function(i, e) {
            var outer = $(this).outerWidth(true);
            childrenWidth += outer;
        });

        if (childrenWidth > $('.' + FDX.SECONDARYMEMU.navClass).width() && $(document).width() >= FDX.BREAKPOINTS.MobileMediaQuery) {
            $('.' + FDX.SECONDARYMEMU.nextBtnClass).css('display', 'inline-block');
            $('.' + FDX.SECONDARYMEMU.prevBtnClass).hide();
        }

    }
}, false);
/* This JS for RTL for Rich text component

Created: 2018-07-05
*/


$(document).ready(function() {
    var rtlValue = $('#justifyRteRtl').val();
    if (rtlValue === "true") {
        var eachparaValue = $('.richtext').find('.fxg-rte p');
        $.each(eachparaValue, function() {
            var alignedValue = $(this).attr("style");
            if (alignedValue !== undefined && alignedValue.indexOf("margin-left") !== -1) {
                alignedValue = alignedValue.replace("left", "right");
                $(this).attr("style", alignedValue);
            }
        });
    }

    let svg = "<svg width=\"16px\" height=\"16px\" viewbox=\"0 0 14 14\" version=\"1.1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" focusable=\"false\"> <title>Small Gray Icon<\/title> <g id=\"Iconography\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"> <g id=\"Group\" transform=\"translate(1.000000, 1.000000)\" stroke=\"#333333\"> <g id=\"icon_external_link_dark_gray_16x16\" transform=\"translate(0.000000, 0.000000)\"> <g id=\"Group\" transform=\"translate(5.250000, 0.000000)\"> <polyline id=\"Path\" points=\"1.5 0.375 6.375 0.375 6.375 5.25\"><\/polyline> <line x1=\"6\" y1=\"0.75\" x2=\"0\" y2=\"6.75\" id=\"Path\"><\/line> <\/g> <polyline id=\"Path\" points=\"5.25 1.875 0.375 1.875 0.375 11.625 10.125 11.625 10.125 6.75\"><\/polyline> <\/g> <\/g> <\/g> <\/svg>";
    let svg12 = "<svg width=\"12px\" height=\"12px\" viewbox=\"0 0 14 14\" version=\"1.1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" focusable=\"false\"> <title>Small Gray Icon<\/title> <g id=\"Iconography\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"> <g id=\"Group\" transform=\"translate(1.000000, 1.000000)\" stroke=\"#333333\"> <g id=\"icon_external_link_dark_gray_16x16\" transform=\"translate(0.000000, 0.000000)\"> <g id=\"Group\" transform=\"translate(5.250000, 0.000000)\"> <polyline id=\"Path\" points=\"1.5 0.375 6.375 0.375 6.375 5.25\"><\/polyline> <line x1=\"6\" y1=\"0.75\" x2=\"0\" y2=\"6.75\" id=\"Path\"><\/line> <\/g> <polyline id=\"Path\" points=\"5.25 1.875 0.375 1.875 0.375 11.625 10.125 11.625 10.125 6.75\"><\/polyline> <\/g> <\/g> <\/g> <\/svg>";
    let svg24 = "<svg width=\"24px\" height=\"24px\" viewbox=\"0 0 14 14\" version=\"1.1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" focusable=\"false\"> <title>Small Gray Icon<\/title> <g id=\"Iconography\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"> <g id=\"Group\" transform=\"translate(1.000000, 1.000000)\" stroke=\"#333333\"> <g id=\"icon_external_link_dark_gray_16x16\" transform=\"translate(0.000000, 0.000000)\"> <g id=\"Group\" transform=\"translate(5.250000, 0.000000)\"> <polyline id=\"Path\" points=\"1.5 0.375 6.375 0.375 6.375 5.25\"><\/polyline> <line x1=\"6\" y1=\"0.75\" x2=\"0\" y2=\"6.75\" id=\"Path\"><\/line> <\/g> <polyline id=\"Path\" points=\"5.25 1.875 0.375 1.875 0.375 11.625 10.125 11.625 10.125 6.75\"><\/polyline> <\/g> <\/g> <\/g> <\/svg>";
    let svg32 = "<svg width=\"32px\" height=\"32px\" viewbox=\"0 0 14 14\" version=\"1.1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" focusable=\"false\"> <title>Small Gray Icon<\/title> <g id=\"Iconography\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"> <g id=\"Group\" transform=\"translate(1.000000, 1.000000)\" stroke=\"#333333\"> <g id=\"icon_external_link_dark_gray_16x16\" transform=\"translate(0.000000, 0.000000)\"> <g id=\"Group\" transform=\"translate(5.250000, 0.000000)\"> <polyline id=\"Path\" points=\"1.5 0.375 6.375 0.375 6.375 5.25\"><\/polyline> <line x1=\"6\" y1=\"0.75\" x2=\"0\" y2=\"6.75\" id=\"Path\"><\/line> <\/g> <polyline id=\"Path\" points=\"5.25 1.875 0.375 1.875 0.375 11.625 10.125 11.625 10.125 6.75\"><\/polyline> <\/g> <\/g> <\/g> <\/svg>";

    $(".svg-icon-18").html(svg);
    $(".svg-icon-14").html(svg12);
    $(".svg-icon-15").html(svg);
    $(".svg-icon-18").html(svg);
    $(".svg-icon-20").html(svg);
    $(".svg-icon-25").html(svg24);
    $(".svg-icon-30").html(svg24);
    $(".svg-icon-32").html(svg32);
    $(".svg-icon-35").html(svg32);


});

//To Limit the shortParsys within the wrapper
$(window).on('load', function() {
    $('.responsivegrid.shortParsysLayout').each(function() {
        $(this).wrap('<div class="fxg-wrapper"></div>');
    })
});
/* This is the FedEx.com tracking app component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-05-01
 */
if (!FDX) {
    var FDX = {};
}

FDX.RATE_SHIP = {

    googleAPILoaded: false,
    rateAppLoaded: false,
    fromAddress: '',
    toAddress: '',
    localPath: '<base href=' + window.location.pathname + '>',

    loadRateShipScripts: function() {

        //var googleAPIKey = document.getElementById("google-api-key").value;
        var def = $.Deferred();

        if (!FDX.RATE_SHIP.googleAPILoaded) {

            var scriptTag = [];
            for (var i = 0; i < FDX.APPBASE.dependentScripts.length; i++) {
                var scriptID = 'dep' + [i];
                scriptTag[i] = document.createElement('script');
                scriptTag[i].src = FDX.APPBASE.dependentScripts[i];
                scriptTag[i].id = scriptID;
                scriptTag[i].async = true;

                var headTag = document.getElementsByTagName('head')[0];
                headTag.appendChild(scriptTag[i]);
            }



            def.resolve();
            FDX.RATE_SHIP.googleAPILoaded = true;
            // console.log("Google API executed!!");
        }
        return def.promise();
    },

    loadRateShipApp: function() {
        //Steal for App Shell.
        if (FDX.RATE_SHIP.rateAppLoaded == false) {
            try {
                //jQuery.support = jQuery.support || {};
                //jQuery.support.cors = true;
                jQuery.ajax({
                    type: "GET",
                    url: FDX.APPBASE.extAppHTML,
                    cache: false,
                    crossDomain: true,

                    success: function(result) {
                        try {
                            jQuery("#magicRateShipApp").empty();
                            //Adding in head to fix the URL issue
                            //$("head").append(FDX.RATE_SHIP.localPath);
                            $.when(jQuery("#magicRateShipApp").append(result)).then(function() {
                                if (result.indexOf("app-loading") != -1) {
                                    FDX.RATE_SHIP.checkLoadedOrNot();
                                } else {
                                    setTimeout(function() {
                                        FDX.RATE_SHIP.rateAppLoaded = true;
                                    }, 300);
                                }
                            });

                        } catch (e) {
                            //fdx_debug(e, "IM", "loadApp:success");
                        }
                    },

                });
            } catch (e) {
                //fdx_debug(e, "IM", "loadApp:success");
            }
        }
    },
    checkLoadedOrNot: function() {
        var appLoaded = $(".app-loading");
        //  console.log("appLoaded"+appLoaded);
        if (appLoaded != null && appLoaded != undefined) {
            var checkStatus = appLoaded.css("visibility");
            // console.log("checkStatus"+checkStatus);
            if (checkStatus.length > 0 && checkStatus == "hidden") {
                // console.log("checkStatus1"+checkStatus);
                setTimeout(function() {
                    FDX.RATE_SHIP.rateAppLoaded = true;
                }, 300);
            } else {
                setTimeout(function() {
                    FDX.RATE_SHIP.checkLoadedOrNot();
                }, 100);
            }

        } else {
            setTimeout(function() {
                FDX.RATE_SHIP.checkLoadedOrNot();
            }, 100);
        }

    },

    resizePageContent: function() {
        console.warn('resizePageContent() is obsolete, and will be removed in future.');
    },

    externalAppInject: function() {

        var externalAppID = document.getElementById("app-external").value;
        var externalAppURL = document.getElementById("app-external-url").value;
        FDX.APPBASE.loadAppBaseData();

        if ((typeof(externalAppID) !== "undefined") && externalAppID !== null) {

            try {

                jQuery.ajax({
                    type: "GET",
                    url: FDX.APPBASE.extAppHTML,
                    cache: false,
                    crossDomain: true,

                    success: function(result) {
                        try {
                            $.when(jQuery("#" + externalAppID).append(result))
                                .then(function() {
                                    setTimeout(function() {
                                        FDX.CUBE.openApp();
                                    }, 300);
                                });

                        } catch (e) {
                            // fdx_debug(e, "IM", "loadApp:success");
                        }
                    },

                });
            } catch (e) {
                console.error(e);
            }
        }

    }

};

$(document).ready(function() {});
/* This is the FedEx.com help component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-09-03
 */

if (!FDX) {
    var FDX = {};
}

FDX.POPUP = {
    popupClass: '.fxg-link-popup',
    openPopup: function(href) {
        window.open(href, 'fdxPopup', 'width=480, height=960, resizable=no', true);
    }
};

$(document).ready(function() {
    //console.log('loading');
    $(FDX.POPUP.popupClass).on('click', function(e) {
        e.preventDefault();
        FDX.POPUP.openPopup(this.href);
    });
});
/* This is the FedEx.com pods component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-04-11
 */

if (!FDX) {
    var FDX = {};
}

FDX.PODS = {
    carouselClass: "fxg-swipe",
    carouselActiveClass: "fxg-swipe--active",
    carouselWrapperClass: "fxg-swipe__wrapper",
    carouselItemClass: "fxg-swipe__item",
    carouselIndecatorClass: "fxg-slider__indecator",
    carouselIndecatorWrapperClass: "fxg-slider__indecators",
    podsClass: "fxg-pods",
    rightToLeftValue: "" + $('#podsRtl').val() + "",
    initialMove: true,
    carouselsetting: "carouselsetting",

    initMobileCarousel: function(mq) {
        if (mq.matches) { //if mobile
            FDX.PODS.initCarousel();
            $('.' + FDX.PODS.carouselIndecatorClass).on('click', function() {
                FDX.PODS.slideOnIndecatorClick(this, $(this).attr('data-index'), $(this).parent().find('.' + FDX.PODS.carouselIndecatorClass + '.active').attr('data-index'));

            });
        } else {
            FDX.PODS.destroyCarousel();
        }
    },

    initCarousel: function() {
        var activeIndecator = 0;
        FDX.PODS.carouselItemCount = $(this).find('.' + FDX.PODS.carouselItemClass).length;


        $('.' + FDX.PODS.carouselClass).each(function(index, element) {
            var itemCount = $(this).find('.' + FDX.PODS.carouselItemClass).length;
            if (itemCount > 1) { //only activate carousel on more than one item
                $(this).attr('data-count', itemCount);

                var setUpIndecator = function(index, element) {
                    activeIndecator = index % $(element).parent().children().length;
                    if (itemCount == 2 && activeIndecator > 1) {
                        $(element).parent().parent().find('.' + FDX.PODS.carouselIndecatorClass + '.active').removeClass('active');
                        $($(element).parent().parent().find('.' + FDX.PODS.carouselIndecatorClass)[activeIndecator - 2]).addClass('active');
                    } else {
                        $(element).parent().parent().find('.' + FDX.PODS.carouselIndecatorClass + '.active').removeClass('active');
                        $($(element).parent().parent().find('.' + FDX.PODS.carouselIndecatorClass)[activeIndecator]).addClass('active');
                    }
                }

                if (FDX.PODS.rightToLeftValue === "true" && itemCount > 2) {
                    var options = {
                        auto: 0,
                        draggable: true,
                        autoRestart: false,
                        disableScroll: false,
                        callback: setUpIndecator,
                        direction: "rtl"
                    };
                    FDX.SWIPE.init(this, null, options);
                } else if (itemCount == 2) {
                    var options = {
                        auto: 0,
                        draggable: true,
                        autoRestart: false,
                        disableScroll: false,
                        continuous: true,
                        callback: setUpIndecator
                    };

                    FDX.SWIPE.init(this, null, options);
                } else {
                    FDX.SWIPE.init(this, setUpIndecator);
                }

                $(this).addClass(FDX.PODS.carouselActiveClass);
                $(this).append('<ul class="' + FDX.PODS.carouselIndecatorWrapperClass + '"></ul>');
                var wrapper = $(this).find('.' + FDX.PODS.carouselIndecatorWrapperClass)[0];
                for (i = 0; i < itemCount; i++) {
                    var element = "";
                    if (i == activeIndecator) {
                        element = '<li class="' + FDX.PODS.carouselIndecatorClass + ' active"  data-index="' + i + '" ></li>';
                    } else {
                        element = '<li class="' + FDX.PODS.carouselIndecatorClass + '"  data-index="' + i + '"></li>';
                    }
                    $(wrapper).append(element);
                }

                //if count = 2 and has videos
                if (itemCount == 2) {
                    $(this).find('.' + FDX.PODS.carouselItemClass).each(function(i, e) {
                        if (i > 1) {
                            $(e).find('.fxg-ooyala-player').each(function(i, e) {
                                var newId = $(e).attr('id') + 'dup';
                                $(e).attr('id', newId);
                                $(e).attr('data-container-id', newId);
                                console.log(e);
                            });
                        }
                    });
                }
            }
        });
    },

    slideOnIndecatorClick: function(element, index, activeIndex) {
        if (activeIndex == index) {
            FDX.PODS.initialMove = false;
        } else {
            FDX.PODS.initialMove = true;
        }

        var activeSwipe = $(element).closest('.fxg-swipe');
        var dataSwipe = $(activeSwipe).data('Swipe');
        var width = parseInt($(activeSwipe).find('.' + FDX.PODS.carouselItemClass).css('width'), 10);
        if (FDX.PODS.initialMove) {
            $(dataSwipe)[0].move(index, width);
        }
        $(dataSwipe)[0].slide(index);
    },

    slideOnTab: function(element, index, lastIndex) {
        var newIndex = parseInt(index, 10);
        var activeSwipe = $(element).closest('.fxg-swipe');
        var dataSwipe = $(activeSwipe).data('Swipe');
        var width = parseInt($(activeSwipe).find('.' + FDX.PODS.carouselItemClass).css('width'), 10);
        $(dataSwipe)[0].move(index, width);
        $(dataSwipe)[0].slide(index - 1);
    },

    destroyCarousel: function() {
        FDX.SWIPE.destroy();
        $('.' + FDX.PODS.carouselClass + '.' + FDX.PODS.carouselActiveClass).removeClass(FDX.PODS.carouselActiveClass);
        $('.' + FDX.PODS.carouselIndecatorWrapperClass).remove();
        //Swipe.js duplicates when items are less than 3. This removes duplicates. 
        $('.' + FDX.PODS.carouselWrapperClass).each(function(index, element) {
            var itemCount = $(element).parent().attr('data-count');
            if (itemCount < $(element).children().length) {
                var newChildren = $(element).children().splice(0, 2);
                $(element).children().remove();
                $(element).append(newChildren);
            }
        });
    }
}


$(document).ready(function() {
    if ($(window).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
        FDX.PODS.initCarousel();
    }

    $('.' + FDX.PODS.carouselIndecatorClass).on('click', function() {
        FDX.PODS.slideOnIndecatorClick(this, $(this).attr('data-index'), $(this).parent().find('.' + FDX.PODS.carouselIndecatorClass + '.active').attr('data-index'));

    });

    $('.' + FDX.PODS.carouselsetting).on('keydown', function(e) {
        var keyCode = e.keyCode || e.which;
        if (keyCode == 9 || keyCode == 37 || keyCode == 39) {

            $(this).parent().find('.' + FDX.PODS.carouselIndecatorClass).click();

            FDX.PODS.slideOnIndecatorClick(this, $(e.target).parent().attr("data-index"), $(e.target).parent().attr("data-index"));
            $($(this).parent().parent().find(".fxg-slider__indecator active")).removeClass('active');
            $($(this).parent().parent().find(".fxg-slider__indecator")[$(e.target).parent().attr("data-index")]).addClass('active');

        }
    });
    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.PODS.initMobileCarousel);
    if (FDX.PODS.rightToLeftValue === "true") {
        var eachlistValue = $('.fxg-pods').find('.fxg-swipe__item');
        $.each(eachlistValue, function() {
            var alignedValue = $(this).attr("style");
            if (alignedValue !== undefined && alignedValue.indexOf("left") !== -1) {
                alignedValue = alignedValue.replace("left", "right");
                $(this).attr("style", alignedValue);
            }
        });
    }

    $(".fxg-pods .fxg-col p").each(function() {
        if ($(this).text().length == 0) {
            $(this).css("margin-bottom", "0");
        }
    });
});
/* This is the FedEx.com offer component javascript file.
The global FDX object must already be defined.

Author: quantrell.sanford@vml.com
Created: 2017-05-01
*/
if (!FDX) {
    var FDX = {};
}

FDX.OFFER = {

    rightToLeftValue: "" + $('#offer').val() + "",
    alignRTLStyle: function() {
        if (FDX.OFFER.rightToLeftValue === "true") {

            var eachlistValue = $('.fxg-offer').find('.fxg-swipe__item');
            $.each(eachlistValue, function() {
                var alignedValue = $(this).attr("style");
                if (alignedValue !== undefined && alignedValue.indexOf("left") !== -1) {
                    alignedValue = alignedValue.replace("left", "right");
                    $(this).attr("style", alignedValue);
                }
            });
        }
    },


}

$(document).ready(function() {
    FDX.OFFER.alignRTLStyle();
    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.OFFER.alignRTLStyle);
});
(function($, _, window) {
    if (!window.FDX) {
        window.FDX = {};
    }

    function modalTemplate() {
        return '<div class="fxg-u-modal fxg-u-modal<% if (peekaboo) { %> fxg-u-modal--peekaboo<% } %> js-modal"' + 'aria-hidden="true" role="dialog" tabindex="0" aria-live="off">' +
            '<div class="fxg-u-modal__wrapper u-scroll-vertical">' +
            '<div class=" <% if (peekaboo) { %> fxg-wrapper <% } %> <% if (!peekaboo) { %> fxg-u-modal__content <% } %>">' +
            '<div class="js-fxg-u-modal__content"></div>' +
            '</div>' +
            '<% if (closable) { %>' +
            '<a href="#" class="fxg-u-modal__close js-modal-close" title="close"></a>' +
            '<% } %>' +
            '</div>' +
            '</div>';
    }

    /**
     * MODAL module
     */
    function modalModule() {
        var Template = modalTemplate();

        var Module = function(options) {
            var defaultOptions = {
                closable: true,
                peekaboo: false
            };

            // CONFIG
            var $eventBus = $({});
            var config = $.extend({}, defaultOptions, options);
            var $modal;
            var $currentFocus;
            var position;

            var BODY_OPEN = 'has-fxg-u-modal-open';
            var ARIA_HIDDEN = 'aria-hidden';
            var ARIA_LIVE = 'aria-live';
            var TRUE = 'true';
            var FALSE = 'false';

            // check if flexbox is supported or not
            if (!$('body').hasClass('flexbox')) {
                $('body').addClass('no-flexbox');
            }

            /**
             * createPanel
             * create modal and register the required events
             */
            function createPanel() {
                // our Modal html
                $modal = $(_.template(Template)({
                    closable: config.closable,
                    peekaboo: config.peekaboo
                }));

                // append template to our document
                $('body').append($modal);

                // click on close, close modal
                $modal.on('click', '.fxg-u-modal__close', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    close();
                });

                // outside modal close modal
                if (config.closable !== false) {
                    $modal.on('click', function(e) {
                        var $target = $(e.target);
                        var inside = $target.closest('.fxg-u-modal__wrapper').length === 1;
                        // some ng apps remove their view while clicking, so element is not in DOM anymore while we are actually checking
                        var hasBody = $target.closest('body').length === 1;

                        if (!inside && hasBody) {
                            close();
                        }
                    });
                }
            }

            /**
             * PUBLIC API
             */

            var on = function() {
                $eventBus.on.apply($eventBus, arguments);
            };

            var off = function() {
                $eventBus.off.apply($eventBus, arguments);
            };

            var trigger = function() {
                $eventBus.triggerHandler.apply($eventBus, arguments);
            };

            var set = function(content) {
                if (!$modal) {
                    createPanel();
                }

                var $content = $modal.find('.js-fxg-u-modal__content');

                $content.empty();
                $content.append(content);

                // remove root classes from the modal content, or else it might be treated as an root element by css
                $content.find('.root').removeClass('root');

                return $content;
            };

            var open = function() {
                $currentFocus = $(':focus');
                position = $(window).scrollTop();

                $modal.attr(ARIA_HIDDEN, FALSE);
                $modal.attr(ARIA_LIVE, 'polite');

                setTimeout(function() {

                    $modal.addClass('is-open');

                    if (!config.peekaboo) {
                        $('body').addClass(BODY_OPEN);
                    }

                    trigger('open', {});

                }, 100);
            };

            var close = function() {
                $('body').removeClass(BODY_OPEN);

                $modal.attr(ARIA_HIDDEN, TRUE);
                $modal.attr(ARIA_LIVE, 'off');

                $modal.removeClass('is-open');

                $('html, body').animate({
                    scrollTop: position
                }, 100, function() {
                    // give focus back to element which had focus before
                    $currentFocus.focus();
                });

                trigger('close', {});
            };

            var destroy = function() {
                $eventBus = null;
                // first clean events set by consumers
                $modal.find('.fxg-u-modal__content').remove();
                // then remove whole modal
                $modal.remove();
            };

            /**
             * Get component element
             *
             * @public
             * @return {Object} jQuery DOM element
             */
            var getElement = function() {
                return $modal;
            };

            /**
             * API MODULE
             */
            var api = {
                on: on,
                off: off,
                set: set,
                open: open,
                close: close,
                destroy: destroy,
                getElement: getElement
            };

            return api;
        };

        return Module;
    }

    function configuredModal() {

        // Modal and FetchService
        var modalInst = modalModule();

        var $configuredModals = $('.is-fxg-modal');
        if ($configuredModals.length !== 0) {
            $configuredModals.each(function(index, element) {

                var $element = $(element);
                var $data = $element.data();

                // Defect ID : 64103
                // Fix to bypass the Launch script click.js handler logic
                $element.attr('target', '_blank');

                // element can be just a link with href attr or any element with data-content-path attr
                var $contentPath = $data.contentPath || '';
                $contentPath = $element.attr('href') ? $element.attr('href') : $contentPath;

                if ($contentPath !== '') {

                    // remove the '/' character at the end of the url
                    $contentPath = $contentPath.substring($contentPath.length - 1) === '/' ? $contentPath.slice(0, -1) : $contentPath;

                    // check and add '.html' to the content path. As all the content pages should be .html pages.
                    $contentPath = $contentPath.indexOf('.html') === -1 ? $contentPath + '.html' : $contentPath;

                    // new API Instance for each element
                    var modalAPI = modalInst();

                    $element.on('click', function(e) {
                        e.preventDefault();

                        window.FDX.FetchService.get($contentPath, 'html')
                            .done(function(response) {
                                if (!_.isEmpty(response)) {
                                    modalAPI.set(response);
                                    modalAPI.open();
                                }
                            }).fail(function(resp) {
                                console.log('Not a valid content');
                            });
                    });

                }

            });
        }
    }

    configuredModal();

    // PUBLIC API, can be used to create the MODAL instance.
    window.FDX.MODAL = {
        init: modalModule
    };

}(window.jQuery, _, window));
if (!FDX) {
    var FDX = {};
}

FDX.CLIENTLOGIN = {

    authCallResult: "",
    accessToken: "",
    tokenType: "",
    expiresIn: "",
    grantType: "",
    loginData: "",
    userInfo: "",
    userLogout: "",
    logoutCheck: "",
    loginCheck: "",
    adminUrl: "",
    altUrl: "",
    mBoxId: "",
    url: "",
    loginData2: "",
    fclaPagePath: "",
    defaultAccount: "",
    wifmUrlPath: "",
    magsUrlPath: "",
    clientId: "",
    isSecure: false,
    cookiePresent: false,
    getAPIConfigPath: "/mnt/acs-commons/lists/fedex-api-gateway-configs/oauthconfigs.json",
    rewardsUrl: "getrewards.fedex.com",
    rewardsUATUrl: "getrewardsuat.epsilon.com",
    fname: "",
    lname: "",

    setSecureClientId: function(secureCall) {
        FDX.CLIENTLOGIN.isSecure = secureCall;
    },

    setPaths: function(wifm, mags, mbId, fclPage, clientID) {
        FDX.CLIENTLOGIN.wifmUrlPath = wifm;
        FDX.CLIENTLOGIN.magsUrlPath = mags;
        FDX.CLIENTLOGIN.mBoxId = mbId;
        FDX.CLIENTLOGIN.fclaPagePath = fclPage;
        FDX.CLIENTLOGIN.clientId = clientID;

    },
    getOAuthToken: function() {
        //Passing parameters in URL for IE issue, suggested by APIG
        $.ajax({
            type: 'POST',
            url: 'https://' + FDX.SESSION.apiURL + '/auth/oauth/v2/token?' + 'grant_type=' + FDX.SESSION.grantType + '&client_id=' + FDX.SESSION.clientID +
                '&client_secret=' + FDX.SESSION.clientSecret,
            xhrFields: {
                withCredentials: true
            },
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },

            /*data: {
                'client_id': FDX.SESSION.clientID,
                'client_secret': FDX.SESSION.clientSecret,
                'grant_type': FDX.SESSION.grantType
            },*/

            success: function(msg) {
                FDX.CLIENTLOGIN.authCallResult = msg;
                // console.log("******The success result =" + msg);
                var tokenExpireTime = new Date();
                tokenExpireTime.setSeconds(new Date()
                    .getSeconds() + 3600);
                // console.log("TokenExpireTime :"+tokenExpireTime);

                var loginData = {
                    token: FDX.CLIENTLOGIN.authCallResult.access_token,
                    tokenExpireTime: tokenExpireTime
                };

                sessionStorage.setItem("loginDataStorage", JSON.stringify(loginData));
                // console.log("logout check *** :"+FDX.CLIENTLOGIN.logoutCheck);
                // console.log("login check *** :"+FDX.CLIENTLOGIN.loginCheck);

                if (!FDX.CLIENTLOGIN.logoutCheck && !FDX.CLIENTLOGIN.loginCheck) {
                    var userLoggedInDetails = sessionStorage.getItem("userLoggedIn");
                    //FDX.CLIENTLOGIN.doAPIisLoggedIn();
                    if (localStorage.getItem("userLoggedInFlag") != 'true' || (userLoggedInDetails == null || JSON.parse(userLoggedInDetails).output.userLoggedIn == 'false') ||
                        document.cookie.indexOf("fdx_login") <= 0) {
                        FDX.CLIENTLOGIN.doAPIisLoggedIn();
                    } else {
                        FDX.CLIENTLOGIN.doGetUserInfoDetails();
                    }
                }
            },
            error: function(request, status, error) {
                console.log('Error in OAuth call : ', error);
            }
        });


    },

    doAPILogin: function(formData) {

        var userData = '{"userName":"","password":""}';
        var jsonData = JSON.parse(userData);
        jsonData.userName = formData.user;
        jsonData.password = formData.pwd;
        userData = JSON.stringify(jsonData);
        var jsonData = JSON.parse(userData);
        if (sessionStorage.getItem("loginDataStorage") == null) {
            FDX.CLIENTLOGIN.getOAuthToken();
        }
        var parsedObject = JSON.parse(sessionStorage.getItem("loginDataStorage"));
        var tokenExpireTime = new Date(Date.parse(parsedObject.tokenExpireTime));

        if (Date.now() > tokenExpireTime.getTime()) {
            // console.log("***login inside condition check");

            FDX.CLIENTLOGIN.loginCheck = true;

            FDX.CLIENTLOGIN.getOAuthToken();

        }

        var parsedObjectToken = parsedObject.token != undefined ? parsedObject.token : parsedObject.access_token;

        $.ajax({
            type: 'POST',
            url: 'https://' + FDX.SESSION.apiURL + '/user/v2/login/validate',
            xhrFields: {
                withCredentials: true
            },


            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + parsedObjectToken,
                'X-locale': 'en_US',
                'X-loggedin': 'true',
                'X-version': '1.0',
                'X-clientid': 'WCDO'

            },


            data: userData,
            dataType: 'json',

            success: function(msg, status, xhr) {
                FDX.CLIENTLOGIN.loginData = msg;

                // console.log("The success result =" + msg);
                if (typeof(FDX.CLIENTLOGIN.loginData.output.loginCookieOutputVO) !== undefined && FDX.CLIENTLOGIN.loginData.output.loginCookieOutputVO.uuidCookie !== null) {

                    $.ajax({
                        type: 'GET',
                        url: 'https://' + FDX.SESSION.apiURL + '/user/v2/users/userinfo',
                        xhrFields: {
                            withCredentials: true
                        },


                        headers: {

                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + parsedObject.token,
                            'X-locale': 'en_US',
                            'X-loggedin': 'true',
                            'X-version': '1.0',
                            'X-clientid': 'WCDO'

                        },


                        //data : userData,
                        //dataType:'json',

                        success: function(msg, textStatus, xhr) {
                            FDX.CLIENTLOGIN.userInfo = msg;
                            // console.log("The success result =" + msg);

                            if (xhr.status == 200 && typeof(FDX.CLIENTLOGIN.userInfo.output) !== 'undefined') {
                                FDX.CLIENTLOGIN.userDetails = FDX.CLIENTLOGIN.userInfo.output;
                                FDX.CLIENTLOGIN.loginSuccess = true;



                                //Profile update

                                var data = FDX.CLIENTLOGIN.userDetails;
                                if (typeof(data.userProfile) !== 'undefined') {
                                    // The login is Successful so we need to trigger loggedIn event for anyone listening
                                    if (data.userProfile) {
                                        $("#global-login-wrapper")
                                            .trigger("loggedIn", {
                                                "contactName": data.userProfile.userProfileAddress.contact.personName.firstName + " " + data.userProfile.userProfileAddress.contact.personName.lastName,
                                                "userProfile": data.userProfile
                                            });
                                        FDX.SESSION.setUserModel(data.userProfile);
                                    } else {
                                        $("#global-login-wrapper")
                                            .trigger("loggedIn", {
                                                "contactName": data.userProfile.userProfileAddress.contact.personName.firstName + " " + data.userProfile.userProfileAddress.contact.personName.lastName,
                                                "userProfile": null
                                            });
                                    }
                                    FDX.SESSION.setAuthenticated(true); // <--- change this to true if login passed
                                    FDX.UTILNAV.showContactName();
                                    FDX.LOGINCONTAINER.hideContainer();
                                    FDX.UTILNAV.showAuthenticatedState();
                                    FDX.DROPDOWN.closeAllDropdowns();
                                    FDX.SESSION.setUserRewards();
                                    FDX.UTILNAV.toggleRewardPointsLink();
                                    FDX.LINK.showHideLockIcon();

                                    //Deleting secret question and street address.
                                    //Set-up local storage for user profile, for rewards and other apps (VA etc..)
                                    delete FDX.CLIENTLOGIN.userDetails.userProfile.loginInformation.secretQuestion;
                                    delete FDX.CLIENTLOGIN.userDetails.userProfile.userProfileAddress.address.streetLines;
                                    delete FDX.CLIENTLOGIN.userDetails.userProfile.userProfileAddress.contactAncillaryDetail;
                                    sessionStorage.setItem('userDetails', JSON.stringify(FDX.CLIENTLOGIN.userDetails));

                                    //Temp variable to fix SHF session storage clear isssue, SHF will watch this flag.
                                    localStorage.setItem('userLoggedInFlag', true);

                                    edata = {
                                        userProfile: data.userProfile,
                                        UUID: FDX.SESSION.getUUID()
                                    };
                                    // Setup and Send an event for LogIn
                                    var tmpDate = new Date()
                                    eventData = {
                                        eventData: edata,
                                        eventAction: "Header Login",
                                        type: "authentication",
                                        effect: "Change Authenticated State to Logged In",
                                        timestamp: tmpDate.toUTCString()
                                    }
                                    FDX.DATALAYER.event.push(eventData);
                                    if (FDX.LOGIN.loginResourceElement !== '' && FDX.LOGIN.loginResourceType !== '' && !FDX.CLIENTLOGIN.isSecure) {
                                        try {
                                            //eval(FDX.LOGIN.loginResourceFun);
                                            var $element = FDX.LOGIN.loginResourceElement;
                                            if (FDX.LOGIN.loginResourceType === 'OPEN') {
                                                var url = $element.attr("href") || '';
                                                var target = $element.attr("target") || '';
                                                window.open(url, target, '', true);
                                            } else if (FDX.LOGIN.loginResourceType === 'SUBMIT') {
                                                $element[0].submit()
                                            }
                                        } catch (e) {}
                                        FDX.LOGIN.loginResourceFun = "";
                                    }
                                    if (document.cookie.indexOf("fdx_memberType") == -1) {
                                        document.cookie = 'postalCode=' + FDX.SESSION.userModel.userProfileAddress.address.postalCode + ';domain=.fedex.com;path=/' + '; secure';
                                        //Removing MFXR APIG calls, will be back soon.
                                        /*if(typeof(FDX.SESSION.rewardsAPIGEnabled) != 'undefined' && FDX.SESSION.rewardsAPIGEnabled === 'true'){
                                        	FDX.MFXR_APIG.getMFXRAPIGRewards();	
                                        } */

                                        FDX.CLIENTLOGIN.getRewardsKey();

                                    }
                                    if (typeof(FDX.SECUREPAGECHECK) !== "undefined" && sessionStorage.getItem("redirectURL") !== null && sessionStorage.getItem("securePageRequest") == 'true') {
                                        window.open(encodeURI(sessionStorage.getItem("redirectURL")), "_self");
                                        FDX.SECUREPAGECHECK.clearSessionStorage();
                                    }
                                } else {
                                    // If failed
                                    // Reset error message.
                                    if (data.errorList && data.errorList[0].error && data.errorList[0].error.message) {
                                        FDX.LOGIN.loginFailedMessage = data.errorList[0].error.message;
                                    } else {
                                        FDX.LOGIN.loginFailedMessage = "Sorry. Something went wrong. Please re-enter your user name and password to try again.";
                                    }
                                    FDX.LOGIN.showErrorMessage();
                                    FDX.SESSION.setAuthenticated(false); // <--- change this to true if login passed
                                }
                            } else {
                                FDX.LOGIN.loginFailedMessage = "Sorry. Something went wrong. Please re-enter your user name and password to try again.";
                                FDX.LOGIN.showErrorMessage();
                                FDX.SESSION.setAuthenticated(false); // <--- change this to true if login passed
                            }

                        },
                        error: function(response, status, error) {
                            //console.log(error);
                            if (response.responseJSON != null && response.responseJSON.errors && response.responseJSON.errors.length > 0 &&
                                response.responseJSON.errors[0].message) {
                                FDX.LOGIN.loginFailedMessage = decodeURIComponent(escape(response.responseJSON.errors[0].message));
                            } else {
                                FDX.LOGIN.loginFailedMessage = "Sorry. Something went wrong. Please re-enter your user name and password to try again.";
                            }
                            FDX.LOGIN.showErrorMessage();
                            FDX.SESSION.setAuthenticated(false);
                        }
                    });

                }
                //def.resolve();
            },
            error: function(response, status, error) {
                // console.log(error);
                if (response.responseJSON != null && response.responseJSON.errors && response.responseJSON.errors.length > 0 &&
                    response.responseJSON.errors[0].message) {
                    FDX.LOGIN.loginFailedMessage = decodeURIComponent(escape(response.responseJSON.errors[0].message));
                } else {
                    FDX.LOGIN.loginFailedMessage = "Sorry. Something went wrong. Please re-enter your user name and password to try again.";
                }
                FDX.LOGIN.showErrorMessage();
                FDX.SESSION.setAuthenticated(false);
            }
        });
        //return;
    },

    doAPIgetUserInfo: function() {

        var parsedObject = JSON.parse(sessionStorage.getItem("loginDataStorage"));
        var parsedObjectToken = parsedObject.token != undefined ? parsedObject.token : parsedObject.access_token;

        $.ajax({
            type: 'GET',
            url: 'https://' + FDX.SESSION.apiURL + '/user/v2/users/userinfo',
            xhrFields: {
                withCredentials: true
            },


            headers: {

                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + parsedObjectToken,
                'X-locale': 'en_US',
                'X-loggedin': 'true',
                'X-version': '1.0',
                'X-clientid': 'WCDO'

            },


            //data : userData,
            //dataType:'json',

            success: function(msg) {
                FDX.CLIENTLOGIN.userInfo = msg;
                // console.log("The success result =" + msg);

            },
            error: function(request, status, error) {

                // console.log(error);
            }
        });
    },

    doAPILogout: function() {
        var logoutRequest = '{"LogOutRequest":{"processingParameters":{"anonymousTransaction":false,"clientId":"WCDO","clientVersion":"1","returnDetailedErrors":true,"returnLocalizedDateTime":false}}}';
        if (sessionStorage.getItem("loginDataStorage") == null) {
            FDX.CLIENTLOGIN.getOAuthToken();
        }
        if (typeof(fdx) !== 'undefined' && fdx.isBrand !== 'undefined' && fdx.isBrand == "true" && localStorage.hasOwnProperty("okta-token-storage")) {
            FDX.CLIENTLOGIN.doPurpleIdLogout();
        }
        var parsedObject = JSON.parse(sessionStorage.getItem("loginDataStorage"));
        var tokenExpireTime = new Date(Date.parse(parsedObject.tokenExpireTime));
        var iswlgn = $("#wlgn-secure-link").val();
        if (Date.now() > tokenExpireTime.getTime()) {
            // console.log("***Logout inside condition check");
            FDX.CLIENTLOGIN.logoutCheck = true;

            FDX.CLIENTLOGIN.getOAuthToken();

        }
        // console.log("***Logout");
        var parsedObjectToken = parsedObject.token != undefined ? parsedObject.token : parsedObject.access_token;

        $.ajax({
            type: 'PUT',
            url: 'https://' + FDX.SESSION.apiURL + '/user/v2/logout',


            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + parsedObjectToken,
            },
            xhrFields: {
                withCredentials: true
            },

            data: logoutRequest,
            dataType: 'json',

            success: function(msg) {
                FDX.CLIENTLOGIN.userLogout = msg;
                FDX.CLIENTLOGIN.userLogout = msg;
                // console.log("The success result =" + msg);
                var memberType = FDX.SESSION.getRewardTypeCookie();
                if (typeof(memberType) !== undefined && memberType !== null) {
                    FDX.CLIENTLOGIN.rewardsLogout();
                }
                $("#global-login-wrapper")
                    .trigger("loggedOut", {});
                FDX.SESSION.destroyLogedInState();
                FDX.CLIENTLOGIN.fname = "";
                FDX.CLIENTLOGIN.lname = "";
                FDX.CLIENTLOGIN.cookiePresent = false;
                FDX.CLIENTLOGIN.userDetails = undefined;

                FDX.SESSION.setAuthenticated(false);
                FDX.SESSION.setTargetRedirectAuth(false);
                //sessionStorage.removeItem("userAuthenticated");
                FDX.LOGINCONTAINER.hideContainer();

                localStorage.removeItem("targetUserAuthenticated");
                localStorage.removeItem("magsUserCheck");
                FDX.LINK.showHideLockIcon();


                if (typeof(FDX.SECUREPAGECHECK) !== "undefined" && typeof(FDX.LOGINCHECK) !== "undefined") {
                    FDX.LOGINCHECK.userAuthenticated = false;

                    FDX.SECUREPAGECHECK.clearSessionStorage();

                    if (FDX.DATALAYER.page.pageInfo.securePage === "true") {
                        if (typeof(fdx) !== 'undefined' && fdx.isBrand !== 'undefined' && fdx.isBrand == "true") {
                            localStorage.clear();
                            window.open(encodeURI(window.location.origin) + "/fedex-brand/login", "_self");
                        } else {
                            window.open(FDX.SECUREPAGECHECK.getHomePage(), "_self");
                        }
                    } else if (typeof(fdx) !== 'undefined' && fdx.isBrand !== 'undefined' && fdx.isBrand == "true") {
                        localStorage.clear();
                        window.open(encodeURI(window.location.origin) + "/fedex-brand/login", "_self");
                    }
                }
                FDX.UTILNAV.hideContactName();
                if (iswlgn === "true") {
                    FDX.UTILNAV.showWlgnState();
                } else {
                    FDX.UTILNAV.showUnAuthenticatedState();
                }
                localStorage.removeItem("wlgndiv");
                FDX.DROPDOWN.closeAllDropdowns();
                //sessionStorage.removeItem("userAuthenticated");
                //localStorage.removeItem("loginDataStorage");

                function clearListCookies() {
                    var cookies = document.cookie.split(";");
                    for (var i = 0; i < cookies.length; i++) {
                        var spcook = cookies[i].split("=");
                        deleteCookie(spcook[0]);
                    }

                    function deleteCookie(cookiename) {
                        var d = new Date();
                        d.setDate(d.getDate() - 1);
                        var expires = ";expires=" + d;
                        var name = cookiename;

                        var value = "";
                        document.cookie = name + "=" + value + expires + "; path=/acc/html";
                    }
                    window.location = ""; // TO REFRESH THE PAGE
                }


                // Setup and Send an event for LogIn
                var tmpDate = new Date()
                uuid = {
                    userProfile: undefined,
                    UUID: FDX.SESSION.getUUID()
                }
                eventData = {
                    eventData: uuid,
                    eventAction: "Header LogOut",
                    type: "authentication",
                    effect: "Change Authenticated State to Logged Out",
                    timestamp: tmpDate.toUTCString()
                }
                FDX.DATALAYER.event.push(eventData);

            },
            error: function(request, status, error) {

                // console.log(error);
            }
        });
    },

    doAPIisLoggedIn: function() {
        // console.log("*** caling doAPIisLoggedIn");
        var parsedObject = JSON.parse(sessionStorage.getItem("loginDataStorage"));
        var parsedObjectToken = parsedObject.token != undefined ? parsedObject.token : parsedObject.access_token;

        $.ajax({
            type: 'GET',
            url: 'https://' + FDX.SESSION.apiURL + '/user/v2/login',
            xhrFields: {
                withCredentials: true
            },

            cache: false,
            headers: {

                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + parsedObjectToken,
                'X-locale': 'en_US',
                'X-loggedin': 'true',
                'X-version': '1.0',
                'X-clientid': 'WCDO'

            },

            success: function(msg) {
                FDX.CLIENTLOGIN.isLoggedInResponse = msg;
                FDX.CLIENTLOGIN.userLoggedIn = FDX.CLIENTLOGIN.isLoggedInResponse.output.userLoggedIn;
                sessionStorage.setItem("userLoggedIn", JSON.stringify(msg));
                //  console.log("The success user is logged in =" + FDX.CLIENTLOGIN.userLoggedIn);
                //FDX.CLIENTLOGIN.valShippingAccount(formData,"LSHP");
                var savedUserDetails = JSON.parse(sessionStorage.getItem('userDetails'));
                if (FDX.CLIENTLOGIN.userLoggedIn) {
                    //Temp variable to fix SHF session storage clear isssue, SHF will watch this flag.
                    localStorage.setItem('userLoggedInFlag', true);

                    if (savedUserDetails == null || typeof(savedUserDetails) == '') {
                        //Get user info call if isLoggedIn returns true.
                        $.ajax({
                            type: 'GET',
                            url: 'https://' + FDX.SESSION.apiURL + '/user/v2/users/userinfo',
                            xhrFields: {
                                withCredentials: true
                            },


                            headers: {

                                'Accept': 'application/json',
                                'Content-Type': 'application/json',
                                'Authorization': 'Bearer ' + parsedObjectToken,
                                'X-locale': 'en_US',
                                'X-loggedin': 'true',
                                'X-version': '1.0',
                                'X-clientid': 'WCDO'

                            },

                            success: function(msg, textStatus, xhr) {
                                FDX.CLIENTLOGIN.userInfo = msg;
                                //  console.log("The success result user info =" + msg);

                                if (xhr.status == 200 && typeof(FDX.CLIENTLOGIN.userInfo.output) !== 'undefined' &&
                                    typeof(FDX.CLIENTLOGIN.userInfo.output.userProfile) !== 'undefined') {

                                    FDX.CLIENTLOGIN.userDetails = FDX.CLIENTLOGIN.userInfo.output;

                                    //Deleting secret question and street address.
                                    //Set-up local storage for user profile, for rewards and other apps (VA etc..)
                                    delete FDX.CLIENTLOGIN.userDetails.userProfile.loginInformation.secretQuestion;
                                    delete FDX.CLIENTLOGIN.userDetails.userProfile.userProfileAddress.address.streetLines;
                                    delete FDX.CLIENTLOGIN.userDetails.userProfile.userProfileAddress.contactAncillaryDetail;
                                    sessionStorage.setItem('userDetails', JSON.stringify(FDX.CLIENTLOGIN.userDetails));

                                    FDX.SESSION.setUserModel(FDX.CLIENTLOGIN.userDetails.userProfile);
                                    FDX.SESSION.setAuthenticated(true); // <--- change this to true if login passed
                                    FDX.LOGINCONTAINER.hideContainer();
                                    FDX.SESSION.setTargetRedirectAuth(true);
                                    FDX.UTILNAV.showAuthenticatedState();
                                    FDX.UTILNAV.showContactName();
                                    FDX.SESSION.setUserRewards();
                                    FDX.UTILNAV.toggleRewardPointsLink();
                                    FDX.LINK.showHideLockIcon();

                                    var isIE11 = window.navigator.userAgent.indexOf('Trident/');

                                    //Clear session storage if WLGN is enabled
                                    if (typeof(FDX.SECUREPAGECHECK) !== "undefined" && FDX.DATALAYER.page.pageInfo.wlgnURL &&
                                        sessionStorage.getItem("redirectURL") !== null &&
                                        sessionStorage.getItem("securePageRequest") == 'true') {
                                        if (isIE11 > 0) {
                                            if (sessionStorage.getItem("useWLGNValue") == 'true') {
                                                window.open(encodeURI(sessionStorage.getItem("redirectURL")), "_self");
                                                sessionStorage.removeItem("useWLGNValue");
                                                FDX.SECUREPAGECHECK.clearSessionStorage();
                                            }
                                        } else {
                                            if (FDX.DATALAYER.page.pageInfo.useWLGN == 'true') {
                                                window.open(encodeURI(sessionStorage.getItem("redirectURL")), "_self");
                                                FDX.SECUREPAGECHECK.clearSessionStorage();
                                            }
                                        }
                                    }

                                    // Setup and Send an event for LogIn
                                    edata = {
                                        userProfile: FDX.CLIENTLOGIN.userDetails.userProfile,
                                        UUID: FDX.SESSION.getUUID()
                                    };

                                    var tmpDate = new Date()
                                    eventData = {
                                        eventData: edata,
                                        eventAction: "State Verification Logged In",
                                        type: "authentication",
                                        effect: "Indication of logged in state",
                                        timestamp: tmpDate.toUTCString()
                                    }
                                    FDX.DATALAYER.event.push(eventData);
                                    if (document.cookie.indexOf("fdx_memberType") == -1) {
                                        document.cookie = 'postalCode=' + FDX.SESSION.userModel.userProfileAddress.address.postalCode + ';domain=.fedex.com;path=/' + '; secure';
                                        //Removing MFXR APIG calls, will be back soon.
                                        /*if(typeof(FDX.SESSION.rewardsAPIGEnabled) != 'undefined' && FDX.SESSION.rewardsAPIGEnabled === 'true'){
                                        	FDX.MFXR_APIG.getMFXRAPIGRewards();	
                                        }*/

                                        FDX.CLIENTLOGIN.getRewardsKey();

                                    }
                                }

                            },
                        });
                    } else {
                        FDX.CLIENTLOGIN.setupUserData(savedUserDetails);
                    }

                } else {
                    FDX.SESSION.setAuthenticated(false);
                    FDX.SESSION.setTargetRedirectAuth(false);
                    FDX.SESSION.setUserModel(null);
                    FDX.SESSION.userAuthenticated = false;
                    FDX.SESSION.destroyLogedInState();
                    var tmpDate = new Date()
                    uuid = {
                        UUID: FDX.SESSION.getUUID()
                    }
                    eventData = {
                        eventData: uuid,
                        eventAction: "State Verification Anonymous",
                        type: "authentication",
                        effect: "Indication anonymous state notification on page load",
                        timestamp: tmpDate.toUTCString()
                    }
                    FDX.DATALAYER.event.push(eventData);
                }



            },
            error: function(request, status, error) {

                // console.log(error);
                FDX.LOGIN.loginFailedMessage = "Sorry. Something went wrong......";
                FDX.LOGIN.showErrorMessage();
                FDX.SESSION.setAuthenticated(false); // <--- change this to true if login passed
                FDX.SESSION.setTargetRedirectAuth(false);
            }
        });


    },
    doGetUserInfoDetails: function() {
        // console.log("*** caling doAPIisLoggedIn");
        var parsedObject = JSON.parse(sessionStorage.getItem("loginDataStorage"));
        var parsedObjectToken = parsedObject.token != undefined ? parsedObject.token : parsedObject.access_token;

        var userLoggedInDetails = sessionStorage.getItem("userLoggedIn");
        //FDX.CLIENTLOGIN.doAPIisLoggedIn();
        if (document.cookie.indexOf("fdx_login") > 0 && FDX.SESSION.getCookie(FDX.SESSION.COOKIENAMES.login) != 'no' && (localStorage.getItem("userLoggedInFlag") == 'true' || (userLoggedInDetails != null || JSON.parse(userLoggedInDetails).output.userLoggedIn == 'true'))) {
            var savedUserDetails = JSON.parse(sessionStorage.getItem('userDetails'));
            if (savedUserDetails == null || typeof(savedUserDetails) == '') {
                //Get user info call if isLoggedIn returns true.
                $.ajax({
                    type: 'GET',
                    url: 'https://' + FDX.SESSION.apiURL + '/user/v2/users/userinfo',
                    xhrFields: {
                        withCredentials: true
                    },


                    headers: {

                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + parsedObjectToken,
                        'X-locale': 'en_US',
                        'X-loggedin': 'true',
                        'X-version': '1.0',
                        'X-clientid': 'WCDO'

                    },

                    success: function(msg, textStatus, xhr) {
                        FDX.CLIENTLOGIN.userInfo = msg;
                        //  console.log("The success result user info =" + msg);

                        if (xhr.status == 200 && typeof(FDX.CLIENTLOGIN.userInfo.output) !== 'undefined' &&
                            typeof(FDX.CLIENTLOGIN.userInfo.output.userProfile) !== 'undefined') {

                            FDX.CLIENTLOGIN.userDetails = FDX.CLIENTLOGIN.userInfo.output;

                            //Deleting secret question and street address.
                            //Set-up local storage for user profile, for rewards and other apps (VA etc..)
                            delete FDX.CLIENTLOGIN.userDetails.userProfile.loginInformation.secretQuestion;
                            delete FDX.CLIENTLOGIN.userDetails.userProfile.userProfileAddress.address.streetLines;
                            delete FDX.CLIENTLOGIN.userDetails.userProfile.userProfileAddress.contactAncillaryDetail;
                            sessionStorage.setItem('userDetails', JSON.stringify(FDX.CLIENTLOGIN.userDetails));

                            FDX.SESSION.setUserModel(FDX.CLIENTLOGIN.userDetails.userProfile);
                            FDX.SESSION.setAuthenticated(true); // <--- change this to true if login passed
                            FDX.LOGINCONTAINER.hideContainer();
                            FDX.SESSION.setTargetRedirectAuth(true);
                            FDX.UTILNAV.showAuthenticatedState();
                            FDX.UTILNAV.showContactName();
                            FDX.SESSION.setUserRewards();
                            FDX.UTILNAV.toggleRewardPointsLink();
                            FDX.LINK.showHideLockIcon();

                            var isIE11 = window.navigator.userAgent.indexOf('Trident/');

                            //Clear session storage if WLGN is enabled
                            if (typeof(FDX.SECUREPAGECHECK) !== "undefined" && FDX.DATALAYER.page.pageInfo.wlgnURL &&
                                sessionStorage.getItem("redirectURL") !== null &&
                                sessionStorage.getItem("securePageRequest") == 'true') {
                                if (isIE11 > 0) {
                                    if (sessionStorage.getItem("useWLGNValue") == 'true') {
                                        window.open(encodeURI(sessionStorage.getItem("redirectURL")), "_self");
                                        sessionStorage.removeItem("useWLGNValue");
                                        FDX.SECUREPAGECHECK.clearSessionStorage();
                                    }
                                } else {
                                    if (FDX.DATALAYER.page.pageInfo.useWLGN == 'true') {
                                        window.open(encodeURI(sessionStorage.getItem("redirectURL")), "_self");
                                        FDX.SECUREPAGECHECK.clearSessionStorage();
                                    }
                                }
                            }

                            // Setup and Send an event for LogIn
                            edata = {
                                userProfile: FDX.CLIENTLOGIN.userDetails.userProfile,
                                UUID: FDX.SESSION.getUUID()
                            };

                            var tmpDate = new Date()
                            eventData = {
                                eventData: edata,
                                eventAction: "State Verification Logged In",
                                type: "authentication",
                                effect: "Indication of logged in state",
                                timestamp: tmpDate.toUTCString()
                            }
                            FDX.DATALAYER.event.push(eventData);
                            if (document.cookie.indexOf("fdx_memberType") == -1) {
                                document.cookie = 'postalCode=' + FDX.SESSION.userModel.userProfileAddress.address.postalCode + ';domain=.fedex.com;path=/' + '; secure';
                                //Removing MFXR APIG calls, will be back soon.
                                /*if(typeof(FDX.SESSION.rewardsAPIGEnabled) != 'undefined' && FDX.SESSION.rewardsAPIGEnabled === 'true'){
                                	FDX.MFXR_APIG.getMFXRAPIGRewards();	
                                }*/

                                FDX.CLIENTLOGIN.getRewardsKey();

                            }
                        }

                    },
                });
            } else {
                FDX.CLIENTLOGIN.setupUserData(savedUserDetails);
            }

        } else {
            FDX.SESSION.setAuthenticated(false);
            FDX.SESSION.setTargetRedirectAuth(false);
            FDX.SESSION.setUserModel(null);
            FDX.SESSION.userAuthenticated = false;
            FDX.SESSION.destroyLogedInState();
            var tmpDate = new Date()
            uuid = {
                UUID: FDX.SESSION.getUUID()
            }
            eventData = {
                eventData: uuid,
                eventAction: "State Verification Anonymous",
                type: "authentication",
                effect: "Indication anonymous state notification on page load",
                timestamp: tmpDate.toUTCString()
            }
            FDX.DATALAYER.event.push(eventData);
        }

    },

    getRewardsKey: function() {
        // console.log("inside getRewardsKey1");
        var asyncRequestObject = new XMLHttpRequest();
        asyncRequestObject.open('GET', '/etc/services/rewardskey.json');
        asyncRequestObject.onload = handleSuccess;
        asyncRequestObject.send();

        function handleSuccess() {
            if (this.responseText) {
                FDX.SESSION.rewardsKey = this.responseText;
                //		console.log(this.responseText);
                FDX.CLIENTLOGIN.doAPIRewards();
            }
        }
    },
    doAPIRewards: function() {
        var domainName = window.location.hostname;
        var rewardsHost = "";
        if (domainName.indexOf("www.fedex") > -1) {
            rewardsHost = FDX.SESSION.rewardsHost;
        } else {
            rewardsHost = FDX.SESSION.rewardsUATHost;
        }
        var rewardsData = '{"member_Info_Request":{"uuid":"","apiSource":"MOBILE","locale":"en_us","key":""}}';
        var jsonData = JSON.parse(rewardsData);
        jsonData.member_Info_Request.uuid = FDX.SESSION.getUUID();
        jsonData.member_Info_Request.key = FDX.SESSION.rewardsKey;
        rewardsData = JSON.stringify(jsonData);
        $.ajax({
            type: 'GET',
            url: 'https://' + rewardsHost + '/getMemberInfo?data=' + encodeURIComponent(rewardsData),
            success: function(data) {
                if (data) {

                    var rewardsResp = JSON.parse(data);
                    var pointsAvailable = "0";
                    if (typeof(rewardsResp.member_Info_Response.memberType) != undefined &&
                        rewardsResp.member_Info_Response.memberType != null) {
                        var memberType = rewardsResp.member_Info_Response.memberType
                        document.cookie = 'fdx_memberType=' + memberType + ';domain=.fedex.com;path=/';
                        if (typeof(rewardsResp.member_Info_Response) != undefined && rewardsResp.member_Info_Response.pointsSummary != undefined &&
                            rewardsResp.member_Info_Response.pointsSummary.pointsAvailable != null) {
                            pointsAvailable = rewardsResp.member_Info_Response.pointsSummary.pointsAvailable

                        }
                        document.cookie = 'fdx_rewardPoints=' + pointsAvailable + ';domain=.fedex.com;path=/';
                    }

                    FDX.SESSION.setUserRewards();
                    FDX.UTILNAV.toggleRewardPointsLink();
                }
            }
        });
    },

    rewardsLogout: function() {
        var domainName = window.location.hostname;
        var rewardsURL = "";
        if (domainName.indexOf("www.fedex") > -1) {
            rewardsURL = FDX.CLIENTLOGIN.rewardsUrl;
        } else {
            rewardsURL = FDX.CLIENTLOGIN.rewardsUATUrl;
        }
        $.ajax({
            type: "POST",
            url: 'https://' + rewardsURL + '/services/logout',
            xhrFields: {
                withCredentials: true
            },
            success: function(data) {
                // check if catalog logout is required, will be implemented later.
                //var returnPage = JSON.parse(data).returnPage;
                console.log("rewards user logged-out sucessfully ");
            }
        });
    },

    setupUserData: function(userData) {

        FDX.CLIENTLOGIN.userDetails = userData;
        FDX.LINK.showHideLockIcon();

        FDX.SESSION.setUserModel(FDX.CLIENTLOGIN.userDetails.userProfile);
        FDX.SESSION.setAuthenticated(true); // <--- change this to true if login passed
        FDX.SESSION.setTargetRedirectAuth(true);
        FDX.LOGINCONTAINER.hideContainer();
        FDX.UTILNAV.showAuthenticatedState();
        FDX.UTILNAV.showContactName();
        FDX.SESSION.setUserRewards();
        FDX.UTILNAV.toggleRewardPointsLink();

        // Setup and Send an event for LogIn
        edata = {
            userProfile: FDX.CLIENTLOGIN.userDetails.userProfile,
            UUID: FDX.SESSION.getUUID()
        };

        var tmpDate = new Date()
        eventData = {
            eventData: edata,
            eventAction: "State Verification Logged In",
            type: "authentication",
            effect: "Indication of logged in state",
            timestamp: tmpDate.toUTCString()
        }
        FDX.DATALAYER.event.push(eventData);
        if (document.cookie.indexOf("fdx_memberType") == -1) {
            //Removing MFXR APIG calls, will be back soon.
            /*if(typeof(FDX.SESSION.rewardsAPIGEnabled) != 'undefined' && FDX.SESSION.rewardsAPIGEnabled === 'true'){
            	FDX.MFXR_APIG.getMFXRAPIGRewards();	
            }*/

            FDX.CLIENTLOGIN.getRewardsKey();

        }
    },
    doPurpleIdLogout: function() {
        localStorage.clear();
        window.open(encodeURI(window.location.origin) + "/fedex-brand/login", "_self");
    }

}

/* This is the FedEx.com login_module app javascript file.
 The global FDX object must already be defined.
 It is dependent on the FDX.SESSION object, which is included as a dependency.

 Author: joey.dukeminier@vml.com
 Created: 2017-03-27
 */
if (!FDX) {
    var FDX = {};
}

FDX.LOGIN = {
    rootElement: "",
    loginShowText: "",
    loginShowAltText: "",
    loginHideText: "",
    loginHideAltText: "",
    navLoginPassword: "",
    navLoginPasswordShow: "",
    loginFormID: "#HeaderLogin",
    loginFailedClass: "fxg-login-error",
    loginFailedMessage: "An undefined error occurred.",
    loginResourceElement: "",
    loginResourceType: "",
    //isSecure : false,


    loginConfigs: function() {
        FDX.LOGIN.rootElement = $(".js-fxg-login-module");
        FDX.LOGIN.loginShowText = FDX.LOGIN.rootElement.data("show");
        FDX.LOGIN.loginShowAltText = FDX.LOGIN.rootElement.data("altshow");
        FDX.LOGIN.loginHideAltText = FDX.LOGIN.rootElement.data("althide");
        FDX.LOGIN.loginHideText = FDX.LOGIN.rootElement.data("hide");
        FDX.LOGIN.navLoginPassword = FDX.LOGIN.rootElement.find("#NavLoginPassword");
        FDX.LOGIN.navLoginPasswordShow = FDX.LOGIN.rootElement.find("#NavLoginPassword_show");
    },

    doLogin: function(form) {
        // This is the stub method to perform the login
        // FedEx IT should pickup from here.
        // Should also return error message to populate error placeholder.

        // Remove any existing error message.
        FDX.LOGIN.removeErrorMessage();

        // FIRST, Check if user is already logged in. Do not run this again if already logged in
        if (FDX.SESSION.userAuthenticated == false || FDX.SESSION.targetRedirectAuth == false) {
            // Get login form data and create object
            var formData = $(form).serializeArray().reduce(function(obj, item) {
                obj[item.name] = item.value;
                return obj;
            }, {});
            // formData is an object that contains all form values as props
            // Example: formData.url, formData.user, formData.password

            // Remember Me Logic
            if (formData.rememberme == 'rememberme') {
                // set remember me cookie
                FDX.SESSION.setRememberMe(formData.user, 30); // <-- Number of days. Adjusted for how long the remember me should be held.
            } else {
                // destroy remember me cookie if it exists
                FDX.SESSION.destroyRememberMe('', -1);
            }

            // Check runMode...debug is used for testing
            if (FDX.CORE.runMode == "debug") {
                // If runMode is debug, we set the mock cookies
                //console.log("You are in debug mode");
                FDX.SESSION.setMockCookies(1); // argument passed in is the expiration time (days)
                FDX.SESSION.setAuthenticated(true);
                FDX.SESSION.setTargetRedirectAuth(true);
                FDX.SESSION.setUserRewards();
                FDX.LOGIN.loginFailedMessage = "";
            } else if (FDX.CORE.runMode == "production") {
                // TODO: FedEx IT pick up from here to do login
                // DO LIVE LOGIN

                FDX.LOGIN.loginFailedMessage = "";

                if (FDX.LINK.isShippingCall || FDX.SESSION.cubeShippipng) {
                    //console.log("*** Calling Shipping API ***");
                    //528073 : Modify AEM code to call the new JS
                    FDX.SHIPPINGROUTING.valShippingAccount(formData);
                } else {
                    //console.log("*** Calling doAPILogin *** ");
                    FDX.CLIENTLOGIN.doAPILogin(formData);
                }

            }

        }
    },

    doLogout: function() {
        FDX.LOGIN.preLogOut();
        if (FDX.CORE.runMode == "debug") {
            // If runMode is debug, we load the mock cookies for testing
            FDX.SESSION.setMockCookies(-1); // argument passed in is the expiration time
        } else if (FDX.CORE.runMode == "production") {
            // TODO: FedEx IT pick up from here to do logout
            // TODO: FedEx IT pick up from here to do login
            // DO LIVE LOGIN

            FDX.LOGIN.loginFailedMessage = "";
            var formData = {
                "method": "logout"
            };

            FDX.CLIENTLOGIN.doAPILogout();
        }
    },

    setRememberMeState: function() {
        if (FDX.SESSION.getRememberMe() != null) {
            $('[name=user]').val(FDX.SESSION.getRememberMe());
            $('[name=rememberme]').prop('checked', true);
            $("#NavLoginPassword_show").hide();
            FDX.LOGIN.onPasswordKeyUp();
            FDX.LOGIN.onPasswordClick();
        }
    },

    removeErrorMessage: function() {
        $('.' + FDX.LOGIN.loginFailedClass).remove();

    },
    showErrorMessage: function() {
        var messageString = FDX.LOGIN.loginFailedMessage.replace(/<(?:.|\n)*?>/gm, ''); //removing html from error message
        // This has not been completed yet and will change!
        // Error placeholder TBD.
        FDX.LOGIN.removeErrorMessage();

        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        var msgTemplate = isSafari ? '<div tabindex="0" id="loginNoErrorFillMsg" role="alert" focusable="true" aria-required="true"  aria-label="' + messageString + '"  class="' + FDX.LOGIN.loginFailedClass + ' fdx__fail-msg-ada2" ></div>' : '<div tabindex="0" id="loginNoErrorFillMsg" focusable="true" aria-required="true"  aria-label="' + messageString + '"  class="' + FDX.LOGIN.loginFailedClass + ' fdx__fail-msg-ada2" ></div>';

        $(FDX.LOGIN.loginFormID).prepend(msgTemplate);
        $('#loginNoErrorFillMsg').html(FDX.LOGIN.loginFailedMessage);

        if (!isSafari) {
            setTimeout(function() {
                $("#loginNoErrorFillMsg").focus();
            }, 1000);
        }
    },

    setLoginResource: function(element, type) {
        FDX.LOGIN.loginResourceElement = element;
        FDX.LOGIN.loginResourceType = type;
    },
    /*checkSecure: function(isSec){
		FDX.LOGIN.isSecure=isSec;
    },*/

    showHideFunction: function() {
        FDX.LOGIN.loginConfigs();
        if (FDX.LOGIN.navLoginPassword.attr("type") == "password") {
            FDX.LOGIN.navLoginPassword.attr("type", "text");
            FDX.LOGIN.navLoginPasswordShow.text(FDX.LOGIN.loginHideText);
            FDX.LOGIN.navLoginPasswordShow.attr("aria-label", FDX.LOGIN.loginHideAltText);
        } else {
            FDX.LOGIN.navLoginPassword.attr("type", "password");
            FDX.LOGIN.navLoginPasswordShow.text(FDX.LOGIN.loginShowText);
            FDX.LOGIN.navLoginPasswordShow.attr("aria-label", FDX.LOGIN.loginShowAltText);
        }
    },

    preLogin: function() {
        console.log("Pre Login called");
        //getting active cube data before login
        FDX.CUBE.storeAppInfo();
    },
    preLogOut: function() {
        console.log("pre log out called");
    },

    onKeyUpAndOnClick: function(thisVal) {

        if (thisVal !== "") {
            $("#NavLoginPassword_show").show();
        } else {
            $("#NavLoginPassword_show").hide();
        }
    },

    onPasswordKeyUp: function() {
        $("#NavLoginPassword").keyup(function() {
            var thisVal = $(this).val();
            FDX.LOGIN.onKeyUpAndOnClick(thisVal);
        });
    },

    onPasswordClick: function() {
        $("#NavLoginPassword").click(function(e) {
            var thisVal = $(this).val();
            FDX.LOGIN.onKeyUpAndOnClick(thisVal);
            e.stopPropagation();
        });
    },

    onPasswordShowclick: function() {
        $("#NavLoginPassword_show").click(function() {
            FDX.LOGIN.showHideFunction();
        });
    },

    onPasswordShowKeyPress: function() {
        $("#NavLoginPassword_show").keypress(function(e) {
            if (e.which == 13) {
                FDX.LOGIN.showHideFunction();
            }
        });
    }
};

$(document).ready(function() {
    FDX.LOGIN.loginConfigs();
    // Bind to the login form in the header
    // We bind to the body because the login form can be added/removed from the dom dynamically, so we must ensure it remains bound
    $(FDX.LOGIN.loginFormID).off("submit");
    $(FDX.LOGIN.loginFormID + ':not(.bound)').addClass('bound').submit(function(e) {
        e.preventDefault();
        FDX.DTM.pushButtonInfo("hdr|Login", "samePage");
        FDX.LOGIN.doLogin($(this));
    });
    $(".wlgnlink-class" + ':not(.bound)').addClass('bound').click(function(e) {
        FDX.LOGIN.preLogin();

    });
    FDX.LOGIN.setRememberMeState();
    $("#NavLoginPassword_show").hide();
    FDX.LOGIN.onPasswordClick();
    FDX.LOGIN.onPasswordShowKeyPress();
    FDX.LOGIN.onPasswordKeyUp();
    FDX.LOGIN.onPasswordShowclick();
    var checkBoxChecked = false;
    $('#NavLoginRememberMe').click(function() {
        checkBoxChecked = !checkBoxChecked;
        $('#NavLoginRememberMe').attr('aria-checked', checkBoxChecked);
    });

});

//sign out issue fix for iphone/and ipads on clicking back button after navigating back from  targeting/segmetation link
window.onpageshow = function(event) {

    var userAgent = window.navigator.userAgent;
    if (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i)) {
        if (event.persisted) {
            window.location.reload();
        }
    }

};

/* This is the FedEx.com locations module component javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-05-01
 */

if (!FDX) {
    var FDX = {};
}

FDX.LOCATIONS_MODULE = {
    //Location module component was designed for header navigation, But it was never used due to google MAP API usage and restrictions.
    //Doing code cleanup to avoid security issues.

};

/* This is the FedEx.com tracking app component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-05-01
 */

if (!FDX) {
    var FDX = {};
}

FDX.LOCATIONS = {

    mapClass: 'fxg-locations-gmap',
    mapTypeId: 'roadmap',
    location: {
        'lat': '',
        'lng': ''
    },
    zoom: 11,
    viewAllLinkText: "VIEW ALL LOCATIONS",
    address: '',
    geometry: '',

    submit: function() {
        // MVP1: We are driving directly to the locations landing page to show the locations.
        // Post MPV1: We will be adding in state 2. Uncomment the below FDX.LOCATIONS.centerMap()

        var address = document.getElementById("HomepageLocationsAppInput").value;
        var locale = FDX.SESSION.getLocale();
        var cc = FDX.SESSION.getCountryPath();
        var country = '';
        var pincode = '';
        var state = '';
        var city = '';
        var locality = '';
        var street = '';
        var lat = '';
        var lng = '';
        var dataAnalytics = document.getElementById("dataAnalytics").value;
        console.log('Location-App, address is ', FDX.LOCATIONS.address);
        console.log('Location-App, geo is ', FDX.LOCATIONS.geometry);

        if (!(FDX.LOCATIONS.address === '')) {
            lat = FDX.LOCATIONS.geometry.lat();
            lng = FDX.LOCATIONS.geometry.lng();
            var address_components = {
                country: '',
                postal_code: '',
                administrative_area_level_1: '',
                administrative_area_level_2: '',
                locality: '',
                route: ''
            };
            $.each(FDX.LOCATIONS.address, function(k, v1) {
                jQuery.each(v1.types, function(k2, v2) {
                    address_components[v2] = v1.short_name
                });
            })
            console.log('address components ', address_components);


            var link = 'http://www.fedex.com/locate/?locale=' + locale + '&appId=WCON&originLatitude=' + lat + '&originLongitude=' + lng + '&originStreetLines=' +
                address_components.route + '&originCity=' + address_components.locality + '&originStateOrProvinceCode=' + address_components.administrative_area_level_1 + '&originPostalCode=' + address_components +
                '&originCountryCode=' + address_components.country + '&actionType=results';
            var openInNewWindow = document.getElementById("openInNewWindowLoc").value;
            console.log("openInNewWindow : " + openInNewWindow)

            FDX.DTM.pushButtonInfo(dataAnalytics, "newPage");

            if (openInNewWindow == "true") {

                window.open(link, "_blank");
            } else {
                window.location = link;
            }


        }
        // Option 1: Drive to locations landing page directly as a get request
        // Option 2: Set the form action and submit the form to the locations page, posting the field as data.
        //window.location = "";


        // FedEx IT to pickup from here to populate map
        // Get locations data source
        // Set FDX.LOCATIONS.DATA with locations data

        // TODO: Pickup from here when we are post MVP1 to complete State 2 of locations on homepage.
        // FDX.LOCATIONS.centerMap(address);
    },

    centerMap: function(address) {

        var geocoder = new google.maps.Geocoder();
        geocoder.geocode({
            address: address
        }, function(results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
                //FDX.LOCATIONS.centerMap(results[0].geometry.location);
                FDX.LOCATIONS.location = results[0].geometry.location;
                FDX.LOCATIONS.drawMap();
            } else {
                alert(address + ' not found');
            }
        });
    },

    drawMap: function() {
        var map = new google.maps.Map(document.getElementsByClassName(FDX.LOCATIONS.mapClass)[0], {
            zoom: FDX.LOCATIONS.zoom,
            center: FDX.LOCATIONS.location,
            styles: FDX.LOCATIONS.GMAPSTYLE
        });

        map.data.loadGeoJson = FDX.LOCATIONS.DATA;

        /*map.data.setStyle = function(feature) {
            return {
                icon: {
					// TODO: When adding this back, be sure to add the contextPath (FDX.contextPath)
                    url: '/content/dam/fedex-com/gmap/icon_${feature.getProperty("category")}.png',
                    scaledSize: new google.maps.Size(64, 64)
                }
            };
        };*/

        var infoWindow = new google.maps.InfoWindow();
        infoWindow.setOptions({
            pixelOffset: new google.maps.Size(0, -30)
        });

        if (FDX.CUBE)
            FDX.CUBE.openApp();
    },

    clearLocations: function() {
        infoWindow.close();
        for (var i = 0; i < markers.length; i++) {
            markers[i].setMap(null);
        }
        markers.length = 0;

        locationSelect.innerHTML = "";
        var option = document.createElement("option");
        option.value = "none";
        option.innerHTML = FDX.LOCATIONS.viewAllLinkText;
        locationSelect.appendChild(option);
    }

};

$(document).ready(function() {
    //Submit on enter click
    $('#HomepageLocationsAppInput').change(function(e) {
        $('#HomepageLocationsAppInput').focus();
        window.setTimeout(function() {
            FDX.DTM.updateLocationApp();
        }, 500);
        e.preventDefault();
    });

    //Stubbed submit on click
    $('#HomepageLocationsApp').on('submit', function(e) {
        e.preventDefault();
        FDX.LOCATIONS.submit();
    });
});

FDX.LOCATIONS.GMAPSTYLE = [{
        "elementType": "geometry",
        "stylers": [{
            "color": "#F2F2F2"
        }]
    },
    {
        'featureType': 'administrative',
        'elementType': 'all',
        'stylers': [{
                'visibility': 'on'
            },
            {
                'lightness': 33
            }
        ]
    },
    {
        "featureType": "administrative.land_parcel",
        "elementType": "labels.text.fill",
        "stylers": [{
            "color": "#bdbdbd"
        }]
    },
    {
        'featureType': 'landscape',
        'elementType': 'all',
        'stylers': [{
            'color': '#F2F2F2'
        }]
    },
    {
        "featureType": "poi",
        "elementType": "labels.text.fill",
        "stylers": [{
            "color": "#757575"
        }]
    },
    {
        'featureType': 'poi.park',
        'elementType': 'geometry',
        'stylers': [{
            'color': '#F2F2F2'
        }]
    },
    {
        'featureType': 'poi.park',
        'elementType': 'labels',
        'stylers': [{
                'visibility': 'on'
            },
            {
                'lightness': 20
            }
        ]
    },
    {
        "featureType": "poi.park",
        "elementType": "labels.text.fill",
        "stylers": [{
            "color": "#9e9e9e"
        }]
    },
    {
        'featureType': 'road',
        'elementType': 'all',
        'stylers': [{
            'lightness': 20
        }]
    },
    {
        'featureType': 'road.highway',
        'elementType': 'geometry',
        'stylers': [{
            'color': '#E4E4E4'
        }]
    },
    {
        'featureType': 'road.arterial',
        'elementType': 'geometry',
        'stylers': [{
            'color': '#ffffff'
        }]
    },
    {
        'featureType': 'road.local',
        'elementType': 'geometry',
        'stylers': [{
            'color': '#ffffff'
        }]
    },
    {
        'featureType': 'water',
        'elementType': 'all',
        'stylers': [{
                'visibility': 'on'
            },
            {
                'color': '#C8F1FE'
            }
        ]
    },
    {
        "elementType": "labels.icon",
        "stylers": [{
            "visibility": "off"
        }]
    },
    {
        "elementType": "labels.text.fill",
        "stylers": [{
            "color": "#616161"
        }]
    },
    {
        "elementType": "labels.text.stroke",
        "stylers": [{
            "color": "#f5f5f5"
        }]
    },
    {
        "featureType": "transit.line",
        "elementType": "geometry",
        "stylers": [{
            "color": "#ffffff"
        }]
    },
    {
        "featureType": "transit.station",
        "elementType": "geometry",
        "stylers": [{
            "color": "#e4e4e4"
        }]
    }
];

FDX.LOCATIONS.DATA = {
    'type': 'FeatureCollection',
    'feature': [{
            'geometry': {
                'type': 'Point',
                'coordinates': [-73.948555, 40.809074]
            },
            'type': 'Feature',
            'properties': {
                'category': 'shipping',
                'hours': '7:30am - 9:00pm',
                'description': '207 W 125th St, New York, NY 10027',
                'name': 'FedEx Office Print & Ship Center',
                'phone': '123-456-7890'
            }
        },
        {
            'geometry': {
                'type': 'Point',
                'coordinates': [-73.96445, 40.808243]
            },
            'type': 'Feature',
            'properties': {
                'category': 'shipping',
                'hours': '8:30am - 9:00pm',
                'description': '600 W 116th St, New York, NY 10027',
                'name': 'FedEx Office Ship Center',
                'phone': '567-890-1234'
            }
        },
        {
            'geometry': {
                'type': 'Point',
                'coordinates': [-73.97967, 40.784283]
            },
            'type': 'Feature',
            'properties': {
                'category': 'shipping',
                'hours': '7:30am - 9:00pm',
                'description': '2233 Broadway, New York, NY 10024',
                'name': 'FedEx Location 3',
                'phone': '456-789-1234'
            }
        }
    ]
};
/*
 * Created 4/6/2017 by Edgar Galindo edgar.galindo@vml.com
 * Updated 7/10/2017
 * This is the javascript object for the landing page hero.
 */

if (!FDX) {
    var FDX = {};
}

FDX.LANDINGPAGEHERO = {
    heroClass: "fxg-landing-hero",
    backgroundImgClass: "fxg-landing-hero__background-image",
    videoBtn: ".fxg-landing-hero__video-btn, .fxg-landing-hero__video-btn--dark",
    heroMobileVideoClass: "fxg-landing-heroMobileVideo",
    openVideoClass: "fxg-landing-hero--open",
    videoWrapperClass: ".fxg-landing-hero__video",
    closeBtn: ".fxg-landing-hero__close-btn",
    heroVideoId: "",
    kalturaVideoPlayControlClass: '.mwPlayerContainer .controlBarContainer .controlsContainer button.playPauseBtn',

    setMobileBackgroundImage: function() {
        var targetElem = $('.' + FDX.LANDINGPAGEHERO.heroClass + " ." + FDX.LANDINGPAGEHERO.backgroundImgClass);
        var mainImg = targetElem.attr('data-mobile-image');
        targetElem.css('background-image', 'none');
    },

    setMainBackgroundImage: function() {
        var targetElem = $('.' + FDX.LANDINGPAGEHERO.heroClass + " ." + FDX.LANDINGPAGEHERO.backgroundImgClass);
        var mainImg = targetElem.attr('data-main-image');
        var maskType = targetElem.attr('data-mask-type') || 'none';
        var maskIntensity = targetElem.attr('data-mask-intensity') || '0.75';

        if (maskType === 'radial') {

            var maskInverse = targetElem.attr('data-mask-inverse') || 'false';

            var maskIntensityOne = '0';
            var maskIntensityTwo = maskIntensity;

            if (maskInverse === 'true') {
                maskIntensityOne = maskIntensity;
                maskIntensityTwo = '0';
            }

            var radialPosition = targetElem.attr('data-radial-position') || '50';
            var radialSize = targetElem.attr('data-radial-size') || '25';

            targetElem.css({
                'background-image': 'radial-gradient(circle farthest-side at ' + radialPosition + '% 50%, rgba(0,0,0,' + maskIntensityOne + ') ' + radialSize + '%, rgba(0,0,0,' + maskIntensityTwo + ') 100%), url(' + mainImg + ')'
            });

        } else if (maskType === 'linear') {
            var linearPosition = targetElem.attr('data-linear-position') || 'left';

            targetElem.css({
                'background-image': 'linear-gradient(to ' + linearPosition + ', rgba(0,0,0,0) 40%, rgba(0,0,0,' + maskIntensity + ') 100%), url(' + mainImg + ')'
            });

        } else {
            targetElem.css('background-image', 'url(' + mainImg + ')');
        }
    },

    mobileBreakpointChanged: function(mq) {
        if (mq.matches) {
            FDX.LANDINGPAGEHERO.setMobileBackgroundImage();
        } else {
            FDX.LANDINGPAGEHERO.setMainBackgroundImage();
        }
    },

    closeVideo: function() {
        var videoControl = $(FDX.LANDINGPAGEHERO.closeBtn).next().find('button.vjs-play-control');
        if ($(videoControl).hasClass('vjs-playing')) {
            $(videoControl).click();
        }
        var iFrameContent = $(FDX.LANDINGPAGEHERO.closeBtn).next().find('.kWidgetIframeContainer.mavice-kp-player iframe').contents();
        var playPauseBtn = iFrameContent.find(FDX.LANDINGPAGEHERO.kalturaVideoPlayControlClass);
        if (playPauseBtn.hasClass('icon-pause')) {
            playPauseBtn.click();
        }
        $('.' + FDX.LANDINGPAGEHERO.heroClass).removeClass(FDX.LANDINGPAGEHERO.openVideoClass);
    }
};

$(document).ready(function() {
    // Set mobile/desktop hero text
    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.LANDINGPAGEHERO.mobileBreakpointChanged);

    // init
    FDX.LANDINGPAGEHERO.mobileBreakpointChanged(FDX.BREAKPOINTS.getMobileMediaQuery());

    $(FDX.LANDINGPAGEHERO.videoBtn).on('click', function(e) {
        $('.' + FDX.LANDINGPAGEHERO.heroClass).addClass(FDX.LANDINGPAGEHERO.openVideoClass);

    });

    $(FDX.LANDINGPAGEHERO.closeBtn).on('click', function(e) {
        FDX.LANDINGPAGEHERO.closeVideo();
    });

    //To show Image if Hero landing is added through Target
    document.addEventListener('readystatechange', function(ev) {
        if (document.readyState === 'complete') {
            setTimeout(function() {
                if ((typeof(adobe) != 'undefined') && (typeof(adobe.target) != 'undefined') && (typeof(adobe.target.VERSION) != 'undefined')) {
                    FDX.LANDINGPAGEHERO.mobileBreakpointChanged(FDX.BREAKPOINTS.getMobileMediaQuery());
                }
            }, 300);
        }
    });
});

/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * Jump Links
         *
         * Sticky navigation with tabs that upon click jump (scroll) to the related headers
         */
        (function($, _) {
            window.FDX.components.jumplinks = function() {
                /**
                 * @type {Object[]} list of instances
                 */
                var instances = [];
                /**
                 * @type {string} root selector
                 */

                var selector = '.fxg-jumplinks';
                /**
                 * Create component instance
                 *
                 * @public
                 * @return {Object} instance
                 */

                function create() {
                    /**
                     * @type {Object} configuration
                     */
                    var config = {};
                    /**
                     * @type {Object} jQuery DOM root element
                     */

                    var $root = null;
                    /**
                     * @type {Object} jQuery DOM placeholder element
                     */

                    var $placeholder = null;
                    /**
                     * @type {Object} jQuery DOM nav element
                     */

                    var $nav = null;
                    /**
                     * @type {number} nav top
                     */

                    var navTop;
                    /**
                     * @type {number} nav height
                     */

                    var navHeight = 48;
                    /**
                     * @type {Object} jQuery DOM tabs element
                     */

                    var $tabs = null;
                    /**
                     * @type {Object} jQuery DOM previous tab button
                     */

                    var $prevTab = null;
                    /**
                     * @type {Object} jQuery DOM next tab button
                     */

                    var $nextTab = null;
                    /**
                     * @type {number} tabs margin
                     */

                    var tabsMargin = 10;
                    /**
                     * @type {boolean} flag indicating whether jumping is going on
                     */

                    var jumping = false;
                    /**
                     * @type {Object[]} tabs and headers on page
                     */

                    var tabs = [];
                    /**
                     * @type {Object} visible tabs detected by intersection observer
                     */

                    var visibleTabs = {
                        items: [],
                        first: null,
                        last: null
                    };
                    /**
                     * @type {Object} jQuery DOM element of highlighted tab
                     */

                    var $highlightedTab = null;
                    /**
                     * @type {boolean} flag indicating whether element should currently stick
                     */

                    var isSticky = false;
                    /**
                     * Set configuration
                     *
                     * @public
                     * @param {Object} _config - key/value pair
                     * @return {Object} instance
                     */

                    function setConfig(_config) {}

                    ;
                    /**
                     * Render HTML
                     *
                     * @private
                     * @return {Promise<string>} A promise that resolves with rendered HTML
                     */

                    function render() {}
                    /**
                     * Brings the active tab into view and highlights it
                     *
                     * @private
                     */


                    function showTab($tab, highlight) {
                        $tabs.animate({
                            scrollLeft: $tab.position().left
                        }, 500);

                        if (highlight) {
                            if ($highlightedTab) {
                                $highlightedTab.find('a').attr('aria-selected', 'false');
                            }

                            $tab.find('a').attr('aria-selected', 'true');
                            $highlightedTab = $tab;
                        }
                    }
                    /**
                     * Calculate nav top
                     *
                     * @private
                     */


                    function calcNavTop() {
                        navTop = $root.offset().top;
                    }
                    /**
                     * Collect tabs and headers on page
                     *
                     * @private
                     */


                    function collectTabsAndHeaders() {
                        tabs = [];
                        $tabs.find('ul > li').each(function() {
                            // find header
                            var href = $(this).find('a').attr('href');
                            if (!href) return;
                            var $header = $('body').find(href); // collect

                            tabs.push({
                                href: href,
                                $tab: $(this),
                                $header: $header,
                                headerTop: $header.length ? $header.offset().top : 0
                            }); // sort based on header top position

                            tabs.sort(function(a, b) {
                                return a.headerTop - b.headerTop;
                            });
                        });
                    }
                    /**
                     * Calculate headers top
                     *
                     * @private
                     */


                    function calcHeadersTop() {
                        tabs.forEach(function(tab) {
                            tab.headerTop = tab.$header.length ? tab.$header.offset().top : 0;
                        });
                    }
                    /**
                     * Observe tabs
                     *
                     * @private
                     */


                    function observeTabs() {
                        // init intersection observer
                        var options = {
                            root: null,
                            rootMargin: '0px',
                            threshold: [0.5, 0.75, 1]
                        };
                        var observer = new IntersectionObserver(function(entries, observer) {
                            // set visible items
                            entries.forEach(function(entry) {
                                var index = $(entry.target).index();
                                var isVisible = entry.intersectionRatio >= 0.5;
                                visibleTabs.items[index] = isVisible;
                            }); // redefine first and last visible index

                            visibleTabs.first = null;
                            visibleTabs.last = null;

                            for (var _i in visibleTabs.items) {
                                if (visibleTabs.items[_i]) {
                                    visibleTabs.first = visibleTabs.first === null ? parseInt(_i) : Math.min(visibleTabs.first, _i);
                                    visibleTabs.last = visibleTabs.last === null ? parseInt(_i) : Math.max(visibleTabs.last, _i);
                                }
                            } // toggle previous + next button


                            $prevTab.toggleClass('cc-aem-u-display--none', visibleTabs.items[0]);
                            $nextTab.toggleClass('cc-aem-u-display--none', visibleTabs.items[visibleTabs.items.length - 1]);
                        }, options); // observe tabs

                        for (var i in tabs) {
                            observer.observe(tabs[i].$tab[0]);
                        }
                    }
                    /**
                     * Observe headers
                     *
                     * @private
                     */


                    function observeHeaders() {
                        $(window).on('scroll', _.debounce(function() {
                            // skip observing during jump
                            if (jumping) return; // detect closest header

                            detectClosestHeader();
                        }, 200));
                    }
                    /**
                     * Observe sticky
                     *
                     * @private
                     */


                    function observeSticky() {
                        $(window).on('scroll', _.debounce(function() {
                            // skip observing during jump
                            if (jumping) return; // set sticky

                            setSticky();
                        }, 200));
                    }
                    /**
                     * Set sticky attributes of nav + placeholder
                     *
                     * @private
                     */


                    function setSticky(force) {
                        // is sticky?
                        var scrollTop = $(window).scrollTop() + FDX.HEADER.height;

                        var _isSticky = scrollTop > navTop; // toggle sticky


                        if (_isSticky !== isSticky || force) {
                            isSticky = _isSticky;
                            $nav.toggleClass('cc-aem-u-position--fixed', isSticky);
                            $placeholder.toggleClass('cc-aem-u-display--none', !isSticky);

                            if (isSticky) {
                                $nav.css('top', FDX.HEADER.height);
                            } else {
                                $nav.css('top', '');
                            }
                        }
                    }
                    /**
                     * Observe header height
                     *
                     * @private
                     */


                    function observeHeaderHeight() {
                        $(FDX.HEADER.events).on(FDX.HEADER.events.heightChanged, function() {
                            calcNavTop();
                            calcHeadersTop();
                            setSticky(true);
                        });
                    }
                    /**
                     * Observe window resize
                     *
                     * @private
                     */


                    function observeWindowResize() {
                        $(window).on('resize', _.debounce(function() {
                            calcNavTop();
                            calcHeadersTop();
                            setSticky(true);
                        }, 200));
                    }
                    /**
                     * Bind interactions events
                     *
                     * @private
                     */


                    function bindInteractions() {
                        // on tab click jump to header
                        tabs.forEach(function(tab) {
                            tab.$tab.find('a').on('click', function(event) {
                                // calculate headers top
                                calcHeadersTop(); // highlight tab

                                showTab(tab.$tab, true); // smooth scroll to header

                                event.preventDefault();
                                jumping = true;
                                var navigateTo = tab.headerTop - (FDX.HEADER.height + navHeight + tabsMargin);
                                var scrollingElement = document.scrollingElement || document.documentElement;
                                $(scrollingElement).animate({
                                    scrollTop: navigateTo
                                }, 500, function(event) {
                                    // after smooth scroll adjust once again as header might have shrunk by now which causes change in navigateTo
                                    navigateTo = tab.headerTop - (FDX.HEADER.height + navHeight + tabsMargin);
                                    $(scrollingElement).animate({
                                        scrollTop: navigateTo
                                    }, function(event) {
                                        // after final scroll start observing scroll again
                                        jumping = false;
                                        setSticky();
                                    });
                                });
                            });
                        }); // tab navigation

                        $prevTab.on('click', function() {
                            goToPrevTab();
                        });
                        $nextTab.on('click', function() {
                            goToNextTab();
                        });
                    }
                    /**
                     * Detect closest header and highlight its related tab
                     *
                     * @private
                     */


                    function detectClosestHeader() {
                        // find closest passed header
                        var closest;
                        var scrollTop = $(window).scrollTop() + FDX.HEADER.height + navHeight + tabsMargin;

                        for (var i in tabs) {
                            var diff = scrollTop - tabs[i].headerTop;

                            if (diff > 0) {
                                if (!closest) {
                                    closest = tabs[i];
                                } else {
                                    var diffClosest = scrollTop - closest.headerTop;

                                    if (diff < diffClosest) {
                                        closest = tabs[i];
                                    }
                                }
                            }
                        } // highlight related tab


                        if (closest) {
                            if ($highlightedTab !== closest.$tab) {
                                showTab(closest.$tab, true);
                            }
                        } else {
                            if ($highlightedTab) {
                                // no tabs should be highlighted
                                // lets make sure first tab is shown
                                $highlightedTab.find('a').attr('aria-selected', 'false');
                                $highlightedTab = null;
                                showTab(tabs[0].$tab);
                            }
                        }
                    }
                    /**
                     * Go to next tab
                     *
                     * @private
                     */


                    function goToNextTab() {
                        if (visibleTabs.last < visibleTabs.items.length - 1) {
                            var $tab = $tabs.find('ul > li').eq(visibleTabs.last + 1);
                            showTab($tab);
                        }
                    }
                    /**
                     * Go to previous tab
                     *
                     * @private
                     */


                    function goToPrevTab() {
                        if (visibleTabs.first > 0) {
                            var $tab = $tabs.find('ul > li').eq(visibleTabs.first - 1);
                            showTab($tab);
                        }
                    }
                    /**
                     * Initialize component instance
                     *
                     * @public
                     * @param {Object} [_$root] compnent root element (optional)
                     * @return {Promise} A promise that resolves when instance is initiated
                     */


                    function init(_$root) {
                        var promise = $.Deferred();
                        $root = _$root;
                        $placeholder = _$root.find('.fxg-jumplinks__placeholder');
                        $nav = _$root.find('.fxg-jumplinks__nav');
                        $tabs = _$root.find('.fxg-jumplinks__tabs');
                        $prevTab = $root.find('.fxg-jumplinks__prev-tab');
                        $nextTab = $root.find('.fxg-jumplinks__next-tab'); // calc nav top

                        calcNavTop(); // collect tabs and headers

                        collectTabsAndHeaders(); // detect closest header

                        detectClosestHeader(); // set sticky

                        setSticky(); // observe

                        observeTabs();
                        observeHeaders();
                        observeHeaderHeight();
                        observeWindowResize();
                        observeSticky(); // bind interaction events

                        bindInteractions(); // initialized

                        $root.data('initialized', true);
                        promise.resolve();
                        return promise;
                    }
                    /**
                     * Get component element
                     *
                     * @public
                     * @return {Object} jQuery DOM element
                     */


                    function getElement() {
                        return $root;
                    } // add and return instance


                    var instance = {
                        setConfig: setConfig,
                        init: init,
                        getElement: getElement
                    }; // pass private attributes and methods to jest

                    if (typeof jest !== 'undefined') {
                        showTab = jest.fn(showTab);
                        calcNavTop = jest.fn(calcNavTop);
                        collectTabsAndHeaders = jest.fn(collectTabsAndHeaders);
                        calcHeadersTop = jest.fn(calcHeadersTop);
                        detectClosestHeader = jest.fn(detectClosestHeader);
                        goToNextTab = jest.fn(goToNextTab);
                        goToPrevTab = jest.fn(goToPrevTab);
                        setSticky = jest.fn(setSticky);
                        observeTabs = jest.fn(observeTabs);
                        observeHeaders = jest.fn(observeHeaders);
                        observeHeaderHeight = jest.fn(observeHeaderHeight);
                        observeWindowResize = jest.fn(observeWindowResize);
                        observeSticky = jest.fn(observeSticky);
                        bindInteractions = jest.fn(bindInteractions);

                        instance.$private = function() {
                            return {
                                $root: $root,
                                $placeholder: $placeholder,
                                $nav: $nav,
                                navTop: navTop,
                                navHeight: navHeight,
                                $tabs: $tabs,
                                $prevTab: $prevTab,
                                $nextTab: $nextTab,
                                jumping: jumping,
                                tabs: tabs,
                                visibleTabs: visibleTabs,
                                $highlightedTab: $highlightedTab,
                                isSticky: isSticky,
                                showTab: showTab,
                                calcNavTop: calcNavTop,
                                collectTabsAndHeaders: collectTabsAndHeaders,
                                calcHeadersTop: calcHeadersTop,
                                detectClosestHeader: detectClosestHeader,
                                goToNextTab: goToNextTab,
                                goToPrevTab: goToPrevTab,
                                setSticky: setSticky,
                                observeTabs: observeTabs,
                                observeHeaders: observeHeaders,
                                observeHeaderHeight: observeHeaderHeight,
                                observeWindowResize: observeWindowResize,
                                observeSticky: observeSticky,
                                bindInteractions: bindInteractions
                            };
                        };
                    }

                    instances.push(instance);
                    return instance;
                }
                /**
                 * Create instances
                 *
                 * @public
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function createInstances() {
                    var promise = $.Deferred();
                    var initPromises = []; // find all related elements

                    $(selector).each(function() {
                        // skip already initialized elements
                        var $element = $(this);
                        if ($element.data('initialized')) return; // create instance

                        var instance = window.FDX.components.jumplinks.create(); // initialize instance

                        var initPromise = instance.init($element);
                        initPromises.push(initPromise);
                    }); // resolve after all inits

                    $.when.apply($, initPromises).then(function() {
                        promise.resolve();
                    });
                    return promise;
                } // return component


                return {
                    create: create,
                    instances: instances,
                    createInstances: createInstances,
                    selector: selector
                };
            }();
        })(jQuery, _);

        /***/
    }),
    /* 2 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // extracted by mini-css-extract-plugin


        /***/
    })
    /******/
]);
/**
 * .....Modules included......
 * Utility MODULE -> Form utility module, used as a helper functions.
 * Validation MODULE - Custom validations. Validates form fields with (required='true') on blur event and on form submit.
 * Notification MODULE -> Custom notifications for validation/submission notifications at field and form level.
 * PUBLIC Form MODULE
 * Analytic MODULE -> Adds GDL and DTM analytics support. (For more information on GDL form tracking: https://gdl-master.devapp.paas.fedex.com/testbed.form.html)
 */
if (!window.FDX) {
    window.FDX = {};
}

window.FDX.INTERIMFORM = (function($, _, window, $analytics, $utils) {

    'use strict';

    /**
     * form utility MODULE
     * to fetch and process the form field data
     */
    var utilityModule = function() {

        // PRIVATE function to get the concatenate values of group checkbox field
        function _getGroupCheckBoxValue(formData, field) {
            var fieldName = field.name;
            var fieldValue = field.checked ? field.value : '';

            if (formData.length === 0) {
                return fieldValue;
            }

            // index of current checkbox in the data array.
            var fieldIndex = _.findIndex(formData, {
                name: fieldName
            });

            // If 'data' array doesn't contain current checkbox then set index  to last item index.
            fieldIndex = fieldIndex !== -1 ? fieldIndex : formData.length - 1;

            // stored field data from formData object
            var formFieldValue = formData[fieldIndex].value;
            var formFieldName = formData[fieldIndex].name;

            // concatenate the checkbox values of the same group.
            if (formFieldName === fieldName) {
                fieldValue = formFieldValue && fieldValue ? formFieldValue + ', ' + fieldValue : (formFieldValue ? formFieldValue : fieldValue);

                // Remove the current field from the data as it is already cached to fieldValue
                // also to avoid duplicate items.
                formData.splice(fieldIndex, 1);
            }
            return fieldValue;
        }

        /**
         * Get list of url paramters
         * URL (urlString) Format. The '?' separates the query string from the URL. The query strings are name value pairs.
         * Each name value pair is separated by an ampersand (&) while the name (key) and value is separated by an equals sign (=).
         * default format eg. https://www.fedex.com?key1=value1&key2=value2
         *
         * Below are the unreserved characters that are allowed in a URI but do not have a purpose 
         * A-Za-z / 0-9 / "-" / "." / "_" / "~"
         *
         * @param {string} urlString query or url in string format
         * @param {string} fdxDelimiter that separates key-value pairs. Default is &
         * @param {string} fdxSubDelimiter that separates key and value. Default is =
         *
         * @return {Object} list of paramters
         */
        function getUrlParams(urlString, fdxDelimiter, fdxSubDelimiter) {
            var urlParams = {};
            var delimiter = fdxDelimiter || '&';
            var subDelimiter = fdxSubDelimiter || '=';

            var queryList = urlString.split('?')[1] ? urlString.split('?')[1].split(delimiter) : '';

            if (queryList) {
                queryList.forEach(function(item) {
                    var params = item.split(subDelimiter);
                    var key = decodeURIComponent(params[0]);
                    var value = decodeURIComponent(params.slice(1).join(subDelimiter));
                    urlParams[key] = value;
                });
            }

            return urlParams;
        }

        /**
         * set Analytics Visitor ID (B-532229)
         * 
         * @param {object} $field Jquery form element
         */
        var setVisitorIdValue = function($field) {
            if (!$field.length) {
                return;
            }

            var visitorID = $field.data('visitorCookie');
            var value = $field[0].value || '';

            if (visitorID && FDX.SESSION) {
                // Standard value of visitor cookie(s_ecid) is 'MCMID%7C51409889379996808931017060402060222295'
                // This is static format and it is an encoded value and split with '%7C', which is '|' symbol
                // Final decoded visitorId value is '51409889379996808931017060402060222295'
                var visitorIDValue = decodeURIComponent(FDX.SESSION.getCookie(visitorID)).split('|')[1];
                value = visitorIDValue || value;
                $field[0].value = value;
            }
        };


        /**
         * Get single form element data return them as {}
         *
         * @param {object} field form element
         * @param {object} formData  form data object
         * @param {object} $formConfig  form configuration object
         *
         * @return {Object} form element data object
         */
        function _getFieldData(field, formData, $formConfig) {

            var name = field.name || '';
            var title = $(field).data('title') || '';
            var value = field.value || '';
            var key = field.dataset.key || '';
            var isHiddenField = false;
            var $config = $formConfig || '';

            // check if it is campaign key and update the value
            if ($config && $config.urlParams) {
                value = $config.urlParams[name] || value;
                field.value = value;
            }

            switch (field.type) {

                case 'checkbox':
                    if (field.id.indexOf('_checkbox_single') !== -1) {
                        // single checkbox scenario
                        value = field.checked ? field.dataset.selected : field.dataset.unselected;
                    } else {
                        //group checkbox scenario
                        value = _getGroupCheckBoxValue(formData, field);
                    }
                    break;

                case 'radio':
                    name = !field.checked ? '' : name;
                    break;

                case 'select-one':
                    value = $(field).val();
                    break;

                case 'hidden':
                    isHiddenField = true;
                    setVisitorIdValue($(field));
                    value = field.value;
                    break;

                default:
                    // type = 'text' || 'textarea'
                    break;
            }

            // Date-picker: If date is not set then its value should be empty string
            if ($(field).hasClass('js-fxg-date-picker')) {
                if (value === '' || value === 'DD/MM/YYYY' || value === 'MM/DD/YYYY') {
                    value = '';
                }
            }

            // Field data in Object format
            var fieldObj = {
                name: name,
                title: title,
                value: $.trim(value),
                order: 10000,
                group: key,
                isHidden: isHiddenField
            };

            // Set configured order
            var order = $(field).data('order');
            if (order && order !== null) {
                fieldObj.order = order;
            }

            return fieldObj;
        }

        /**
         * Get all form data return them as JSON object.
         *
         * @param {object} $form jQuery form element
         * @param {object} $config configured form object
         *
         * @return {Object} form data in JSON format
         */
        var getJSONFormData = function($form, $config) {
            // To store the form submission details.
            var formData = [];
            var recipientsMailList = '';
            var positionOrder = 10000;
            var $formConfig = $config || '';

            // Iterate all the form input fields and fetch the field data 
            $form.find(':input').each(function() {
                var fieldData = _getFieldData(this, formData, $formConfig);

                // define object to make sure the field data will be sent properly
                var formInputData = {
                    name: fieldData.name || '',
                    title: fieldData.title || '',
                    value: fieldData.value || '',
                    order: fieldData.order || '',
                    isHidden: fieldData.isHidden || false
                };

                // Update order for fields which do not have order configuration. 
                if (formInputData.name && formInputData.order === 10000) {
                    positionOrder = positionOrder + 1;
                    formInputData.order = positionOrder;
                }

                // push the valid field to 'data' array
                if (formInputData.name) {
                    formData.push(formInputData);
                }

                // set configured 
                if ($(this).data('constraintType') === 'email' && this.value !== '') {
                    recipientsMailList = recipientsMailList ? recipientsMailList + ',' + this.value : this.value;
                }
            });

            // push the form data which are not valid input fields (:input)
            function pushNonInputData(name, value) {
                var formNonInputData = {};
                formNonInputData.title = '';
                formNonInputData.isHidden = false;

                formNonInputData.name = name;
                formNonInputData.value = $.trim(value);

                // update order
                positionOrder = positionOrder + 1;
                formNonInputData.order = positionOrder;

                formData.push(formNonInputData);
            }

            // push recipients mail list
            if (($formConfig.sendMailConfirmation || $formConfig.replyTo) && recipientsMailList) {
                pushNonInputData('recipientsMailKeyValue', recipientsMailList);
            }

            // 'page-url-param' - includes the page url with parameters
            // This used in Optimizely to know about the current variant
            if ($formConfig.isPageUrlParam) {
                pushNonInputData('page-url-param', encodeURIComponent(window.location.href));
            }

            // sort form data in the configured order
            var formSortedDataList = _.sortBy(formData, function(dObj) {
                return dObj.order;
            });

            return formSortedDataList;
        };

        /**
         * Get all form data and group them as configured.
         *
         * @param {object} $form jQuery form
         * @param {object} $config configured form object
         * @return {Object} returns form grouped data in hierarchical format
         */
        var getGroupedFormData = function($form, $config) {
            var formData = [];
            var groupedFormData = {};
            var dataToReturn;
            var $formConfig = $config || '';
            var groups = $formConfig.formGroups;

            // POST JSON Template configurations
            // this may have properties out side form field/configurations.
            var customJson = _.unescape($formConfig.jsonTemplate).replace(/'/g, "\"");

            // Store form fields that are configured in the customJson
            // Store the group data mapped to the form fiels and configured in the customJson
            var customObject = {};

            if (groups !== '') {
                groups = $formConfig.formGroups.split(',');

                // Using the non disabled fields generate the grouped form data
                $form.find(':input:not([disabled])').each(function() {
                    var jsonItem = _getFieldData(this, formData, $formConfig);
                    formData.push(jsonItem);

                    if (_.includes(customJson, '{{fd_' + jsonItem.name + '}}')) {
                        // add the field configured on customJson template to customObject
                        customObject['{{fd_' + jsonItem.name + '}}'] = jsonItem.value.replace(/\n/ig, "\\n");
                    } else if (_.includes(customJson, '{{gp_' + jsonItem.group + '}}')) {
                        // add the group configured on customJson template to customObject
                        customObject['{{gp_' + jsonItem.group + '}}'] = jsonItem.group;
                    }

                    // check if the current field or jsonItem is assigned to valid group or not.
                    var isValidGroup = _.filter(groups, function(group) {
                        return group === jsonItem.group;
                    });

                    // if no group/key is set to field then it will be ignored or not sent to API.
                    if (jsonItem.name && jsonItem.group !== '' && isValidGroup.length === 1) {
                        groupedFormData[jsonItem.group] = groupedFormData[jsonItem.group] || {};
                        groupedFormData[jsonItem.group][jsonItem.name] = jsonItem.value.replace(/\n/ig, "\\n");
                    }
                });

                // case: default format (no custom json configured)
                var formattedFormData = [];
                formattedFormData.push(groupedFormData);

                // case: custom format for POST Submission
                if ($formConfig.jsonTemplate) {
                    formattedFormData = customJson;

                    // update 'groups' data to customObject
                    groups.forEach(function(group) {
                        customObject['{{gp_' + group + '}}'] = groupedFormData[group];
                    });

                    // generate JSON as per configured customJSON template using customObject properties
                    for (var item in customObject) {
                        var rgx = new RegExp(item, 'gi');
                        if (_.isObject(customObject[item])) {
                            rgx = new RegExp('"' + item + '"', 'gi');
                            formattedFormData = formattedFormData.replace(rgx, JSON.stringify(customObject[item]));
                        } else {
                            formattedFormData = formattedFormData.replace(rgx, customObject[item]);
                        }
                    }

                    try {
                        formattedFormData = JSON.parse(formattedFormData);
                    } catch (e) {
                        formattedFormData = '';
                    }
                }
                dataToReturn = formattedFormData;

            } else {
                // non hierarchical format and allow only non disabled fields
                $form.find(':input:not([disabled])').each(function() {
                    var jsonItem = _getFieldData(this, formData, $formConfig);
                    if (jsonItem.name) {
                        formData.push(jsonItem);
                        groupedFormData[jsonItem.name] = jsonItem.value;
                    }
                });
                dataToReturn = groupedFormData;
            }
            return dataToReturn;
        };

        /**
         * fetch the action/target url
         * @param {string} type form method type
         */
        var getUrl = function(type) {
            var url = '';
            switch (type) {
                case 'POST':
                    url = '/etc/services/form/formpostservlet';
                    break;

                default:
                    // case 'mail'
                    url = '/etc/services/form/mail';
                    break;
            }
            return url;
        };

        return {
            getGroupedFormData: getGroupedFormData,
            getJSONFormData: getJSONFormData,
            getUrlParams: getUrlParams,
            getUrl: getUrl,
            setVisitorIdValue: setVisitorIdValue
        };

    };

    /**
     * form Validation MODULE
     */
    var fieldValidationModule = function() {
        function regexPattern(check) {
            var regex;

            if (check !== null || typeof check !== 'undefined') {
                switch (check) {
                    case 'required':
                        // Matches non WHITE SPACE.
                        regex = /\S+/;
                        break;

                    case 'email':
                        // E-mail validation. Source: http://emailregex.com/
                        // NOTE: there is no perfect regex for email, its just for helping hand, see http://www.regular-expressions.info/email.html if user wants to type me@foo.in.in we have to trust him :)
                        regex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
                        break;

                    case 'numeric':
                        // Matches a digit character. Equivalent to [0-9]
                        regex = /^\d+$/;
                        break;

                    case 'telephone':
                        // Matches a telephone supported characters. digits of minimum 6 and charaters like () / + - and space
                        regex = /^([ /+()-]*\d){6,}$/;
                        break;

                    default:
                        // Matches empty field value. Like value = ''
                        // cases like field is hidden, required and validationType = ''
                        // used to validate bot's.
                        regex = /^$/;
                        break;
                }
            }
            return regex;
        }

        var validate = function(fieldValue, check) {
            var validField = true;
            if (typeof fieldValue === 'undefined') {
                return false;
            }

            var regex = regexPattern(check);
            if (!regex.test(fieldValue) || fieldValue === null) {
                validField = false;
            }

            return validField;
        };

        return {
            validate: validate
        };
    };

    /**
     * form Notification MODULE
     */
    var notifyModule = function() {

        function errorTemplate() {
            return '<% if(message) { %>' +
                '<div class="fxg-form js-c-form-field-error" role="alert" aria-live="assertive">' +
                '<div class="<%= messageType %>">' +
                '<%= message %>' +
                '</div>' +
                '</div>' +
                '<% } %>';
        }

        /**
         * Module - to create and show notification messages like error/success/failed
         */
        var Module = function($element, $config) {
            var $root = $element;

            var errorTmp = errorTemplate();
            var template = _.template(errorTmp);

            var JS_FIELD_ERROR = 'js-c-form-field-error';
            var FORM_FIELD = '.js-c-form-field';
            var FIELD_ERROR = 'fxg-field__input--error';


            // root level configurations.
            var $rootConfig = {
                successContentPath: $config.successContentPath || '',
                success: $config.success || '',
                failed: $config.failed || '',
                required: $config.required || ''
            };

            // cache the message container at form level to show success or fail or error messages.
            var $notifyContainer = $root.find('.js-c-form-submit-message');

            /**
             * show form success or failed message to the user.
             *
             * @param {boolean} isSuccess decide if failed or success.
             * @param {string} customMessage  custom error or success message.
             * @param {object} successContent content to show instead of message.
             */
            function showMessage(isSuccess, customMessage, successContent) {
                var msgContext = {};
                // css class name to notify if message is error or failed.
                msgContext.messageType = isSuccess ? 'is-success fxg-form__notification-text' : 'is-failed fxg-form__notification-text';
                msgContext.message = isSuccess ? $rootConfig.success : $rootConfig.failed;
                msgContext.message = customMessage ? customMessage : msgContext.message;
                $root.toggleClass('is-success', isSuccess);

                // update the container with configured content or message/notification
                var content = successContent || template(msgContext);
                $notifyContainer.empty().append(content);

                $('html, body').animate({
                    scrollTop: $notifyContainer.offset().top - 80
                }, 'fast');
            }

            // fetch the form/content.
            function fetchContent(url) {
                if (window.FDX.FetchService) {
                    window.FDX.FetchService.get(url, 'html')
                        .done(function(response) {
                            var successContent = $('<div/>').append(response);
                            showMessage(true, '', successContent);
                        }).fail(function(resp) {
                            // Failed to load content, so fall back to Thankyou message
                            showMessage(true);
                        });
                }
            }

            // Show success message for AJAX enabled form else redirect to the configured thankyou page
            var formSubmissionSuccess = function(customMessage) {
                // check if success message is a content path or just a string message
                if ($rootConfig.successContentPath !== '') {
                    fetchContent($rootConfig.successContentPath);
                } else {
                    showMessage(true, customMessage);
                }
            };

            // Show error message for AJAX enabled form else redirect to the configured error page
            var formSubmissionFailed = function(customMessage) {
                showMessage(false, customMessage);
            };

            // configure and show field error messages
            var showFieldError = function($field, check) {
                var $data = $field.data();

                $field.addClass(FIELD_ERROR);
                var $fieldWrapper = $field.closest(FORM_FIELD);
                var $fieldError = $fieldWrapper.find('.' + JS_FIELD_ERROR);

                if (!$fieldError.length) {
                    var context = {};
                    // css class name to notify field error message.
                    context.messageType = 'fxg-field__validation';
                    // high priority will be for constraint messages which are set at field level.
                    context.message = check === 'required' ? $rootConfig.required : $data.constraintMessage;



                    $fieldWrapper.append(template(context));
                }
            };

            // removes form field error messages
            var removeFieldError = function($field) {
                var $fieldError = $field.closest(FORM_FIELD).find('.' + JS_FIELD_ERROR);
                $field.removeClass(FIELD_ERROR);

                if ($fieldError.length > 0) {
                    $fieldError.remove();
                }
            };

            return {
                showMessage: showMessage,
                showFieldError: showFieldError,
                removeFieldError: removeFieldError,
                formFailed: formSubmissionFailed,
                formSuccess: formSubmissionSuccess
            };
        };

        return Module;
    };

    /**
     * Form MODULE
     */
    var FORMModule = function($element) {

        // cache the dependency modules for form
        var FieldValidation = fieldValidationModule();
        var FormNotify = notifyModule();
        var Utility = utilityModule();

        var $root = $element;
        var $config = $root.find('[data-config="js-cms-form-config"]').html() || '';

        if (!$config) {
            return;
        } else {
            var data = $config.replace(/\n|\r|\t/g, "");
            data = decodeURIComponent(data.trim());
            $config = $.parseJSON(data);
        }

        var HIDDEN = 'fxg-hidden';
        var DISABLED = 'disabled';
        var REQUIRED_TYPE = 'requiredType';
        var CONSTRAINT_TYPE = 'constraintType';
        var REGEX_PATTERN = 'regexPattern';
        var REQUIRED_FIELDS = '[required="true"]';
        var CONSTRAINED_FIELDS = 'js-is-constraint';
        var SUBMIT_ANALYTICS_TAG = 'myquote|Submit a Quote';

        var $failedFieldName = '';
        var isValidCondContent = true;
        var customErrorMessage = '';
        var authorizationToken = '';

        var $formConfig = {
            success: $config.success || '',
            successContentPath: $config.successContentPath || '',
            failed: $config.failed || '',
            required: $config.required || '',
            formType: $config.formType || '',
            formName: $config.formName || 'form',
            isPageUrlParam: $config.isPageUrlParam || false,
            sendMailConfirmation: $config.sendMailConfirmation,
            replyTo: $config.replyTo || false,
            isAuthToken: $config.authToken || false,
            action: $config.action || '',
            formGroups: $config.jsonGroups || '',
            headers: $config.headers || '',
            clientPost: $config.ajaxSubmit || false,
            jsonTemplate: $config.jsonTemplate || '',
            delimiter: $config.delimiter ? decodeHTMLEntities($config.delimiter) : '&',
            subDelimiter: $config.subDelimiter ? decodeHTMLEntities($config.subDelimiter) : '=',
            jsonTemplateError: $config.jsonTemplateError || 'JSON parsing error. Invalid "POST JSON Template" format',
            actionMissingError: $config.actionMissingError || 'Action Missing. Form will not post'
        };

        // One trust configurations
        var $oneTrustConfig = {
            isOTEnabled: $config.isOTEnabled || false,
            otFirstName: $config.otFirstName || 'FirstName',
            otLastName: $config.otLastName || 'LastName',
            otIdentifier: $config.otIdentifier || 'EmailAddress',
            otTest: $config.otTest || 'consentCheck',
            otAPI: $config.otAPI || '',
            otPurposeId: $config.otPurposeId || '',
            otAuthToken: $config.otAuthToken || ''
        }

        var pageUrl = window.location.href || '';
        var urlParams = Utility.getUrlParams(pageUrl, $formConfig.delimiter, $formConfig.subDelimiter);
        $formConfig.urlParams = urlParams || {};

        // cache the form submission buttons
        var $submitButton = $root.find('.js-cms-form-submit');
        var $loader = $root.find('.js-cms-form-loader');

        // configure the notify module to be used for validations and submission messages.
        var Notify = FormNotify($root, $formConfig);


        /**
         * @type {string} current device type
         */
        var deviceType = $utils.deviceType().toLowerCase();

        /**
         * @type {Object} gdl params
         */
        var gdl_os = {
            'android': 'Android',
            'ios': 'iOS',
            'desktop': 'desktop'
        };

        // Attaching analytics attribute to submit button
        $(".js-cms-form-submit").attr('data-analytics', SUBMIT_ANALYTICS_TAG);

        // Function to - validate form field before form submission and on field blur event
        function _fieldValidation(field) {
            var isValidField = true;
            var isRequired = $(field).data(REQUIRED_TYPE) ? true : false;
            var constraintType = $(field).data(CONSTRAINT_TYPE);
            var customRegex = $(field).data(REGEX_PATTERN);

            // type of validation/check to be done
            var check = constraintType;

            if (!check && !field) {
                return isValidField;
            }

            var $field = $(field);
            var value;

            if (field.type === 'checkbox') {
                field.value = field.checked ? field.dataset.selected : '';
                value = field.value;
            } else if (field.tagName === 'SELECT') {
                value = $(field).val();
            } else if ($(field).hasClass('js-fxg-date-picker')) {
                value = $(field).val();
                if (value === '' || value === 'DD/MM/YYYY' || value === 'MM/DD/YYYY') {
                    value = '';
                }
            } else {
                value = field.value;
            }

            // allow form to submit for constraint fields(non required)
            if (value === '' && $field.hasClass(CONSTRAINED_FIELDS)) {
                Notify.removeFieldError($field);
                isValidField = true;
            } else {
                // first validate if the "required" field is not empty then do "constraint" validation
                if (isRequired) {
                    check = 'required'
                    isValidField = FieldValidation.validate(value, check);
                }

                if (isValidField && constraintType) {
                    // now validate for constraint 
                    check = constraintType;

                    if (check === 'regex' && customRegex) {
                        var regex = new RegExp(customRegex);
                        if (!regex.test(value) || value === null) {
                            isValidField = false;
                        }
                    } else {
                        isValidField = FieldValidation.validate(value, check);
                    }
                }
            }

            if (!isValidField) {
                Notify.removeFieldError($field);
                Notify.showFieldError($field, check);
            } else {
                Notify.removeFieldError($field);
            }

            return isValidField;
        }

        /**
         * Helper function to decode HTML entities from JSON
         *
         * @param {string} elementValue - form field
         * @return {string} decoded value
         */
        function decodeHTMLEntities(elementValue) {
            var textArea = document.createElement('textarea');
            textArea.innerHTML = elementValue;

            return textArea.value;
        }

        /**
         * Helper function to check if element is in viewPort or not
         * 
         * @param {object} field - form field
         * @return {boolean} true of false base on visibility in Viewport 
         */
        function _isVisibleInViewPort(field) {
            var $field = field;
            var fieldTop = $field.offset().top;

            // consider the Fedex header height (80px) as well.
            var viewportTop = $(window).scrollTop() + 80;
            var viewportBottom = viewportTop + $(window).height();

            return fieldTop > viewportTop && fieldTop < viewportBottom;
        }

        /**
         * Perform form validation
         * 
         * @return {boolean} true of false based on form validation 
         */
        function _formValidation() {
            var isValidForm = true;

            $root.find(':input:not([disabled])').each(function() {
                if ($(this).data(REQUIRED_TYPE) || $(this).data(CONSTRAINT_TYPE)) {
                    // trigger the field validation
                    isValidForm = _fieldValidation(this);

                    if (!isValidForm) {
                        $failedFieldName = $(this);

                        // scroll only if element is outside viewport
                        if (!_isVisibleInViewPort($failedFieldName)) {
                            $('html, body').animate({
                                scrollTop: $failedFieldName.offset().top - 80
                            }, 'fast', function() {
                                // Callback after animation to focus the current field
                                $failedFieldName.focus();
                            });
                        } else {
                            $failedFieldName.focus();
                        }

                        // break loop when field validation failed
                        return false;
                    }
                }
            });

            return isValidForm;
        }

        /**
         * Manage the Submit button state to be enabled or disabled and
         * Show the loader accordingly.
         * 
         * @param {boolean} flag - true to enable submit button and hide loader and vice versa
         * @return {boolean} true of false based on form validation 
         */
        function enableSubmitButtonAndLoader(flag) {
            if (flag) {
                $submitButton.prop(DISABLED, false);
                $loader.addClass(HIDDEN);
            } else {
                $submitButton.prop(DISABLED, true);
                $loader.removeClass(HIDDEN);
            }
        }

        /**
         * populate (campaign) input hidden fields - for GET type forms
         *
         * @param {object} $formConfig - configurations of the form
         */
        function populateHiddenField($formConfig) {
            var $config = $formConfig;
            var $hiddenFields = $root.find('[type=hidden]');
            $hiddenFields.each(function(index, item) {
                var key = item.name;
                item.value = $config.urlParams[key] || item.value;
            });
        }

        /**
         * Before Form submittion (type: GET)
         * Update hidden fields with action URL Params
         * Update single checkbox with customized values
         */
        function getRequestParamsToHiddenFields() {
            // reset created hidden fields for every submission
            var $tempHiddenFields = $root.find('.js-temp-hidden-field[type=hidden]');
            $tempHiddenFields.each(function(index, item) {
                $(item).remove();
            });

            // create hidden fields
            var setInputHiddenField = function(key, value) {
                $root.find('fieldset').append('<input class="js-temp-hidden-field" type="hidden" name="' + key + '" value="' + value + '" />');
            };

            // fetch the url parameter from the form action path.
            var queryString = $formConfig.action;
            var actionParams = Utility.getUrlParams(queryString);
            if (actionParams) {
                for (var key in actionParams) {
                    setInputHiddenField(key, actionParams[key]);
                }
            }

            // TODO: Need to check if we can merge with _gatherAndSetCheckboxValue method. 
            // GET scenario to set non required single checkbox customized value.
            // required field is set during the form validation
            var nonReqFields = $root.find('input:not([required="true"])');
            nonReqFields.each(function() {
                var field = this;
                if (field.id.indexOf('_checkbox_single') !== -1) {

                    if (field.checked) {
                        field.value = field.dataset.selected;
                    } else {
                        // checkbox not selected: set checkbox as hidden field so that it will be sent via GET request
                        field.value = field.dataset.unselected;
                        setInputHiddenField(field.name, field.dataset.unselected);
                    }
                }
            });
        }

        /**
         * Submit Form type POST and Mail
         */
        function _submitFormPost() {
            var apiURL = $formConfig.clientPost ? $formConfig.action : Utility.getUrl($formConfig.formType);
            var formProcessedData = $formConfig.clientPost ? Utility.getGroupedFormData($root, $formConfig) : Utility.getJSONFormData($root, $formConfig);
            var headerObj = {};
            var custHeaders = $formConfig.headers;

            if (custHeaders !== '' && $formConfig.clientPost) {
                custHeaders = custHeaders.split(',');
                custHeaders.forEach(function(header) {
                    if (header.indexOf('=') !== -1) {
                        var item = header.split('=');
                        headerObj[item[0]] = item[1];
                    }
                });
            }

            // fetch the token on every submit, as it is a dynamic/random token
            var loginData = sessionStorage.getItem('loginDataStorage');
            if (loginData && $formConfig.isAuthToken) {
                var parsedObject = JSON.parse(loginData);
                var parsedObjectToken = parsedObject.token != undefined ? parsedObject.token : parsedObject.access_token;
                authorizationToken = parsedObjectToken || '';
            }

            // append APIG token for authentication of iSell API on the API Gateway
            if (authorizationToken !== '') {
                headerObj.Authorization = 'Bearer ' + authorizationToken;
            }

            if (!formProcessedData) {
                Notify.showMessage(false, $formConfig.jsonTemplateError);
                enableSubmitButtonAndLoader(true);
                return;
            }

            // JQuery AJAX request to post data to a Servlet/API
            $.ajax({
                    type: 'POST',
                    url: apiURL,
                    data: JSON.stringify(formProcessedData),
                    headers: headerObj,
                    contentType: 'application/json'
                })
                .success(function(msg, statusText, xhr) {
                    // for POST Client submission, any status code with 200 till 299 is valid response.
                    var rgx = /^2\d{2}$/;
                    var isSuccess = $formConfig.clientPost ? rgx.test(xhr.status) : msg === 'success';
                    if (isSuccess) {
                        var payload = {
                            gdl: {
                                category: 'form',
                                eventName: 'submit',
                                params: {
                                    name: $formConfig.formName
                                }
                            }
                        };
                        $analytics.push(payload);

                        FDX.DTM.pushButtonInfo('webform:formsuccess', 'samePage');
                        Notify.formSuccess();
                        enableSubmitButtonAndLoader(true);
                    } else {
                        FDX.DTM.pushButtonInfo('webform:formfail', 'samePage');
                        Notify.formFailed();
                        enableSubmitButtonAndLoader(true);
                    }
                })
                .error(function(error) {
                    FDX.DTM.pushButtonInfo('webform:formservererror:' + error.status, 'samePage');
                    Notify.formFailed();
                    enableSubmitButtonAndLoader(true);
                });
        }

        /**
         * set Focus event for required and constrained form fields
         */
        function _setFocusEvent($element) {
            $element.on('focus', function(event) {
                var payload = {
                    gdl: {
                        category: 'form',
                        eventName: 'start-interaction',
                        params: {
                            name: $formConfig.formName
                        }
                    }
                };
                $analytics.push(payload);
            });
        }

        /**
         * set Blur event for required and constrained form fields
         */
        function _setBlurEvent($element) {
            $element.on('blur', function(event) {
                event.preventDefault();
                _fieldValidation(this);
            });
        }
        /**
         * set Change event for select dropdown fields
         */
        function _setChangeEventAnalytics($element) {
            const domNode = $element[0];
            $element.on('change', function(event) {
                if (domNode.value) {
                    var payload = {
                        gdl: {
                            category: 'form',
                            eventName: 'update-data',
                            params: {
                                name: $formConfig.formName,
                                data: {}
                            }
                        }
                    };

                    if (domNode.tagName.toLowerCase() === 'select') {
                        payload.gdl.params.data['select|' + domNode.id] = (domNode.value || '')
                    }

                    $analytics.push(payload);
                }

            });
        }

        /**
         * fetch the Conditional SELECT content and register the required events
         */
        function fetchConditionalContent(field, contentPath) {
            if (FDX.contextPath === undefined) {
                if (typeof(fdx) !== 'undefined') {
                    FDX.contextPath = fdx.context.envtVar;
                }
            }
            if (field && contentPath !== '' && window.FDX.FetchService) {
                var $conditionalSelect = field;
                var path = FDX.contextPath + contentPath;
                var $conditionalSelectContent = $conditionalSelect.find('.js-conditional-select-content');

                var errorMessage = $conditionalSelect.data('error-message') || '';
                customErrorMessage = $conditionalSelect.data('form-error-message') || '';

                var $loader = $conditionalSelect.find('.js-fxg-spinner');
                $loader.removeClass(HIDDEN);

                window.FDX.FetchService.get(path, 'html')
                    .done(function(response) {
                        $loader.addClass(HIDDEN);
                        isValidCondContent = true;

                        var content = $('<div/>').append(response).find('.js-cms-conditional-form-template');
                        $conditionalSelectContent.empty().append(content);

                        // lazy INIT form elements like date picker
                        var $datePkr = $conditionalSelect.find('.js-fxg-date-picker-wrapper');
                        if ($datePkr.length > 0 && window.FDX.DATEPICKER) {
                            $datePkr.each(function(index, dpicker) {
                                window.FDX.DATEPICKER.init($(dpicker));
                            });
                        }

                        // REGISTER blur events for non disabled elements of conditional content.
                        // this is for field validation purpose
                        $conditionalSelect.find(':input:not([disabled])').each(function() {
                            if ($(this).data(REQUIRED_TYPE)) {
                                _setBlurEvent($(this));
                            }
                        });

                    }).fail(function(resp) {
                        // if no valid content, then block the form submission
                        isValidCondContent = false;
                        $loader.addClass(HIDDEN);
                        $conditionalSelectContent.empty().append('<span class="fxg-field__validation">' + errorMessage + '</span>');
                    });
            }
        }

        /**
         * Before Form submission (type: simplepost) using the HTML Form submission mechanism,
         * update we add single checkboxes checked or unchecked customised values.
         */
        function _gatherAndSetCheckboxValue() {
            var checkboxes = $root.find('input[type="checkbox"]');

            $.each(checkboxes, function(k, v) {
                var $self = $(v);

                var attr = $self.attr('data-selected');
                if (typeof attr !== typeof undefined && attr !== false) {

                    var selectedValue = $self.attr('data-selected');
                    var unselectedValue = $self.attr('data-unselected');

                    if ($self.is(":checked")) {
                        $self.val(selectedValue);
                    } else {
                        // For posting unchecked checkbox, we need to be check it and set unselected value
                        // so it will be submitted as unchecked
                        $self.prop('checked', true);
                        $self.val(unselectedValue);
                    }
                }
            });
        }

        /**
         * Method which triggers all form type submissions
         */
        function triggerFormSubmission() {
            if ($formConfig.formType == 'GET' || $formConfig.formType == 'simplepost') {

                // remove submit event listener
                $root.off('submit');

                // We do default form submit for 'GET' and 'simplepost' type.
                $root.on('submit', function(event) {
                    if ($formConfig.action === '') {
                        event.preventDefault();
                    } else {
                        if ($formConfig.formType == 'GET') {
                            getRequestParamsToHiddenFields();
                        } else {
                            // simplepost use case
                            _gatherAndSetCheckboxValue();
                        }

                        populateHiddenField($formConfig);

                        var $visitorIdField = $root.find('[data-visitor-cookie][type=hidden]');
                        Utility.setVisitorIdValue($visitorIdField);

                        FDX.DTM.pushButtonInfo("webform:formsuccess", "samePage");
                    }
                });

                // trigger default submit manually as we removed the actual default submit event listener
                $root.trigger('submit');
            } else {
                // form type: mail or post
                _submitFormPost();
            }
        }

        /**
         * Method to generate the OneTrust payload from the form configurations
         *
         * @return {Object} oneTrustPayload
         */
        function getOTPayload() {
            var oneTrustPayload = {
                identifier: '',
                test: '',
                dsDataElements: {
                    FirstName: '',
                    LastName: '',
                },
                requestInformation: '',
                purposes: [{
                    Id: ''
                }]
            };

            oneTrustPayload.identifier = $root.find('#' + $oneTrustConfig.otIdentifier).val() || '';
            oneTrustPayload.test = $root.find('#' + $oneTrustConfig.otTest + '_checkbox_single').is(":checked") ? true : false;
            oneTrustPayload.requestInformation = $oneTrustConfig.otAuthToken || '';
            oneTrustPayload.purposes[0].Id = $oneTrustConfig.otPurposeId || '';
            oneTrustPayload.dsDataElements.FirstName = $root.find('#' + $oneTrustConfig.otFirstName).val() || '';
            oneTrustPayload.dsDataElements.LastName = $root.find('#' + $oneTrustConfig.otLastName).val() || '';

            return oneTrustPayload;
        }

        /**
         * Submit to One trust API
         *
         * @return {Object} deferred promise
         */
        function submitOneTrust() {
            var deferred = $.Deferred();

            if (!$oneTrustConfig.isOTEnabled || $oneTrustConfig.otAPI === '') {
                // One trust is not enabled, so resolve immediatly.
                return deferred.resolve();
            }

            var postTimeout = 4000; // 4 seconds delay

            var oneTrustPayload = getOTPayload();
            var headerObj = {};
            headerObj.Authorization = 'Bearer ' + oneTrustPayload.requestInformation;

            $.ajax({
                    type: 'POST',
                    url: $oneTrustConfig.otAPI,
                    data: JSON.stringify(oneTrustPayload),
                    headers: headerObj,
                    timeout: postTimeout,
                    contentType: 'application/json'
                })
                .success(function() {
                    deferred.resolve();
                })
                .error(function() {
                    deferred.reject();
                });

            return deferred.promise();
        }

        /**
         * Init method to set Form events
         * required for submission, validation and fetching data
         */
        function _setFormEvents() {
            // Form default submit event
            $root.on('submit', function(event) {
                event.preventDefault();

                // check if form is validated
                if (!_formValidation()) {
                    return false;
                }

                // check for valid conditional form content and perform onetrust submission
                if (!isValidCondContent) {
                    Notify.formFailed(customErrorMessage);
                    FDX.DTM.pushButtonInfo('webform:formsubmit:content-error', 'samePage');
                } else {
                    // set button into spinner state
                    enableSubmitButtonAndLoader(false);

                    // one trust submission
                    submitOneTrust().then(function() {
                        // on success continue with the form submission
                        triggerFormSubmission();
                    }, function() {
                        // failed
                        Notify.formFailed();
                        enableSubmitButtonAndLoader(true);
                    });
                }
            });

            var $requiredFields = $root.find(REQUIRED_FIELDS);
            $requiredFields.each(function() {
                _setFocusEvent($(this));
                _setBlurEvent($(this));
            });

            var $constrainedFields = $root.find('.' + CONSTRAINED_FIELDS);
            $constrainedFields.each(function() {
                _setFocusEvent($(this));
                _setBlurEvent($(this));
            });

            // 'change' event for conditional select element
            $root.on('change', '.js-conditional-select', function(event) {
                event.preventDefault();
                var $condElement = $(this).closest('.js-conditional-select-wrapper');
                var contentPath = $(this[this.selectedIndex]).data('contentPath');
                fetchConditionalContent($condElement, contentPath);
            });

            // 'change' event for conditional select element 
            $root.find('select:not([disabled])').each(function() {
                _setChangeEventAnalytics($(this));
            });
        }

        /**
         * Set Form View analytics event
         */
        function _setFormViewAnalytics() {
            var payload = {
                gdl: {
                    category: 'form',
                    eventName: 'view',
                    params: {
                        name: $formConfig.formName,
                    }
                }
            };
            $analytics.push(payload);
        }

        // Set form view analytics
        _setFormViewAnalytics();

        // Initiate form events
        _setFormEvents();
    };

    // return the Instance of Form module
    var initComponent = function($element) {
        return FORMModule($element);
    };

    return {
        init: initComponent
    };
}(window.jQuery, _, window, window.FDX.services.analytics, window.FDX.services.utils));

// initiate all component instances on DOM ready
$(document).ready(function() {

    var $components = $('.js-c-form');
    $components.each(function(index, component) {
        window.FDX.INTERIMFORM.init($(component));
    });
});


/* This is the FedEx.com input app javascript file.
 The global FDX object must already be defined.

 Author: quantrell.sanford@vml.com
 Created: 2017-05-18
 */

if (!FDX) {
    var FDX = {};
}

// CHANGE: VMLNAFEDEXW-676 Add classes for LP Tracking Apps
FDX.INPUT = {
    maxInputCount: 30,
    addressFromAuto: '',
    geometryFromAuto: '',
    formClass: "fxg-form",
    multiTrackingClass: "fxg-tracking-app__multi-tracking",
    multiTrackingLandingPageClass: "fxg-landing-tracking-app__multi-tracking",
    singleTrackingClass: "fxg-app__single-tracking",
    singleTrackingLandingPageClass: "fxg-landing-tracking-app__single-tracking",
    validationMessageClass: "fxg-field__validation",
    validationDefaultMessage: "Sorry, this is a required field.",
    formRowClass: "fxg-form__row",
    datePickerClass: "fxg-field__date-picker",
    textInputClass: "fxg-field__input-text",
    requiredInputClass: "fxg-field__input--required",
    erroredInputClass: "fxg-field__input--error",
    numberedInputClass: "fxg-field__input-text--numbered",
    numberedPlaceholderClass: "fxg-field__numbered-placeholder",
    floatingPlaceholderClass: "fxg-field__floating-placeholder",
    inputAutoCompleteClass: "fxg-input__autocomplete",
    validationAlertSuffix: "fxg-validation-",
    splitMultiTrackingNumbers: function(input, callback) {
        var codeList = input.replace(/\n/g, ",") //strip line breaks
            .replace(/\r/g, ",")
            .replace(/\t/g, ",")
            .replace(/\s+/g, '') //strip spaces
            .replace(/,,/g, ',') //strip double commas
            .split(','); //if still have spaces then its pasted from word, so split

        if (callback)
            callback(codeList);
    },

    populateMultiTrackingNumbers: function(list) {
        for (var i = 0; i < list.length; i++) {
            if (list[i].length == 0)
                continue;
            //find current focus
            var currentField = $(':focus');

            //To get number of focussed input field
            var focusedField = $(currentField).attr("aria-label");
            var focusedFieldCount = parseInt(focusedField[focusedField.length - 2] + focusedField[focusedField.length - 1]);

            //Set input
            currentField.val(list[i]);

            //To add new fields for copy paste
            var parentInputDiv = currentField.closest('.' + FDX.INPUT.formRowClass);
            var isLastBox = $(parentInputDiv).next('.' + FDX.INPUT.formRowClass).find('.' + FDX.INPUT.floatingPlaceholderClass).length === 0 ? true : false;
            if (isLastBox && (focusedFieldCount + 1) <= FDX.INPUT.maxInputCount) {
                var cloneDiv = $(parentInputDiv).clone();
                var multiCountPadded = FDX.CORE.pad((focusedFieldCount + 1), 2);
                $(cloneDiv).find('.' + FDX.INPUT.floatingPlaceholderClass).html("TRACKING NUMBER " + multiCountPadded);
                var $inputField = $(cloneDiv).find('.' + FDX.INPUT.numberedInputClass);
                $inputField.val('');
                $inputField.attr('aria-label', FDX.TRACKING.multipleTrackingNumberAltText + ' ' + (focusedFieldCount + 1));
                $(cloneDiv).insertAfter(parentInputDiv);

                if (FDX.HERO)
                    FDX.HERO.setHeroHeight();

                if (FDX.TOGGLE)
                    FDX.TOGGLE.setActivePaneHeight($('.' + FDX.TOGGLE.toggleActivePanelClass));
            }

            //go to the next field
            if ($(currentField).parents('.' + FDX.INPUT.formRowClass).index() >= (FDX.INPUT.maxInputCount - 1)) {
                break;
            }
            var nextInput = $(currentField).parents('.' + FDX.INPUT.formRowClass).next().find('.' + FDX.INPUT.numberedInputClass);
            $(nextInput).focus();

        }
    },

    gmInitAutoComplete: function() {
        //Get all elements that have auto complete class


        var inputs = document.getElementsByClassName(FDX.INPUT.inputAutoCompleteClass);

        for (var i = 0; i < inputs.length; i++) {
            FDX.INPUT.inputAddListener(inputs, i);
        }
        $('.' + FDX.INPUT.inputAutoCompleteClass).on('keyup', function(e) {
            var dataInput = $(this).val();

            if (dataInput && (dataInput === FDX.DATALAYER.inputField)) {
                FDX.DATALAYER.googleAPIFlag = true;
            } else {
                FDX.DATALAYER.googleAPIFlag = false;
            }
        });
    },

    inputAddListener: function(inputs, i) {

        var autoComplete = new google.maps.places.Autocomplete(
            inputs[i], {
                types: ['geocode']
            }
        );

        // When the user selects an address from the dropdown, populate the address
        // fields in the form.
        autoComplete.addListener('place_changed', function() {
            FDX.INPUT.addressFromAuto = autoComplete.getPlace().address_components;
            FDX.INPUT.geometryFromAuto = autoComplete.getPlace().geometry.location;
            var currentField = inputs[i].value;
            FDX.DATALAYER.inputField = currentField;
            FDX.DATALAYER.googleAPIFlag = true;
        });
    },

    //VMLNAFEDEXW-717: Fix clipboard for ie
    getClipboardData: function(e) {
        var pastedText = '';

        if (window.clipboardData && window.clipboardData.getData) { // IE
            pastedText = window.clipboardData.getData('Text');
        } else if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) { // other browsers
            pastedText = e.originalEvent.clipboardData.getData('text/plain');
        }

        return pastedText;
    }
};

$(document).ready(function() {
    // given an HTML element, checks whether is valid or not.
    // in case of HTML Lists, validation succeeds if there is one active 'li' element
    // (having the class 'active')
    var isInvalid = function($field) {
        if (isList($field)) {
            return invalidField = ($field.find("li[class='active']").length === 0) ? true : false;
        } else {
            return invalidField = (!$field.val() || $field.val() == "") ? true : false;
        }
    };

    // checks if an HTML element is a valid HTML list
    var isList = function($field) {
        return $field.is("ul") || $field.is("ol");
    };

    // clear error-related status, attributes and surrounding elements from an input field
    var clearInvalidState = function($field) {
        $field.removeClass(FDX.INPUT.erroredInputClass);
        $field.attr("aria-invalid", "false");
        $field.removeAttr("aria-describedby");
        $field.parent().find('.' + FDX.INPUT.validationMessageClass).remove();
    };

    // clean-up <input> invalid state as soon as user type in something
    $('.' + FDX.INPUT.formClass + ' .' + FDX.INPUT.requiredInputClass).on("change, keyup", function() {
        var $element = $(this);
        if ($element.hasClass(FDX.INPUT.erroredInputClass) && !isInvalid($element)) {
            clearInvalidState($element);
        }
    });

    // clean-up invalid state on bootstrap-dropdown as soon as a user make a selection
    $('.' + FDX.DROPDOWN.bootstrapDropdownClass + ' a').on('click', function(e) {
        e.preventDefault();
        var $parentItem = $(this).parent(),
            $parentList = $parentItem.parent()
        $button = $(this).closest('.dropdown-toggle');
        if ($parentList.hasClass(FDX.INPUT.erroredInputClass)) {
            clearInvalidState($parentList);
            $button.next().focus();
        }
    });
    //Form validations. Must have at least on character
    $('.' + FDX.INPUT.formClass + ' :submit').on('click', function(e) {
        e.preventDefault();
        var form = $(this).parents('form:first');
        var fields = $(form).find('.' + FDX.INPUT.requiredInputClass);

        var $firstError = null,
            $alert = null;
        fields.each(function(index) {
            var $field = $(this);

            clearInvalidState($field);
            if (isInvalid($field)) {
                // if invalid, set the 'aria-invalid' attribute to 'true'
                $field.addClass(FDX.INPUT.erroredInputClass).focus();
                $field.attr("aria-invalid", "true");
                var msg = $field.data('errmsg') ? $field.data('errmsg') : FDX.INPUT.validationDefaultMessage;
                // create a container for the error message and link it to the field.
                // id is based on current milliseconds to ensure its uniqueness
                var id = FDX.INPUT.validationAlertSuffix + new Date().getTime();
                $field.attr("aria-describedby", id);
                var $currentAlert = $("<span />").addClass(FDX.INPUT.validationMessageClass)
                    .html(msg).attr("id", id);
                $currentAlert.appendTo($field.parent());

                if ($firstError === null) {
                    $firstError = $field;
                    $alert = $currentAlert;
                }
            }
        });

        if ($firstError === null)
            form.submit();
        else {
            // set focus to the first invalid field
            if (isList($firstError)) {
                $firstError = $firstError.parent().find("button");
            }
            // set the role to 'alert' to the first invalid field.
            // screen-readers should detect this change and read the text present
            // in this alert.
            $alert.attr("role", "alert");
            $firstError.focus();

            if (FDX.CUBE && form.parents('.' + FDX.CUBE.activeCubeClass).length > 0) {
                FDX.CUBE.setAppError();
            }
        }
    });

    //Set up date picker
    if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {
        $('.' + FDX.INPUT.datePickerClass).attr("type", "date");
    } else {
        $('.' + FDX.INPUT.datePickerClass).datepicker({
            showAnim: "",
            dayNamesMin: ["S", "M", "T", "W", "T", "F", "S"],
            onSelect: function() {
                var $input = $(this);
                if ($input.hasClass(FDX.INPUT.requiredInputClass)) {
                    // clean-up error messages
                    clearInvalidState($input);
                }
            }
        });
        // workaround: on window resize, if there is an opened datepicker,
        // it won't show responsiveness. the following code
        // resets its state.
        $(window).resize(function() {
            var $field = $(document.activeElement);
            if ($field.is('.hasDatepicker')) {
                $field.datepicker('hide').datepicker('show');
            }
        });
    }

    //Jump to multi tracking if more than on number is pasted on single
    $('.' + FDX.INPUT.singleTrackingClass + ' .' + FDX.INPUT.textInputClass).on('paste', function(e) {
        FDX.INPUT.splitMultiTrackingNumbers(FDX.INPUT.getClipboardData(e), function(list) {
            if (list.length > 1) {
                e.preventDefault();
                FDX.TRACKING.showMultiTracking();
                $('.fxg-tracking-app__multi-tracking .fxg-field__input-text--numbered').first().focus();
                FDX.INPUT.populateMultiTrackingNumbers(list);
            }
        });
    });

    //Jump to multi tracking if more than on number is pasted on single (Landing Page Traking Apps)
    $('.' + FDX.INPUT.singleTrackingLandingPageClass + ' .' + FDX.INPUT.textInputClass).on('paste', function(e) {
        FDX.INPUT.splitMultiTrackingNumbers(FDX.INPUT.getClipboardData(e), function(list) {
            if (list.length > 1) {
                e.preventDefault();
                FDX.TRACKING.showMultiTrackingLandingPage();
                $('.fxg-landing-tracking-app__multi-tracking .fxg-field__input-text--numbered').first().focus();
                FDX.INPUT.populateMultiTrackingNumbers(list);
            }
        });
    });

    $('.' + FDX.INPUT.singleTrackingClass + ' .' + FDX.INPUT.textInputClass).on('keydown', function(e) {
        if (e.which == 188 || e.keyCode == 188) {
            if ($(e.target).val() != '') {
                var list = [this.value];
                e.preventDefault();
                FDX.TRACKING.showMultiTracking();
                $('.fxg-tracking-app__multi-tracking .fxg-field__input-text--numbered').first().focus();
                FDX.INPUT.populateMultiTrackingNumbers(list);
            }
        }
    });

    $('.' + FDX.INPUT.singleTrackingLandingPageClass + ' .' + FDX.INPUT.textInputClass).on('keydown', function(e) {
        if (e.which == 188 || e.keyCode == 188) {
            if ($(e.target).val() != '') {
                var list = [this.value];
                e.preventDefault();
                FDX.TRACKING.showMultiTrackingLandingPage();
                $('.fxg-landing-tracking-app__multi-tracking .fxg-field__input-text--numbered').first().focus();
                FDX.INPUT.populateMultiTrackingNumbers(list);
            }
        }
    });

    $('.' + FDX.INPUT.datePickerClass).keydown(function(e) {
        if (e.which !== 9) {
            e.preventDefault();
        }
    });

    //Multi tracking events
    //On focus 
    $('.' + FDX.INPUT.multiTrackingClass + ' .' + FDX.INPUT.formClass + ',' +
        '.' + FDX.INPUT.multiTrackingLandingPageClass + ' .' + FDX.INPUT.formClass).on('keyup', '.' + FDX.INPUT.numberedInputClass, function(e) {
        var parentRow = $(this).closest('.' + FDX.INPUT.formRowClass);

        //console.log('Parent row log'+ $(this).closest('.' + FDX.INPUT.formRowClass+ ' div input.fxg-field__input-text').val().length);
        if ($(this).closest('.' + FDX.INPUT.formRowClass + ' div input.fxg-field__input-text').val().length >= 0 && e.which !== 9) {
            // calculate the number of existing inputs, by looking for this element's siblings
            var $inputs = $(this).closest('form').find('.' + FDX.INPUT.numberedInputClass),
                index = $inputs.index(this),
                currentCount = $inputs.length,
                // check if this is the last element number-input in this form
                isLast = $(parentRow).next('.' + FDX.INPUT.formRowClass).find('.' + FDX.INPUT.floatingPlaceholderClass).length === 0 ? true : false;

            if (isLast && currentCount < FDX.INPUT.maxInputCount) {
                var $previous = $inputs.eq(index - 1);
                if ($previous.val() === '') {
                    return;
                }
                currentCount++;
                var parentForm = $(parentRow).parent();
                var clone = $(parentRow).clone();
                var currentCountPadded = FDX.CORE.pad(currentCount, 2);
                $(clone).find('.' + FDX.INPUT.floatingPlaceholderClass).html("TRACKING NUMBER " + currentCountPadded);
                var $input = $(clone).find('.' + FDX.INPUT.numberedInputClass);
                $input.val('');
                $input.attr('aria-label', FDX.TRACKING.multipleTrackingNumberAltText + ' ' + currentCount);
                $(clone).insertAfter(parentRow);

                if (FDX.TOGGLE)
                    FDX.TOGGLE.setActivePaneHeight($('.' + FDX.TOGGLE.toggleActivePanelClass));
            }
        }
        //To remove the field that is newly added when the previous field does not contain value
        if ($(this).closest('.' + FDX.INPUT.formRowClass + ' div input.fxg-field__input-text').val().length === 0 && currentCount > 3 && index == currentCount - 2) {
            parentRow.next('.' + FDX.INPUT.formRowClass).remove();
        }
    });

    //On Tab
    $('.' + FDX.INPUT.multiTrackingClass + ' .' + FDX.INPUT.formClass + ',' +
        '.' + FDX.INPUT.multiTrackingLandingPageClass + ' .' + FDX.INPUT.formClass).on('keydown', '.' + FDX.INPUT.numberedInputClass, function(e) {

        if (e.which == 13 || e.keyCode == 13) {
            if ($(e.target).val() == '') {
                $(':focus').closest('form').find(':submit').focus();
            } else {
                e.preventDefault();
                $(this).parent().parent().next('.row').find('input').focus();
            }
        } else if (e.which == 188 || e.keyCode == 188) {

            if ($(e.target).val() == '') {

            } else {
                e.preventDefault();
                $(this).parent().parent().next('.row').find('input').focus();
            }
        }

    });
    // CHANGE: VMLNAFEDEXW-676 Add listeners for LP Tracking Apps
    //On paste
    $('.' + FDX.INPUT.multiTrackingClass + ' .' + FDX.INPUT.formClass + ',' +
        '.' + FDX.INPUT.multiTrackingLandingPageClass + ' .' + FDX.INPUT.formClass).on('paste', '.' + FDX.INPUT.numberedInputClass, function(e) {
        FDX.INPUT.splitMultiTrackingNumbers(FDX.INPUT.getClipboardData(e), function(list) {
            e.preventDefault();
            FDX.INPUT.populateMultiTrackingNumbers(list);
        });
    });

    //Google Maps autocomplete
    //Set placeholder to blank, otherwise google will place in default. 
    $('.' + FDX.INPUT.inputAutoCompleteClass).attr("placeholder", "");

    //753: Remove focus on Google Auto Complete on scroll. 
    $(window).on('scroll', function() {
        if ($('.pac-container:visible').length > 0) {
            $('.' + FDX.INPUT.inputAutoCompleteClass).blur();
        }
    });
});
/* This is the FedEx.com Simple Login Wall component javascript file.

 Author: troy.gottier.osv@fedex.com
 Created: 2018-03-27
 */
if (!FDX) {
    var FDX = {};
}
$(document).ready(function() {
    var imageGalleryContainer = $(".fxg-image_gallery");
    if (imageGalleryContainer.length > 0) {
        $.each(imageGalleryContainer, function() {
            var uuid = $(this).attr("data-uuid"),
                unlink = $(this).attr("data-unlink"),
                grow = $(this).attr("data-growattr"),
                children = $(this).find(".image_gallery_item").filter(function() {
                    return !$(this).closest(".inner_gallery").length;
                });
            $(this).find(".imageGalleryItems_v1").parent().closest('div').css({
                "display": "flex",
                "flex-wrap": "wrap"
            });
            $.each(children, function() {
                var modalTrigger = $(this).children("a"),
                    innerGalleryItems = $(this).find(".inner_gallery").find(".image_gallery_item");

                galleryImageBuilder(modalTrigger);

                if (unlink != "yes") {
                    modalTrigger.attr("data-fxmodalbox", uuid);
                }
                if (grow == "yes") {
                    $(this).css("flex-grow", 1);
                }
                if (innerGalleryItems.length > 0) {
                    var num = Math.floor(Math.random() * 99999999) + 1;
                    modalTrigger.attr("data-fxmodalbox", uuid + num);

                    $.each(innerGalleryItems, function() {
                        var modalTrigger = $(this).children("a");
                        modalTrigger.attr("data-fxmodalbox", uuid + num);
                        // build out gallery gallery images. 
                        // disabled to save bandwidth for users. 
                        // only see these in the modal window and it works off anchors not images
                        //						galleryImageBuilder(modalTrigger);
                    });
                }
            });
        });
    }

    function galleryImageBuilder(element) {
        // remove the text alowing users to click to go see the image
        element.empty();
        // build the img as a background
        var src = element.attr("href"),
            caption = element.attr("data-caption");

        element.css("background-image", "url(" + src + ")");

        if (caption != undefined) {
            element.append("<span class='caption'>" + caption + "</span>");
        }
    }
});
if (!FDX) {
    var FDX = {};
}

//==================================================
//fxModalBox v1.0.0
//Author: Troy Gottier (troy.gottier.osv@fedex.com)
//==================================================
;
(function(window, document, $, undefined) {
    'use strict';

    // fxModalBox requires jQuery
    // =========================================
    if (!$) {
        return;
    }

    // Check if fxModalBox is already initialized
    // ========================================

    if ($.fn.fxModalBox) {
        if ('fxModalBox' in window) {
            console.log('fxModalBox already has already been initialized');
        }
        return;
    }

    // Private default settings
    // ========================

    var defaults = {
        loop: true, // Enable or disable infinite gallery navigation
        margin: [44, 0], // Space around image, ignored if zoomed-in or viewport width is smaller than 800px
        gutter: 50, // Horizontal space between slides
        keyboard: true, // Enable keyboard navigation
        arrows: true, // Should display navigation arrows at the screen edges
        infobar: true, // Should display infobar (counter and arrows at the top)
        toolbar: true, // Should display toolbar (buttons at the top)

        // What buttons should appear in the top right corner.
        // Buttons will be created using templates from `btnTpl` option
        // and they will be placed into toolbar (class="fxModalBox-toolbar"` element)
        buttons: [
            //'slideShow',
            'fullScreen',
            //'thumbs',
            //'share',
            'download',
            //'zoom',
            'close'
        ],
        idleTime: 0, // Detect "idle" time in seconds

        // Should display buttons at top right corner of the content
        // If 'auto' - they will be created for content having type 'html', 'inline' or 'ajax'
        // Use template from `btnTpl.smallBtn` for customization
        smallBtn: 'auto',
        protect: false, // Disable right-click and use simple image protection for images
        modal: false, // Shortcut to make content "modal" - disable keyboard navigtion, hide buttons, etc
        image: {
            // Wait for images to load before displaying
            // Requires predefined image dimensions
            // If 'auto' - will zoom in thumbnail if 'width' and 'height' attributes are found
            preload: "auto"
        },
        ajax: {
            // Object containing settings for ajax request
            settings: {
                // This helps to indicate that request comes from the modal
                // Feel free to change naming
                data: {
                    fxModalBox: true
                }
            }
        },

        iframe: {
            // Iframe template
            tpl: '<iframe id="fxModalBox-frame{rnd}" name="fxModalBox-frame{rnd}" class="fxModalBox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen allowtransparency="true" src=""></iframe>',

            // Preload iframe before displaying it
            // This allows to calculate iframe content width and height
            // (note: Due to "Same Origin Policy", you can't get cross domain data).
            preload: true,

            // Custom CSS styling for iframe wrapping element
            // You can use this to set custom iframe dimensions
            css: {},

            // Iframe tag attributes
            attr: {
                scrolling: 'auto'
            }
        },
        defaultType: 'image', // Default content type if cannot be detected automatically

        // Open/close animation type
        // Possible values:
        //   false            - disable
        //   "zoom"           - zoom images from/to thumbnail
        //   "fade"
        //   "zoom-in-out"
        //
        animationEffect: "zoom",
        animationDuration: 500, // Duration in ms for open/close animation

        // Should image change opacity while zooming
        // If opacity is "auto", then opacity will be changed if image and thumbnail have different aspect ratios
        zoomOpacity: "auto",

        // Transition effect between slides
        //
        // Possible values:
        //   false            - disable
        //   "fade'
        //   "slide'
        //   "circular'
        //   "tube'
        //   "zoom-in-out'
        //   "rotate'
        //
        transitionEffect: "slide",
        transitionDuration: 366, // Duration in ms for transition animation
        slideClass: '', // Custom CSS class for slide element
        baseClass: '', // Custom CSS class for layout

        // Base template for layout
        baseTpl: '<div class="fxModalBox-container" role="dialog" tabindex="-1">' +
            '<div class="fxModalBox-bg"></div>' +
            '<div class="fxModalBox-inner">' +
            '<div class="fxModalBox-infobar">' +
            '<span data-fxModalBox-index></span>&nbsp;/&nbsp;<span data-fxModalBox-count></span>' +
            '</div>' +
            '<div class="fxModalBox-toolbar">{{buttons}}</div>' +
            '<div class="fxModalBox-navigation">{{arrows}}</div>' +
            '<div class="fxModalBox-stage"></div>' +
            '<div aria-live="polite" class="fxModalBox-caption-wrap"><div class="fxModalBox-caption"></div></div>' +
            '</div>' +
            '</div>',
        spinnerTpl: '<div class="fxModalBox-loading"></div>', // Loading indicator template
        errorTpl: '<div class="fxModalBox-error"><p>{{ERROR}}<p></div>', // Error message template

        btnTpl: {
            download: '<a download data-fxModalBox-download class="fxModalBox-button fxModalBox-button--download" title="{{DOWNLOAD}}">' +
                '<svg viewBox="0 0 40 40">' +
                '<path d="M20,23 L20,8 L20,23 L13,16 L20,23 L27,16 L20,23 M26,28 L13,28 L27,28 L14,28" />' +
                '</svg>' +
                '</a>',

            zoom: '<button data-fxModalBox-zoom class="fxModalBox-button fxModalBox-button--zoom" title="{{ZOOM}}">' +
                '<svg viewBox="0 0 40 40">' +
                '<path d="M 18,17 m-8,0 a 8,8 0 1,0 16,0 a 8,8 0 1,0 -16,0 M25,23 L31,29 L25,23" />' +
                '</svg>' +
                '</button>',

            close: '<button data-fxModalBox-close class="fxModalBox-button fxModalBox-button--close" title="{{CLOSE}}">' +
                '<svg viewBox="0 0 40 40">' +
                '<path d="M10,10 L30,30 M30,10 L10,30" />' +
                '</svg>' +
                '</button>',

            // This small close button will be appended to your html/inline/ajax content by default,
            // if "smallBtn" option is not set to false
            smallBtn: '<button data-fxModalBox-close class="fxModalBox-close-small" title="{{CLOSE}}"></button>',

            // Arrows
            arrowLeft: '<button data-fxModalBox-prev class="fxModalBox-button fxModalBox-button--arrow_left" title="{{PREV}}">' +
                '<svg viewBox="0 0 40 40">' +
                '<path d="M23,5 L13,20 L23,35 L13,20 L23,5"></path>' +
                '</svg>' +
                '</button>',

            arrowRight: '<button data-fxModalBox-next class="fxModalBox-button fxModalBox-button--arrow_right" title="{{NEXT}}">' +
                '<svg viewBox="0 0 40 40">' +
                '<path d="M17,5 L27,20 L17,35 L27,20 L17,5"></path>' +
                '</svg>' +
                '</button>'
        },
        parentEl: 'body', // Container is injected into this element


        // Focus handling
        // ==============
        autoFocus: false, // Try to focus on the first focusable element after opening 
        backFocus: true, // Put focus back to active element after closing
        trapFocus: true, // Do not let user to focus on element outside modal content

        // Module specific options
        // =======================
        fullScreen: {
            autoStart: false,
        },

        // Set `touch: false` to disable dragging/swiping
        touch: {
            vertical: true, // Allow to drag content vertically
            momentum: true // Continue movement after releasing mouse/touch when panning
        },
        // Hash value when initializing manually,
        // set `false` to disable hash change
        hash: null,

        // Customize or add new media types
        // Example:
        /*
        media : {
            youtube : {
                params : {
                    autoplay : 0
                }
            }
        }
        */
        media: {},
        slideShow: {
            autoStart: false,
            speed: 4000
        },
        thumbs: {
            autoStart: true, // Display thumbnails on opening
            hideOnClose: true, // Hide thumbnail grid when closing animation starts
            parentEl: '.fxModalBox-container', // Container is injected into this element
            axis: 'x' // Vertical (y) or horizontal (x) scrolling
        },
        // Use mousewheel to navigate gallery
        // If 'auto' - enabled for images only
        wheel: 'auto',
        // Callbacks
        //==========
        // See Documentation/API/Events for more information
        // Example:
        /*
            afterShow: function( instance, current ) {
                 console.info( 'Clicked element:' );
                 console.info( current.opts.$orig );
            }
        */
        onInit: $.noop, // When instance has been initialized
        beforeLoad: $.noop, // Before the content of a slide is being loaded
        afterLoad: $.noop, // When the content of a slide is done loading
        beforeShow: $.noop, // Before open animation starts
        afterShow: $.noop, // When content is done loading and animating
        beforeClose: $.noop, // Before the instance attempts to close. Return false to cancel the close.
        afterClose: $.noop, // After instance has been closed
        onActivate: $.noop, // When instance is brought to front
        onDeactivate: $.noop, // When other instance has been activated

        // Interaction
        // ===========
        // Use options below to customize taken action when user clicks or double clicks on the fxModalBox area,
        // each option can be string or method that returns value.
        //
        // Possible values:
        //   "close"           - close instance
        //   "next"            - move to next gallery item
        //   "nextOrClose"     - move to next gallery item or close if gallery has only one item
        //   "toggleControls"  - show/hide controls
        //   "zoom"            - zoom image (if loaded)
        //   false             - do nothing

        // Clicked on the content
        clickContent: function(current, event) {
            return current.type === 'image' ? 'zoom' : false;
        },
        clickSlide: 'close', // Clicked on the slide
        clickOutside: 'close', // Clicked on the background (backdrop) element
        // Same as previous two, but for double click
        dblclickContent: false,
        dblclickSlide: false,
        dblclickOutside: false,
        // Custom options when mobile device is detected
        // =============================================
        mobile: {
            idleTime: false,
            margin: 0,

            clickContent: function(current, event) {
                return current.type === 'image' ? 'toggleControls' : false;
            },
            clickSlide: function(current, event) {
                return current.type === 'image' ? 'toggleControls' : 'close';
            },
            dblclickContent: function(current, event) {
                return current.type === 'image' ? 'zoom' : false;
            },
            dblclickSlide: function(current, event) {
                return current.type === 'image' ? 'zoom' : false;
            }
        },
        // Internationalization
        // ============
        lang: 'en',
        i18n: {
            'en': {
                CLOSE: 'Close',
                NEXT: 'Next',
                PREV: 'Previous',
                ERROR: 'The requested content cannot be loaded. <br/> Please try again later.',
                PLAY_START: 'Start slideshow',
                PLAY_STOP: 'Pause slideshow',
                FULL_SCREEN: 'Full screen',
                THUMBS: 'Thumbnails',
                DOWNLOAD: 'Download',
                SHARE: 'Share',
                ZOOM: 'Zoom'
            },
            'de': {
                CLOSE: 'Schliessen',
                NEXT: 'Weiter',
                PREV: 'Zurück',
                ERROR: 'Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es später nochmal.',
                PLAY_START: 'Diaschau starten',
                PLAY_STOP: 'Diaschau beenden',
                FULL_SCREEN: 'Vollbild',
                THUMBS: 'Vorschaubilder',
                DOWNLOAD: 'Herunterladen',
                SHARE: 'Teilen',
                ZOOM: 'Maßstab'
            }
        }

    };
    // Few useful variables and methods
    // ================================
    var $W = $(window);
    var $D = $(document);
    var called = 0;

    // Check if an object is a jQuery object and not a native JavaScript object
    // ========================================================================
    var isQuery = function(obj) {
        return obj && obj.hasOwnProperty && obj instanceof $;
    };

    // Handle multiple browsers for "requestAnimationFrame" and "cancelAnimationFrame"
    // ===============================================================================
    var requestAFrame = (function() {
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            // if all else fails, use setTimeout
            function(callback) {
                return window.setTimeout(callback, 1000 / 60);
            };
    })();

    // Detect the supported transition-end event property name
    // =======================================================

    var transitionEnd = (function() {
        var t, el = document.createElement("fakeelement");

        var transitions = {
            "transition": "transitionend",
            "OTransition": "oTransitionEnd",
            "MozTransition": "transitionend",
            "WebkitTransition": "webkitTransitionEnd"
        };
        for (t in transitions) {
            if (el.style[t] !== undefined) {
                return transitions[t];
            }
        }
        return 'transitionend';
    })();

    // Force redraw on an element.
    // This helps in cases where the browser doesn't redraw an updated element properly.
    // ================================================================================
    var forceRedraw = function($el) {
        return ($el && $el.length && $el[0].offsetHeight);
    };

    // Class definition
    // ================

    var FxModalBox = function(content, opts, index) {
        var self = this;

        self.opts = $.extend(true, {
            index: index
        }, $.fxModalBox.defaults, opts || {});

        if ($.fxModalBox.isMobile) {
            self.opts = $.extend(true, {}, self.opts, self.opts.mobile);
        }

        // Exclude buttons option from deep merging
        if (opts && $.isArray(opts.buttons)) {
            self.opts.buttons = opts.buttons;
        }

        self.id = self.opts.id || ++called;
        self.group = [];

        self.currIndex = parseInt(self.opts.index, 10) || 0;
        self.prevIndex = null;

        self.prevPos = null;
        self.currPos = 0;

        self.firstRun = null;

        // Create group elements from original item collection
        self.createGroup(content);

        if (!self.group.length) {
            return;
        }

        // Save last active element and current scroll position
        self.$lastFocus = $(document.activeElement).blur();

        // Collection of gallery objects
        self.slides = {};

        self.init();
    };

    $.extend(FxModalBox.prototype, {

        // Create DOM structure
        // ====================

        init: function() {
            var self = this,
                firstItem = self.group[self.currIndex],
                firstItemOpts = firstItem.opts,
                scrollbarWidth = $.fxModalBox.scrollbarWidth,
                $scrollDiv,
                $container,
                buttonStr;

            self.scrollTop = $D.scrollTop();
            self.scrollLeft = $D.scrollLeft();


            // Hide scrollbars
            // ===============

            if (!$.fxModalBox.getInstance()) {
                $('body').addClass('fxModalBox-active');
                // iOS hack
                if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
                    // iOS has problems for input elements inside fixed containers,
                    // the workaround is to apply `position: fixed` to `<body>` element,
                    // unfortunately, this makes it lose the scrollbars and forces address bar to appear.
                    if (firstItem.type !== 'image') {
                        $('body').css('top', $('body').scrollTop() * -1).addClass('fxModalBox-iosfix');
                    }
                } else if (!$.fxModalBox.isMobile && document.body.scrollHeight > window.innerHeight) {
                    if (scrollbarWidth === undefined) {
                        $scrollDiv = $('<div style="width:50px;height:50px;overflow:scroll;" />').appendTo('body');

                        scrollbarWidth = $.fxModalBox.scrollbarWidth = $scrollDiv[0].offsetWidth - $scrollDiv[0].clientWidth;

                        $scrollDiv.remove();
                    }
                    $('head').append('<style id="fxModalBox-style-noscroll" type="text/css">.compensate-for-scrollbar { margin-right: ' + scrollbarWidth + 'px; }</style>');
                    $('body').addClass('compensate-for-scrollbar');
                }
            }

            // Build html markup and set references
            // ====================================

            // Build html code for buttons and insert into main template
            buttonStr = '';

            $.each(firstItemOpts.buttons, function(index, value) {
                buttonStr += (firstItemOpts.btnTpl[value] || '');
            });

            // Create markup from base template, it will be initially hidden to
            // avoid unnecessary work like painting while initializing is not complete
            $container = $(
                    self.translate(self,
                        firstItemOpts.baseTpl
                        .replace('\{\{buttons\}\}', buttonStr)
                        .replace('\{\{arrows\}\}', firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight)
                    )
                )
                .attr('id', 'fxModalBox-container-' + self.id)
                .addClass('fxModalBox-is-hidden')
                .addClass(firstItemOpts.baseClass)
                .data('FxModalBox', self)
                .appendTo(firstItemOpts.parentEl);

            // Create object holding references to jQuery wrapped nodes
            self.$refs = {
                container: $container
            };

            ['bg', 'inner', 'infobar', 'toolbar', 'stage', 'caption', 'navigation'].forEach(function(item) {
                self.$refs[item] = $container.find('.fxModalBox-' + item);
            });

            self.trigger('onInit');

            // Enable events, deactive previous instances
            self.activate();

            // Build slides, load and reveal content
            self.jumpTo(self.currIndex);
        },


        // Simple i18n support - replaces object keys found in template
        // with corresponding values
        // ============================================================

        translate: function(obj, str) {
            var arr = obj.opts.i18n[obj.opts.lang];

            return str.replace(/\{\{(\w+)\}\}/g, function(match, n) {
                var value = arr[n];

                if (value === undefined) {
                    return match;
                }

                return value;
            });
        },

        // Create array of gallery item objects
        // Check if each object has valid type and content
        // ===============================================

        createGroup: function(content) {
            var self = this;
            var items = $.makeArray(content);

            $.each(items, function(i, item) {
                var obj = {},
                    opts = {},
                    $item,
                    type,
                    found,
                    src,
                    srcParts;

                // Step 1 - Make sure we have an object
                // ====================================

                if ($.isPlainObject(item)) {
                    // We probably have manual usage here, something like
                    // $.fxModalBox.open( [ { src : "image.jpg", type : "image" } ] )
                    obj = item;
                    opts = item.opts || item;
                } else if ($.type(item) === 'object' && $(item).length) {

                    // Here we probably have jQuery collection returned by some selector
                    $item = $(item);

                    opts = $item.data();
                    opts = $.extend({}, opts, opts.options || {});

                    // Here we store clicked element
                    opts.$orig = $item;

                    obj.src = opts.src || $item.attr('href');

                    // Assume that simple syntax is used, for example:
                    //   `$.fxModalBox.open( $("#test"), {} );`
                    if (!obj.type && !obj.src) {
                        obj.type = 'inline';
                        obj.src = item;
                    }
                } else {
                    // Assume we have a simple html code, for example:
                    //   $.fxModalBox.open( '<div><h1>Hi!</h1></div>' );
                    obj = {
                        type: 'html',
                        src: item + ''
                    };

                }
                // Each gallery object has full collection of options
                obj.opts = $.extend(true, {}, self.opts, opts);
                // Do not merge buttons array
                if ($.isArray(opts.buttons)) {
                    obj.opts.buttons = opts.buttons;
                }

                // Step 2 - Make sure we have content type, if not - try to guess
                // ==============================================================
                type = obj.type || obj.opts.type;
                src = obj.src || '';

                if (!type && src) {
                    if (src.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)) {
                        type = 'image';

                    } else if (src.match(/\.(pdf)((\?|#).*)?$/i)) {
                        type = 'pdf';

                    } else if (found = src.match(/\.(mp4|mov|ogv)((\?|#).*)?$/i)) {
                        type = 'video';
                        if (!obj.opts.videoFormat) {
                            obj.opts.videoFormat = 'video/' + (found[1] === 'ogv' ? 'ogg' : found[1]);
                        }
                    } else if (src.charAt(0) === '#') {
                        type = 'inline';
                    }
                }

                if (type) {
                    obj.type = type;

                } else {
                    self.trigger('objectNeedsType', obj);
                }
                // Step 3 - Some adjustments
                // =========================

                obj.index = self.group.length;

                // Check if $orig and $thumb objects exist
                if (obj.opts.$orig && !obj.opts.$orig.length) {
                    delete obj.opts.$orig;
                }
                if (!obj.opts.$thumb && obj.opts.$orig) {
                    obj.opts.$thumb = obj.opts.$orig.find('img:first');
                }
                if (obj.opts.$thumb && !obj.opts.$thumb.length) {
                    delete obj.opts.$thumb;
                }
                // "caption" is a "special" option, it can be used to customize caption per gallery item ..
                if ($.type(obj.opts.caption) === 'function') {
                    obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);
                }
                if ($.type(self.opts.caption) === 'function') {
                    obj.opts.caption = self.opts.caption.apply(item, [self, obj]);
                }
                // Make sure we have caption as a string or jQuery object
                if (!(obj.opts.caption instanceof $)) {
                    obj.opts.caption = obj.opts.caption === undefined ? '' : obj.opts.caption + '';
                }
                // Check if url contains "filter" used to filter the content
                // Example: "ajax.html #something"
                if (type === 'ajax') {
                    srcParts = src.split(/\s+/, 2);
                    if (srcParts.length > 1) {
                        obj.src = srcParts.shift();
                        obj.opts.filter = srcParts.shift();
                    }
                }
                if (obj.opts.smallBtn == 'auto') {
                    if ($.inArray(type, ['html', 'inline', 'ajax']) > -1) {
                        obj.opts.toolbar = false;
                        obj.opts.smallBtn = true;
                    } else {
                        obj.opts.smallBtn = false;
                    }
                }
                // If the type is "pdf", then simply load file into iframe
                if (type === 'pdf') {
                    obj.type = 'iframe';
                    obj.opts.iframe.preload = false;
                }
                // Hide all buttons and disable interactivity for modal items
                if (obj.opts.modal) {
                    obj.opts = $.extend(true, obj.opts, {
                        // Remove buttons
                        infobar: 0,
                        toolbar: 0,
                        smallBtn: 0,
                        // Disable keyboard navigation
                        keyboard: 0,
                        // Disable some modules
                        slideShow: 0,
                        fullScreen: 0,
                        thumbs: 0,
                        touch: 0,
                        // Disable click event handlers
                        clickContent: false,
                        clickSlide: false,
                        clickOutside: false,
                        dblclickContent: false,
                        dblclickSlide: false,
                        dblclickOutside: false
                    });

                }
                // Step 4 - Add processed object to group
                // ======================================
                self.group.push(obj);
            });
        },

        // Attach an event handler functions for:
        //   - navigation buttons
        //   - browser scrolling, resizing;
        //   - focusing
        //   - keyboard
        //   - detect idle
        // ======================================

        addEvents: function() {
            var self = this;
            var rightToLeftValue = $('#imagegalleryRtl').val();
            self.removeEvents();
            // Make navigation elements clickable
            self.$refs.container.on('click.fxmb-close', '[data-fxModalBox-close]', function(e) {
                e.stopPropagation();
                e.preventDefault();
                self.close(e);
            }).on('click.fxmb-prev touchend.fxmb-prev', '[data-fxModalBox-prev]', function(e) {
                e.stopPropagation();
                e.preventDefault();
                if (rightToLeftValue === "true") {
                    self.next();
                } else {
                    self.previous();
                }
            }).on('click.fxmb-next touchend.fxmb-next', '[data-fxModalBox-next]', function(e) {
                e.stopPropagation();
                e.preventDefault();
                if (rightToLeftValue === "true") {
                    self.previous();
                } else {
                    self.next();
                }
            }).on('click.fxmb', '[data-fxModalBox-zoom]', function(e) {
                // Click handler for zoom button
                self[self.isScaledDown() ? 'scaleToActual' : 'scaleToFit']();
            });

            // Handle page scrolling and browser resizing
            $W.on('orientationchange.fxmb resize.fxmb', function(e) {
                if (e && e.originalEvent && e.originalEvent.type === "resize") {
                    requestAFrame(function() {
                        self.update();
                    });
                } else {
                    self.$refs.stage.hide();
                    setTimeout(function() {
                        self.$refs.stage.show();
                        self.update();
                    }, 600);
                }
            });

            // Trap keyboard focus inside of the modal, so the user does not accidentally tab outside of the modal
            // (a.k.a. "escaping the modal")
            $D.on('focusin.fxmb', function(e) {
                var instance = $.fxModalBox ? $.fxModalBox.getInstance() : null;

                if (instance.isClosing || !instance.current || !instance.current.opts.trapFocus || $(e.target).hasClass('fxModalBox-container') || $(e.target).is(document)) {
                    return;
                }
                if (instance && $(e.target).css('position') !== 'fixed' && !instance.$refs.container.has(e.target).length) {
                    e.stopPropagation();
                    instance.focus();
                    // Sometimes page gets scrolled, set it back
                    $W.scrollTop(self.scrollTop).scrollLeft(self.scrollLeft);
                }
            });

            // Enable keyboard navigation
            $D.on('keydown.fxmb', function(e) {
                var current = self.current,
                    keycode = e.keyCode || e.which;

                if (!current || !current.opts.keyboard) {
                    return;
                }
                if ($(e.target).is('input') || $(e.target).is('textarea')) {
                    return;
                }
                // Backspace and Esc keys
                if (keycode === 8 || keycode === 27) {
                    e.preventDefault();
                    self.close(e);
                    return;
                }
                // Left arrow and Up arrow
                if (keycode === 37 || keycode === 38) {
                    e.preventDefault();
                    self.previous();
                    return;
                }

                // Righ arrow and Down arrow
                if (keycode === 39 || keycode === 40) {
                    e.preventDefault();
                    self.next();
                    return;
                }
                self.trigger('afterKeydown', e, keycode);
            });

            // Hide controls after some inactivity period
            if (self.group[self.currIndex].opts.idleTime) {
                self.idleSecondsCounter = 0;
                $D.on('mousemove.fxmb-idle mouseleave.fxmb-idle mousedown.fxmb-idle touchstart.fxmb-idle touchmove.fxmb-idle scroll.fxmb-idle keydown.fxmb-idle', function(e) {
                    self.idleSecondsCounter = 0;
                    if (self.isIdle) {
                        self.showControls();
                    }
                    self.isIdle = false;
                });
                self.idleInterval = window.setInterval(function() {
                    self.idleSecondsCounter++;
                    if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) {
                        self.isIdle = true;
                        self.idleSecondsCounter = 0;

                        self.hideControls();
                    }
                }, 1000);
            }

        },

        // Remove events added by the core
        // ===============================
        removeEvents: function() {
            var self = this;
            $W.off('orientationchange.fxmb resize.fxmb');
            $D.off('focusin.fxmb keydown.fxmb .fxmb-idle');
            this.$refs.container.off('.fxmb-close .fxmb-prev .fxmb-next');

            if (self.idleInterval) {
                window.clearInterval(self.idleInterval);
                self.idleInterval = null;
            }
        },

        // Change to previous gallery item
        // ===============================
        previous: function(duration) {
            return this.jumpTo(this.currPos - 1, duration);
        },
        // Change to next gallery item
        // ===========================
        next: function(duration) {
            return this.jumpTo(this.currPos + 1, duration);
        },
        // Switch to selected gallery item
        // ===============================
        jumpTo: function(pos, duration, slide) {
            var self = this,
                firstRun,
                loop,
                current,
                previous,
                canvasWidth,
                currentPos,
                transitionProps;
            var groupLen = self.group.length;
            if (self.isDragging || self.isClosing || (self.isAnimating && self.firstRun)) {
                return;
            }
            pos = parseInt(pos, 10);
            loop = self.current ? self.current.opts.loop : self.opts.loop;
            if (!loop && (pos < 0 || pos >= groupLen)) {
                return false;
            }
            firstRun = self.firstRun = (self.firstRun === null);
            if (groupLen < 2 && !firstRun && !!self.isDragging) {
                return;
            }
            previous = self.current;
            self.prevIndex = self.currIndex;
            self.prevPos = self.currPos;
            // Create slides
            current = self.createSlide(pos);
            if (groupLen > 1) {
                if (loop || current.index > 0) {
                    self.createSlide(pos - 1);
                }
                if (loop || current.index < groupLen - 1) {
                    self.createSlide(pos + 1);
                }
            }
            self.current = current;
            self.currIndex = current.index;
            self.currPos = current.pos;
            self.trigger('beforeShow', firstRun);
            self.updateControls();
            currentPos = $.fxModalBox.getTranslate(current.$slide);
            current.isMoved = (currentPos.left !== 0 || currentPos.top !== 0) && !current.$slide.hasClass('fxModalBox-animated');
            current.forcedDuration = undefined;

            if ($.isNumeric(duration)) {
                current.forcedDuration = duration;
            } else {
                duration = current.opts[firstRun ? 'animationDuration' : 'transitionDuration'];
            }
            duration = parseInt(duration, 10);
            // Fresh start - reveal container, current slide and start loading content
            if (firstRun) {
                if (current.opts.animationEffect && duration) {
                    self.$refs.container.css('transition-duration', duration + 'ms');
                }
                self.$refs.container.removeClass('fxModalBox-is-hidden');
                forceRedraw(self.$refs.container);
                self.$refs.container.addClass('fxModalBox-is-open');
                // Make first slide visible (to display loading icon, if needed)
                current.$slide.addClass('fxModalBox-slide--current');
                self.loadSlide(current);
                self.preload('image');
                return;
            }
            // Clean up
            $.each(self.slides, function(index, slide) {
                $.fxModalBox.stop(slide.$slide);
            });

            // Make current that slide is visible even if content is still loading
            current.$slide.removeClass('fxModalBox-slide--next fxModalBox-slide--previous').addClass('fxModalBox-slide--current');

            // If slides have been dragged, animate them to correct position
            if (current.isMoved) {
                canvasWidth = Math.round(current.$slide.width());
                $.each(self.slides, function(index, slide) {
                    var pos = slide.pos - current.pos;
                    $.fxModalBox.animate(slide.$slide, {
                        top: 0,
                        left: (pos * canvasWidth) + (pos * slide.opts.gutter)
                    }, duration, function() {
                        slide.$slide.removeAttr('style').removeClass('fxModalBox-slide--next fxModalBox-slide--previous');
                        if (slide.pos === self.currPos) {
                            current.isMoved = false;
                            self.complete();
                        }
                    });
                });
            } else {
                self.$refs.stage.children().removeAttr('style');
            }
            // Start transition that reveals current content
            // or wait when it will be loaded
            if (current.isLoaded) {
                self.revealContent(current);
            } else {
                self.loadSlide(current);
            }
            self.preload('image');
            if (previous.pos === current.pos) {
                return;
            }
            // Handle previous slide
            // =====================
            transitionProps = 'fxModalBox-slide--' + (previous.pos > current.pos ? 'next' : 'previous');
            previous.$slide.removeClass('fxModalBox-slide--complete fxModalBox-slide--current fxModalBox-slide--next fxModalBox-slide--previous');
            previous.isComplete = false;
            if (!duration || (!current.isMoved && !current.opts.transitionEffect)) {
                return;
            }
            if (current.isMoved) {
                previous.$slide.addClass(transitionProps);
            } else {
                transitionProps = 'fxModalBox-animated ' + transitionProps + ' fxModalBox-fx-' + current.opts.transitionEffect;
                $.fxModalBox.animate(previous.$slide, transitionProps, duration, function() {
                    previous.$slide.removeClass(transitionProps).removeAttr('style');
                });
            }
        },
        // Create new "slide" element
        // These are gallery items  that are actually added to DOM
        // =======================================================
        createSlide: function(pos) {
            var self = this;
            var $slide;
            var index;

            index = pos % self.group.length;
            index = index < 0 ? self.group.length + index : index;

            if (!self.slides[pos] && self.group[index]) {
                $slide = $('<div class="fxModalBox-slide"></div>').appendTo(self.$refs.stage);
                self.slides[pos] = $.extend(true, {}, self.group[index], {
                    pos: pos,
                    $slide: $slide,
                    isLoaded: false,
                });
                self.updateSlide(self.slides[pos]);
            }
            return self.slides[pos];
        },

        // Scale image to the actual size of the image
        // ===========================================

        scaleToActual: function(x, y, duration) {
            var self = this;
            var current = self.current;
            var $what = current.$content;
            var imgPos, posX, posY, scaleX, scaleY;
            var canvasWidth = parseInt(current.$slide.width(), 10);
            var canvasHeight = parseInt(current.$slide.height(), 10);
            var newImgWidth = current.width;
            var newImgHeight = current.height;

            if (!(current.type == 'image' && !current.hasError) || !$what || self.isAnimating) {
                return;
            }

            $.fxModalBox.stop($what);
            self.isAnimating = true;
            x = x === undefined ? canvasWidth * 0.5 : x;
            y = y === undefined ? canvasHeight * 0.5 : y;
            imgPos = $.fxModalBox.getTranslate($what);
            scaleX = newImgWidth / imgPos.width;
            scaleY = newImgHeight / imgPos.height;
            // Get center position for original image
            posX = (canvasWidth * 0.5 - newImgWidth * 0.5);
            posY = (canvasHeight * 0.5 - newImgHeight * 0.5);
            // Make sure image does not move away from edges
            if (newImgWidth > canvasWidth) {
                posX = imgPos.left * scaleX - ((x * scaleX) - x);
                if (posX > 0) {
                    posX = 0;
                }
                if (posX < canvasWidth - newImgWidth) {
                    posX = canvasWidth - newImgWidth;
                }
            }
            if (newImgHeight > canvasHeight) {
                posY = imgPos.top * scaleY - ((y * scaleY) - y);
                if (posY > 0) {
                    posY = 0;
                }
                if (posY < canvasHeight - newImgHeight) {
                    posY = canvasHeight - newImgHeight;
                }
            }
            self.updateCursor(newImgWidth, newImgHeight);
            $.fxModalBox.animate($what, {
                top: posY,
                left: posX,
                scaleX: scaleX,
                scaleY: scaleY
            }, duration || 330, function() {
                self.isAnimating = false;
            });
            // Stop slideshow
            if (self.SlideShow && self.SlideShow.isActive) {
                self.SlideShow.stop();
            }
        },

        // Scale image to fit inside parent element
        // ========================================
        scaleToFit: function(duration) {
            var self = this;
            var current = self.current;
            var $what = current.$content;
            var end;
            if (!(current.type == 'image' && !current.hasError) || !$what || self.isAnimating) {
                return;
            }
            $.fxModalBox.stop($what);
            self.isAnimating = true;
            end = self.getFitPos(current);
            self.updateCursor(end.width, end.height);
            $.fxModalBox.animate($what, {
                top: end.top,
                left: end.left,
                scaleX: end.width / $what.width(),
                scaleY: end.height / $what.height()
            }, duration || 330, function() {
                self.isAnimating = false;
            });
        },
        // Calculate image size to fit inside viewport
        // ===========================================
        getFitPos: function(slide) {
            var self = this;
            var $what = slide.$content;
            var imgWidth = slide.width;
            var imgHeight = slide.height;
            var margin = slide.opts.margin;
            var canvasWidth, canvasHeight, minRatio, width, height;
            if (!$what || !$what.length || (!imgWidth && !imgHeight)) {
                return false;
            }
            // Convert "margin to CSS style: [ top, right, bottom, left ]
            if ($.type(margin) === "number") {
                margin = [margin, margin];
            }
            if (margin.length == 2) {
                margin = [margin[0], margin[1], margin[0], margin[1]];
            }
            // We can not use $slide width here, because it can have different diemensions while in transiton
            canvasWidth = parseInt(self.$refs.stage.width(), 10) - (margin[1] + margin[3]);
            canvasHeight = parseInt(self.$refs.stage.height(), 10) - (margin[0] + margin[2]);
            minRatio = Math.min(1, canvasWidth / imgWidth, canvasHeight / imgHeight);
            width = Math.floor(minRatio * imgWidth);
            height = Math.floor(minRatio * imgHeight);
            // Use floor rounding to make sure it really fits
            return {
                top: Math.floor((canvasHeight - height) * 0.5) + margin[0],
                left: Math.floor((canvasWidth - width) * 0.5) + margin[3],
                width: width,
                height: height
            };
        },
        // Update content size and position for all slides
        // ==============================================
        update: function() {
            var self = this;
            $.each(self.slides, function(key, slide) {
                self.updateSlide(slide);
            });
        },
        // Update slide content position and size
        // ======================================
        updateSlide: function(slide, duration) {
            var self = this,
                $what = slide && slide.$content;
            if ($what && (slide.width || slide.height)) {
                self.isAnimating = false;
                $.fxModalBox.stop($what);
                $.fxModalBox.setTranslate($what, self.getFitPos(slide));
                if (slide.pos === self.currPos) {
                    self.updateCursor();
                }
            }
            slide.$slide.trigger('refresh');
            self.trigger('onUpdate', slide);
        },
        // Horizontally center slide
        // =========================
        centerSlide: function(slide, duration) {
            var self = this,
                canvasWidth, pos;
            if (self.current) {
                canvasWidth = Math.round(slide.$slide.width());
                pos = slide.pos - self.current.pos;
                $.fxModalBox.animate(slide.$slide, {
                    top: 0,
                    left: (pos * canvasWidth) + (pos * slide.opts.gutter),
                    opacity: 1
                }, duration === undefined ? 0 : duration, null, false);
            }
        },
        // Update cursor style depending if content can be zoomed
        // ======================================================
        updateCursor: function(nextWidth, nextHeight) {
            var self = this;
            var isScaledDown;
            var $container = self.$refs.container.removeClass('fxModalBox-is-zoomable fxModalBox-can-zoomIn fxModalBox-can-drag fxModalBox-can-zoomOut');
            if (!self.current || self.isClosing) {
                return;
            }
            if (self.isZoomable()) {
                $container.addClass('fxModalBox-is-zoomable');
                if (nextWidth !== undefined && nextHeight !== undefined) {
                    isScaledDown = nextWidth < self.current.width && nextHeight < self.current.height;
                } else {
                    isScaledDown = self.isScaledDown();
                }
                if (isScaledDown) {
                    // If image is scaled down, then, obviously, it can be zoomed to full size
                    $container.addClass('fxModalBox-can-zoomIn');
                } else {
                    if (self.current.opts.touch) {
                        // If image size ir largen than available available and touch module is not disable,
                        // then user can do panning
                        $container.addClass('fxModalBox-can-drag');
                    } else {
                        $container.addClass('fxModalBox-can-zoomOut');
                    }
                }
            } else if (self.current.opts.touch) {
                $container.addClass('fxModalBox-can-drag');
            }
        },
        // Check if current slide is zoomable
        // ==================================
        isZoomable: function() {
            var self = this;
            var current = self.current;
            var fitPos;
            if (!current || self.isClosing) {
                return;
            }
            // Assume that slide is zoomable if
            //   - image is loaded successfuly
            //   - click action is "zoom"
            //   - actual size of the image is smaller than available area
            if (current.type === 'image' && current.isLoaded && !current.hasError &&
                (current.opts.clickContent === 'zoom' || ($.isFunction(current.opts.clickContent) && current.opts.clickContent(current) === "zoom"))
            ) {
                fitPos = self.getFitPos(current);
                if (current.width > fitPos.width || current.height > fitPos.height) {
                    return true;
                }
            }
            return false;
        },
        // Check if current image dimensions are smaller than actual
        // =========================================================
        isScaledDown: function() {
            var self = this;
            var current = self.current;
            var $what = current.$content;
            var rez = false;
            if ($what) {
                rez = $.fxModalBox.getTranslate($what);
                rez = rez.width < current.width || rez.height < current.height;
            }
            return rez;
        },
        // Check if image dimensions exceed parent element
        // ===============================================
        canPan: function() {
            var self = this;
            var current = self.current;
            var $what = current.$content;
            var rez = false;
            if ($what) {
                rez = self.getFitPos(current);
                rez = Math.abs($what.width() - rez.width) > 1 || Math.abs($what.height() - rez.height) > 1;
            }
            return rez;
        },
        // Load content into the slide
        // ===========================
        loadSlide: function(slide) {
            var self = this,
                type, $slide;
            var ajaxLoad;
            if (slide.isLoading) {
                return;
            }
            if (slide.isLoaded) {
                return;
            }
            slide.isLoading = true;
            self.trigger('beforeLoad', slide);
            type = slide.type;
            $slide = slide.$slide;
            $slide
                .off('refresh')
                .trigger('onReset')
                .addClass('fxModalBox-slide--' + (type || 'unknown'))
                .addClass(slide.opts.slideClass);
            // Create content depending on the type
            switch (type) {
                case 'image':
                    self.setImage(slide);
                    break;
                case 'iframe':
                    self.setIframe(slide);
                    break;
                case 'html':
                    self.setContent(slide, slide.src || slide.content);
                    break;
                case 'inline':
                    if ($(slide.src).length) {
                        self.setContent(slide, $(slide.src));
                    } else {
                        self.setError(slide);
                    }
                    break;
                case 'ajax':
                    self.showLoading(slide);
                    ajaxLoad = $.ajax($.extend({}, slide.opts.ajax.settings, {
                        url: slide.src,
                        success: function(data, textStatus) {
                            if (textStatus === 'success') {
                                self.setContent(slide, data);
                            }
                        },
                        error: function(jqXHR, textStatus) {
                            if (jqXHR && textStatus !== 'abort') {
                                self.setError(slide);
                            }
                        }
                    }));
                    $slide.one('onReset', function() {
                        ajaxLoad.abort();
                    });
                    break;
                case 'video':
                    self.setContent(slide,
                        '<video controls>' +
                        '<source src="' + slide.src + '" type="' + slide.opts.videoFormat + '">' +
                        'Your browser doesn\'t support HTML5 video' +
                        '</video>'
                    );
                    break;
                default:
                    self.setError(slide);
                    break;
            }
            return true;
        },


        // Use thumbnail image, if possible
        // ================================
        setImage: function(slide) {
            var self = this;
            var srcset = slide.opts.srcset || slide.opts.image.srcset;
            var found, temp, pxRatio, windowWidth;
            // If we have "srcset", then we need to find matching "src" value.
            // This is necessary, because when you set an src attribute, the browser will preload the image
            // before any javascript or even CSS is applied.
            if (srcset) {
                pxRatio = window.devicePixelRatio || 1;
                windowWidth = window.innerWidth * pxRatio;
                temp = srcset.split(',').map(function(el) {
                    var ret = {};
                    el.trim().split(/\s+/).forEach(function(el, i) {
                        var value = parseInt(el.substring(0, el.length - 1), 10);
                        if (i === 0) {
                            return (ret.url = el);
                        }
                        if (value) {
                            ret.value = value;
                            ret.postfix = el[el.length - 1];
                        }
                    });
                    return ret;
                });
                // Sort by value
                temp.sort(function(a, b) {
                    return a.value - b.value;
                });
                // Ok, now we have an array of all srcset values
                for (var j = 0; j < temp.length; j++) {
                    var el = temp[j];
                    if ((el.postfix === 'w' && el.value >= windowWidth) || (el.postfix === 'x' && el.value >= pxRatio)) {
                        found = el;
                        break;
                    }
                }
                // If not found, take the last one
                if (!found && temp.length) {
                    found = temp[temp.length - 1];
                }
                if (found) {
                    slide.src = found.url;
                    // If we have default width/height values, we can calculate height for matching source
                    if (slide.width && slide.height && found.postfix == 'w') {
                        slide.height = (slide.width / slide.height) * found.value;
                        slide.width = found.value;
                    }
                }
            }
            // This will be wrapper containing both ghost and actual image
            slide.$content = $('<div class="fxModalBox-image-wrap"></div>')
                .addClass('fxModalBox-is-hidden')
                .appendTo(slide.$slide);
            // If we have a thumbnail, we can display it while actual image is loading
            // Users will not stare at black screen and actual image will appear gradually
            if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && (slide.opts.thumb || slide.opts.$thumb)) {
                slide.width = slide.opts.width;
                slide.height = slide.opts.height;
                slide.$ghost = $('<img />')
                    .one('error', function() {
                        $(this).remove();
                        slide.$ghost = null;
                        self.setBigImage(slide);
                    })
                    .one('load', function() {
                        self.afterLoad(slide);
                        self.setBigImage(slide);
                    })
                    .addClass('fxModalBox-image')
                    .appendTo(slide.$content)
                    .attr('src', slide.opts.thumb || slide.opts.$thumb.attr('src'));
            } else {
                self.setBigImage(slide);
            }
        },
        // Create full-size image
        // ======================
        setBigImage: function(slide) {
            var self = this;
            var $img = $('<img />');
            slide.$image = $img
                .one('error', function() {
                    self.setError(slide);
                })
                .one('load', function() {
                    // Clear timeout that checks if loading icon needs to be displayed
                    clearTimeout(slide.timouts);
                    slide.timouts = null;
                    if (self.isClosing) {
                        return;
                    }
                    slide.width = slide.opts.width || this.naturalWidth;
                    slide.height = slide.opts.height || this.naturalHeight;
                    if (slide.opts.image.srcset) {
                        $img.attr('sizes', '100vw').attr('srcset', slide.opts.image.srcset);
                    }
                    self.hideLoading(slide);
                    if (slide.$ghost) {
                        slide.timouts = setTimeout(function() {
                            slide.timouts = null;
                            slide.$ghost.hide();
                        }, Math.min(300, Math.max(1000, slide.height / 1600)));
                    } else {
                        self.afterLoad(slide);
                    }
                })
                .addClass('fxModalBox-image')
                .attr('src', slide.src)
                .attr('alt', slide.opts.$orig.context.dataset.alt)
                .attr('title', slide.opts.$orig.context.title)
                .appendTo(slide.$content);

            if (($img[0].complete || $img[0].readyState == "complete") && $img[0].naturalWidth && $img[0].naturalHeight) {
                $img.trigger('load');
            } else if ($img[0].error) {
                $img.trigger('error');
            } else {
                slide.timouts = setTimeout(function() {
                    if (!$img[0].complete && !slide.hasError) {
                        self.showLoading(slide);
                    }
                }, 100);
            }
        },

        // Create iframe wrapper, iframe and bindings
        // ==========================================
        setIframe: function(slide) {
            var self = this,
                opts = slide.opts.iframe,
                $slide = slide.$slide,
                $iframe;
            slide.$content = $('<div class="fxModalBox-content' + (opts.preload ? ' fxModalBox-is-hidden' : '') + '"></div>')
                .css(opts.css)
                .appendTo($slide);
            $iframe = $(opts.tpl.replace(/\{rnd\}/g, new Date().getTime()))
                .attr(opts.attr)
                .appendTo(slide.$content);
            if (opts.preload) {
                self.showLoading(slide);
                // Unfortunately, it is not always possible to determine if iframe is successfully loaded
                // (due to browser security policy)
                $iframe.on('load.fxmb error.fxmb', function(e) {
                    this.isReady = 1;
                    slide.$slide.trigger('refresh');
                    self.afterLoad(slide);
                });
                // Recalculate iframe content size
                // ===============================
                $slide.on('refresh.fxmb', function() {
                    var $wrap = slide.$content,
                        frameWidth = opts.css.width,
                        frameHeight = opts.css.height,
                        scrollWidth,
                        $contents,
                        $body;
                    if ($iframe[0].isReady !== 1) {
                        return;
                    }
                    // Check if content is accessible,
                    // it will fail if frame is not with the same origin
                    try {
                        $contents = $iframe.contents();
                        $body = $contents.find('body');
                    } catch (ignore) {}
                    // Calculate dimensions for the wrapper
                    if ($body && $body.length) {
                        if (frameWidth === undefined) {
                            scrollWidth = $iframe[0].contentWindow.document.documentElement.scrollWidth;
                            frameWidth = Math.ceil($body.outerWidth(true) + ($wrap.width() - scrollWidth));
                            frameWidth += $wrap.outerWidth() - $wrap.innerWidth();
                        }
                        if (frameHeight === undefined) {
                            frameHeight = Math.ceil($body.outerHeight(true));
                            frameHeight += $wrap.outerHeight() - $wrap.innerHeight();
                        }
                        // Resize wrapper to fit iframe content
                        if (frameWidth) {
                            $wrap.width(frameWidth);
                        }
                        if (frameHeight) {
                            $wrap.height(frameHeight);
                        }
                    }
                    $wrap.removeClass('fxModalBox-is-hidden');
                });
            } else {
                this.afterLoad(slide);
            }
            $iframe.attr('src', slide.src);
            if (slide.opts.smallBtn === true) {
                slide.$content.prepend(self.translate(slide, slide.opts.btnTpl.smallBtn));
            }
            // Remove iframe if closing or changing gallery item
            $slide.one('onReset', function() {
                // This helps IE not to throw errors when closing
                try {
                    $(this).find('iframe').hide().attr('src', '//about:blank');

                } catch (ignore) {}
                $(this).empty();
                slide.isLoaded = false;
            });
        },
        // Wrap and append content to the slide
        // ======================================
        setContent: function(slide, content) {
            var self = this;
            if (self.isClosing) {
                return;
            }
            self.hideLoading(slide);
            slide.$slide.empty();
            if (isQuery(content) && content.parent().length) {
                // If content is a jQuery object, then it will be moved to the slide.
                // The placeholder is created so we will know where to put it back.
                // If user is navigating gallery fast, then the content might be already inside fxModalBox
                // ===================================================================
                // Make sure content is not already moved to fxModalBox
                content.parent('.fxModalBox-slide--inline').trigger('onReset');
                // Create temporary element marking original place of the content
                slide.$placeholder = $('<div></div>').hide().insertAfter(content);
                // Make sure content is visible
                content.css('display', 'inline-block');
            } else if (!slide.hasError) {
                // If content is just a plain text, try to convert it to html
                if ($.type(content) === 'string') {
                    content = $('<div>').append($.trim(content)).contents();
                    // If we have text node, then add wrapping element to make vertical alignment work
                    if (content[0].nodeType === 3) {
                        content = $('<div>').html(content);
                    }
                }
                // If "filter" option is provided, then filter content
                if (slide.opts.filter) {
                    content = $('<div>').html(content).find(slide.opts.filter);
                }
            }
            slide.$slide.one('onReset', function() {
                // Pause all html5 video/audio
                $(this).find('video,audio').trigger('pause');
                // Put content back
                if (slide.$placeholder) {
                    slide.$placeholder.after(content.hide()).remove();
                    slide.$placeholder = null;
                }
                // Remove custom close button
                if (slide.$smallBtn) {
                    slide.$smallBtn.remove();
                    slide.$smallBtn = null;
                }
                // Remove content and mark slide as not loaded
                if (!slide.hasError) {
                    $(this).empty();
                    slide.isLoaded = false;
                }
            });
            slide.$content = $(content).appendTo(slide.$slide);
            this.afterLoad(slide);
        },
        // Display error message
        // =====================
        setError: function(slide) {
            slide.hasError = true;
            slide.$slide.removeClass('fxModalBox-slide--' + slide.type);
            this.setContent(slide, this.translate(slide, slide.opts.errorTpl));
        },
        // Show loading icon inside the slide
        // ==================================
        showLoading: function(slide) {
            var self = this;
            slide = slide || self.current;
            if (slide && !slide.$spinner) {
                slide.$spinner = $(self.opts.spinnerTpl).appendTo(slide.$slide);
            }
        },
        // Remove loading icon from the slide
        // ==================================
        hideLoading: function(slide) {
            var self = this;
            slide = slide || self.current;
            if (slide && slide.$spinner) {
                slide.$spinner.remove();
                delete slide.$spinner;
            }
        },
        // Adjustments after slide content has been loaded
        // ===============================================
        afterLoad: function(slide) {
            var self = this;
            if (self.isClosing) {
                return;
            }
            slide.isLoading = false;
            slide.isLoaded = true;
            self.trigger('afterLoad', slide);
            self.hideLoading(slide);
            if (slide.opts.smallBtn && !slide.$smallBtn) {
                slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content.filter('div,form').first());
            }
            if (slide.opts.protect && slide.$content && !slide.hasError) {
                // Disable right click
                slide.$content.on('contextmenu.fxmb', function(e) {
                    if (e.button == 2) {
                        e.preventDefault();
                    }
                    return true;
                });
                // Add fake element on top of the image
                // This makes a bit harder for user to select image
                if (slide.type === 'image') {
                    $('<div class="fxModalBox-spaceball"></div>').appendTo(slide.$content);
                }
            }
            self.revealContent(slide);
        },
        // Make content visible
        // This method is called right after content has been loaded or
        // user navigates gallery and transition should start
        // ============================================================
        revealContent: function(slide) {
            var self = this;
            var $slide = slide.$slide;
            var effect, effectClassName, duration, opacity, end, start = false;
            effect = slide.opts[self.firstRun ? 'animationEffect' : 'transitionEffect'];
            duration = slide.opts[self.firstRun ? 'animationDuration' : 'transitionDuration'];
            duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);
            if (slide.isMoved || slide.pos !== self.currPos || !duration) {
                effect = false;
            }
            // Check if can zoom
            if (effect === 'zoom' && !(slide.pos === self.currPos && duration && slide.type === 'image' && !slide.hasError && (start = self.getThumbPos(slide)))) {
                effect = 'fade';
            }
            // Zoom animation
            // ==============
            if (effect === 'zoom') {
                end = self.getFitPos(slide);
                end.scaleX = end.width / start.width;
                end.scaleY = end.height / start.height;
                delete end.width;
                delete end.height;
                // Check if we need to animate opacity
                opacity = slide.opts.zoomOpacity;
                if (opacity == 'auto') {
                    opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1;
                }
                if (opacity) {
                    start.opacity = 0.1;
                    end.opacity = 1;
                }
                // Draw image at start position
                $.fxModalBox.setTranslate(slide.$content.removeClass('fxModalBox-is-hidden'), start);
                forceRedraw(slide.$content);
                // Start animation
                $.fxModalBox.animate(slide.$content, end, duration, function() {
                    self.complete();
                });
                return;
            }
            self.updateSlide(slide);
            // Simply show content
            // ===================
            if (!effect) {
                forceRedraw($slide);
                slide.$content.removeClass('fxModalBox-is-hidden');
                if (slide.pos === self.currPos) {
                    self.complete();
                }
                return;
            }
            $.fxModalBox.stop($slide);
            effectClassName = 'fxModalBox-animated fxModalBox-slide--' + (slide.pos >= self.prevPos ? 'next' : 'previous') + ' fxModalBox-fx-' + effect;
            $slide.removeAttr('style').removeClass('fxModalBox-slide--current fxModalBox-slide--next fxModalBox-slide--previous').addClass(effectClassName);
            slide.$content.removeClass('fxModalBox-is-hidden');
            //Force redraww for CSS3 transitions
            forceRedraw($slide);
            $.fxModalBox.animate($slide, 'fxModalBox-slide--current', duration, function(e) {
                $slide.removeClass(effectClassName).removeAttr('style');
                if (slide.pos === self.currPos) {
                    self.complete();
                }
            }, true);
        },
        // Check if we can and have to zoom from thumbnail
        //================================================
        getThumbPos: function(slide) {
            var self = this;
            var rez = false;
            // Check if element is inside the viewport by at least 1 pixel
            var isElementVisible = function($el) {
                var element = $el[0];
                var elementRect = element.getBoundingClientRect();
                var parentRects = [];
                var visibleInAllParents;
                while (element.parentElement !== null) {
                    if ($(element.parentElement).css('overflow') === 'hidden' || $(element.parentElement).css('overflow') === 'auto') {
                        parentRects.push(element.parentElement.getBoundingClientRect());
                    }
                    element = element.parentElement;
                }
                visibleInAllParents = parentRects.every(function(parentRect) {
                    var visiblePixelX = Math.min(elementRect.right, parentRect.right) - Math.max(elementRect.left, parentRect.left);
                    var visiblePixelY = Math.min(elementRect.bottom, parentRect.bottom) - Math.max(elementRect.top, parentRect.top);

                    return visiblePixelX > 0 && visiblePixelY > 0;
                });
                return visibleInAllParents &&
                    elementRect.bottom > 0 && elementRect.right > 0 &&
                    elementRect.left < $(window).width() && elementRect.top < $(window).height();
            };
            var $thumb = slide.opts.$thumb;
            var thumbPos = $thumb ? $thumb.offset() : 0;
            var slidePos;
            if (thumbPos && $thumb[0].ownerDocument === document && isElementVisible($thumb)) {
                slidePos = self.$refs.stage.offset();
                rez = {
                    top: thumbPos.top - slidePos.top + parseFloat($thumb.css("border-top-width") || 0),
                    left: thumbPos.left - slidePos.left + parseFloat($thumb.css("border-left-width") || 0),
                    width: $thumb.width(),
                    height: $thumb.height(),
                    scaleX: 1,
                    scaleY: 1
                };
            }
            return rez;
        },
        // Final adjustments after current gallery item is moved to position
        // and it`s content is loaded
        // ==================================================================

        complete: function() {
            var self = this,
                current = self.current,
                slides = {},
                promise;
            if (current.isMoved || !current.isLoaded || current.isComplete) {
                return;
            }
            current.isComplete = true;
            current.$slide.siblings().trigger('onReset');
            self.preload('inline');
            // Trigger any CSS3 transiton inside the slide
            forceRedraw(current.$slide);
            current.$slide.addClass('fxModalBox-slide--complete');
            // Remove unnecessary slides
            $.each(self.slides, function(key, slide) {
                if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {
                    slides[slide.pos] = slide;
                } else if (slide) {
                    $.fxModalBox.stop(slide.$slide);
                    slide.$slide.off().remove();
                }
            });
            self.slides = slides;
            self.updateCursor();
            self.trigger('afterShow');
            // Play first html5 video/audio
            current.$slide.find('video,audio').first().trigger('play');
            // Try to focus on the first focusable element
            if ($(document.activeElement).is('[disabled]') || (current.opts.autoFocus && !(current.type == 'image' || current.type === 'iframe'))) {
                self.focus();
            }
        },
        // Preload next and previous slides
        // ================================
        preload: function(type) {
            var self = this,
                next = self.slides[self.currPos + 1],
                prev = self.slides[self.currPos - 1];
            if (next && next.type === type) {
                self.loadSlide(next);
            }
            if (prev && prev.type === type) {
                self.loadSlide(prev);
            }
        },
        // Try to find and focus on the first focusable element
        // ====================================================
        focus: function() {
            var current = this.current;
            var $el;
            if (this.isClosing) {
                return;
            }
            if (current && current.isComplete) {
                // Look for first input with autofocus attribute
                $el = current.$slide.find('input[autofocus]:enabled:visible:first');
                if (!$el.length) {
                    $el = current.$slide.find('button,:input,[tabindex],a').filter(':enabled:visible:first');
                }
            }
            $el = $el && $el.length ? $el : this.$refs.container;
            $el.focus();
        },
        // Activates current instance - brings container to the front and enables keyboard,
        // notifies other instances about deactivating
        // =============================================================
        activate: function() {
            var self = this;
            // Deactivate all instances
            $('.fxModalBox-container').each(function() {
                var instance = $(this).data('FxModalBox');
                // Skip self and closing instances
                if (instance && instance.id !== self.id && !instance.isClosing) {
                    instance.trigger('onDeactivate');
                    instance.removeEvents();
                    instance.isVisible = false;
                }
            });
            self.isVisible = true;
            if (self.current || self.isIdle) {
                self.update();
                self.updateControls();
            }
            self.trigger('onActivate');
            self.addEvents();
        },
        // Start closing procedure
        // This will start "zoom-out" animation if needed and clean everything up afterwards
        // ==============================================================
        close: function(e, d) {
            var self = this;
            var current = self.current;
            var effect, duration;
            var $what, opacity, start, end;
            var done = function() {
                self.cleanUp(e);
            };
            if (self.isClosing) {
                return false;
            }
            self.isClosing = true;
            // If beforeClose callback prevents closing, make sure content is centered
            if (self.trigger('beforeClose', e) === false) {
                self.isClosing = false;
                requestAFrame(function() {
                    self.update();
                });
                return false;
            }
            // Remove all events
            // If there are multiple instances, they will be set again by "activate" method
            self.removeEvents();
            if (current.timouts) {
                clearTimeout(current.timouts);
            }
            $what = current.$content;
            effect = current.opts.animationEffect;
            duration = $.isNumeric(d) ? d : (effect ? current.opts.animationDuration : 0);
            // Remove other slides
            current.$slide.off(transitionEnd).removeClass('fxModalBox-slide--complete fxModalBox-slide--next fxModalBox-slide--previous fxModalBox-animated');
            current.$slide.siblings().trigger('onReset').remove();
            // Trigger animations
            if (duration) {
                self.$refs.container.removeClass('fxModalBox-is-open').addClass('fxModalBox-is-closing');
            }
            // Clean up
            self.hideLoading(current);
            self.hideControls();
            self.updateCursor();
            // Check if possible to zoom-out
            if (effect === 'zoom' && !(e !== true && $what && duration && current.type === 'image' && !current.hasError && (end = self.getThumbPos(current)))) {
                effect = 'fade';
            }
            if (effect === 'zoom') {
                $.fxModalBox.stop($what);
                start = $.fxModalBox.getTranslate($what);
                start.width = start.width * start.scaleX;
                start.height = start.height * start.scaleY;
                // Check if we need to animate opacity
                opacity = current.opts.zoomOpacity;
                if (opacity == 'auto') {
                    opacity = Math.abs(current.width / current.height - end.width / end.height) > 0.1;
                }
                if (opacity) {
                    end.opacity = 0;
                }
                start.scaleX = start.width / end.width;
                start.scaleY = start.height / end.height;
                start.width = end.width;
                start.height = end.height;
                $.fxModalBox.setTranslate(current.$content, start);
                forceRedraw(current.$content);
                $.fxModalBox.animate(current.$content, end, duration, done);
                return true;
            }
            if (effect && duration) {
                // If skip animation
                if (e === true) {
                    setTimeout(done, duration);
                } else {
                    $.fxModalBox.animate(current.$slide.removeClass('fxModalBox-slide--current'), 'fxModalBox-animated fxModalBox-slide--previous fxModalBox-fx-' + effect, duration, done);
                }
            } else {
                done();
            }
            return true;
        },
        // Final adjustments after removing the instance
        // =============================================
        cleanUp: function(e) {
            var self = this,
                $body = $('body'),
                instance,
                offset;
            self.current.$slide.trigger('onReset');
            self.$refs.container.empty().remove();
            self.trigger('afterClose', e);
            // Place back focus
            if (self.$lastFocus && !!self.current.opts.backFocus) {
                self.$lastFocus.focus();
            }
            self.current = null;
            // Check if there are other instances
            instance = $.fxModalBox.getInstance();
            if (instance) {
                instance.activate();
            } else {
                $W.scrollTop(self.scrollTop).scrollLeft(self.scrollLeft);
                $body.removeClass('fxModalBox-active compensate-for-scrollbar');
                if ($body.hasClass('fxModalBox-iosfix')) {
                    offset = parseInt(document.body.style.top, 10);
                    $body.removeClass('fxModalBox-iosfix').css('top', '').scrollTop(offset * -1);
                }
                $('#fxModalBox-style-noscroll').remove();
            }
        },
        // Call callback and trigger an event
        // ==================================
        trigger: function(name, slide) {
            var args = Array.prototype.slice.call(arguments, 1),
                self = this,
                obj = slide && slide.opts ? slide : self.current,
                rez;
            if (obj) {
                args.unshift(obj);
            } else {
                obj = self;
            }
            args.unshift(self);
            if ($.isFunction(obj.opts[name])) {
                rez = obj.opts[name].apply(obj, args);
            }
            if (rez === false) {
                return rez;
            }
            if (name === 'afterClose' || !self.$refs) {
                $D.trigger(name + '.fxmb', args);
            } else {
                self.$refs.container.trigger(name + '.fxmb', args);
            }
        },
        // Update infobar values, navigation button states and reveal caption
        // ==================================================================
        updateControls: function(force) {
            var self = this;
            var current = self.current,
                index = current.index,
                caption = current.opts.caption,
                $container = self.$refs.container,
                $caption = self.$refs.caption;
            // Recalculate content dimensions
            current.$slide.trigger('refresh');
            self.$caption = caption && caption.length ? $caption.html(caption) : null;
            if (!self.isHiddenControls && !self.isIdle) {
                self.showControls();
            }
            // Update info and navigation elements
            $container.find('[data-fxModalBox-count]').html(self.group.length);
            $container.find('[data-fxModalBox-index]').html(index + 1);
            $container.find('[data-fxModalBox-prev]').prop('disabled', (!current.opts.loop && index <= 0));
            $container.find('[data-fxModalBox-next]').prop('disabled', (!current.opts.loop && index >= self.group.length - 1));
            if (current.type === 'image') {
                // Update download button source
                $container.find('[data-fxModalBox-download]').attr('href', current.opts.image.src || current.src).attr('data-analytics', current.opts.image.src || current.src).show();
            } else {
                $container.find('[data-fxModalBox-download],[data-fxModalBox-zoom]').hide();
            }
        },
        // Hide toolbar and caption
        // ========================
        hideControls: function() {
            this.isHiddenControls = true;
            this.$refs.container.removeClass('fxModalBox-show-infobar fxModalBox-show-toolbar fxModalBox-show-caption fxModalBox-show-nav');
        },
        showControls: function() {
            var self = this;
            var opts = self.current ? self.current.opts : self.opts;
            var $container = self.$refs.container;
            self.isHiddenControls = false;
            self.idleSecondsCounter = 0;
            $container
                .toggleClass('fxModalBox-show-toolbar', !!(opts.toolbar && opts.buttons))
                .toggleClass('fxModalBox-show-infobar', !!(opts.infobar && self.group.length > 1))
                .toggleClass('fxModalBox-show-nav', !!(opts.arrows && self.group.length > 1))
                .toggleClass('fxModalBox-is-modal', !!opts.modal);
            if (self.$caption) {
                $container.addClass('fxModalBox-show-caption ');
            } else {
                $container.removeClass('fxModalBox-show-caption');
            }
        },
        // Toggle toolbar and caption
        // ==========================
        toggleControls: function() {
            if (this.isHiddenControls) {
                this.showControls();
            } else {
                this.hideControls();
            }
        },
    });
    $.fxModalBox = {
        version: "1.0.0",
        defaults: defaults,
        // Get current instance and execute a command.
        //
        // Examples of usage:
        //
        //   $instance = $.fxModalBox.getInstance();
        //   $.fxModalBox.getInstance().jumpTo( 1 );
        //   $.fxModalBox.getInstance( 'jumpTo', 1 );
        //   $.fxModalBox.getInstance( function() {
        //       console.info( this.currIndex );
        //   });
        // ======================================================
        getInstance: function(command) {
            var instance = $('.fxModalBox-container:not(".fxModalBox-is-closing"):last').data('FxModalBox');
            var args = Array.prototype.slice.call(arguments, 1);
            if (instance instanceof FxModalBox) {
                if ($.type(command) === 'string') {
                    instance[command].apply(instance, args);
                } else if ($.type(command) === 'function') {
                    command.apply(instance, args);
                }
                return instance;
            }
            return false;
        },
        // Create new instance
        // ===================
        open: function(items, opts, index) {
            return new FxModalBox(items, opts, index);
        },
        // Close current or all instances
        // ==============================
        close: function(all) {
            var instance = this.getInstance();
            if (instance) {
                instance.close();
                // Try to find and close next instance
                if (all === true) {
                    this.close();
                }
            }
        },
        // Close instances and unbind all events
        // ==============================
        destroy: function() {
            this.close(true);
            $D.off('click.fxmb-start');
        },
        // Try to detect mobile devices
        // ============================
        isMobile: document.createTouch !== undefined && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
        // Detect if 'translate3d' support is available
        // ============================================
        use3d: (function() {
            var div = document.createElement('div');
            return window.getComputedStyle && window.getComputedStyle(div).getPropertyValue('transform') && !(document.documentMode && document.documentMode < 11);
        }()),
        // Helper function to get current visual state of an element
        // returns array[ top, left, horizontal-scale, vertical-scale, opacity ]
        // =====================================================================
        getTranslate: function($el) {
            var matrix;
            if (!$el || !$el.length) {
                return false;
            }
            matrix = $el.eq(0).css('transform');
            if (matrix && matrix.indexOf('matrix') !== -1) {
                matrix = matrix.split('(')[1];
                matrix = matrix.split(')')[0];
                matrix = matrix.split(',');
            } else {
                matrix = [];
            }
            if (matrix.length) {
                // If IE
                if (matrix.length > 10) {
                    matrix = [matrix[13], matrix[12], matrix[0], matrix[5]];
                } else {
                    matrix = [matrix[5], matrix[4], matrix[0], matrix[3]];
                }
                matrix = matrix.map(parseFloat);
            } else {
                matrix = [0, 0, 1, 1];
                var transRegex = /\.*translate\((.*)px,(.*)px\)/i;
                var transRez = transRegex.exec($el.eq(0).attr('style'));
                if (transRez) {
                    matrix[0] = parseFloat(transRez[2]);
                    matrix[1] = parseFloat(transRez[1]);
                }
            }
            return {
                top: matrix[0],
                left: matrix[1],
                scaleX: matrix[2],
                scaleY: matrix[3],
                opacity: parseFloat($el.css('opacity')),
                width: $el.width(),
                height: $el.height()
            };
        },
        // Shortcut for setting "translate3d" properties for element
        // Can set be used to set opacity, too
        // ========================================================
        setTranslate: function($el, props) {
            var str = '';
            var css = {};
            if (!$el || !props) {
                return;
            }
            if (props.left !== undefined || props.top !== undefined) {
                str = (props.left === undefined ? $el.position().left : props.left) + 'px, ' + (props.top === undefined ? $el.position().top : props.top) + 'px';
                if (this.use3d) {
                    str = 'translate3d(' + str + ', 0px)';
                } else {
                    str = 'translate(' + str + ')';
                }
            }
            if (props.scaleX !== undefined && props.scaleY !== undefined) {
                str = (str.length ? str + ' ' : '') + 'scale(' + props.scaleX + ', ' + props.scaleY + ')';
            }
            if (str.length) {
                css.transform = str;
            }
            if (props.opacity !== undefined) {
                css.opacity = props.opacity;
            }
            if (props.width !== undefined) {
                css.width = props.width;
            }
            if (props.height !== undefined) {
                css.height = props.height;
            }
            return $el.css(css);
        },
        // Simple CSS transition handler
        // =============================
        animate: function($el, to, duration, callback, leaveAnimationName) {
            if ($.isFunction(duration)) {
                callback = duration;
                duration = null;
            }
            if (!$.isPlainObject(to)) {
                $el.removeAttr('style');
            }
            $el.on(transitionEnd, function(e) {
                // Skip events from child elements and z-index change
                if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == 'z-index')) {
                    return;
                }
                $.fxModalBox.stop($el);
                if ($.isPlainObject(to)) {
                    if (to.scaleX !== undefined && to.scaleY !== undefined) {
                        $el.css('transition-duration', '');
                        to.width = Math.round($el.width() * to.scaleX);
                        to.height = Math.round($el.height() * to.scaleY);
                        to.scaleX = 1;
                        to.scaleY = 1;
                        $.fxModalBox.setTranslate($el, to);
                    }
                    if (leaveAnimationName === false) {
                        $el.removeAttr('style');
                    }
                } else if (leaveAnimationName !== true) {
                    $el.removeClass(to);
                }
                if ($.isFunction(callback)) {
                    callback(e);
                }
            });
            if ($.isNumeric(duration)) {
                $el.css('transition-duration', duration + 'ms');
            }
            if ($.isPlainObject(to)) {
                $.fxModalBox.setTranslate($el, to);
            } else {
                $el.addClass(to);
            }
            if (to.scaleX && $el.hasClass('fxModalBox-image-wrap')) {
                $el.parent().addClass('fxModalBox-is-scaling');
            }
            // Make sure that `transitionend` callback gets fired
            $el.data("timer", setTimeout(function() {
                $el.trigger('transitionend');
            }, duration + 16));
        },
        stop: function($el) {
            clearTimeout($el.data("timer"));
            $el.off('transitionend').css('transition-duration', '');
            if ($el.hasClass('fxModalBox-image-wrap')) {
                $el.parent().removeClass('fxModalBox-is-scaling');
            }
        }
    };
    // Default click handler for "fxModalBoxed" links
    // ============================================
    function _run(e) {
        var $target = $(e.currentTarget),
            opts = e.data ? e.data.options : {},
            value = $target.attr('data-fxModalBox') || '',
            index = 0,
            items = [];
        // Avoid opening multiple times
        if (e.isDefaultPrevented()) {
            return;
        }
        e.preventDefault();
        // Get all related items and find index for clicked one
        if (value) {
            items = opts.selector ? $(opts.selector) : (e.data ? e.data.items : []);
            items = items.length ? items.filter('[data-fxModalBox="' + value + '"]') : $('[data-fxModalBox="' + value + '"]');
            index = items.index($target);
            // Sometimes current item can not be found
            // (for example, when slider clones items)
            if (index < 0) {
                index = 0;
            }
        } else {
            items = [$target];
        }
        $.fxModalBox.open(items, opts, index);
    }
    // Create a jQuery plugin
    // ======================

    $.fn.fxModalBox = function(options) {
        var selector;
        options = options || {};
        selector = options.selector || false;
        if (selector) {
            $('body').off('click.fxmb-start', selector).on('click.fxmb-start', selector, {
                options: options
            }, _run);
        } else {
            this.off('click.fxmb-start').on('click.fxmb-start', {
                items: this,
                options: options
            }, _run);
        }
        return this;
    };
    // Self initializing plugin
    // ========================
    $D.on('click.fxmb-start', '[data-fxModalBox]', _run);
}(window, document, window.jQuery || jQuery));
//==========================================================================
//
//Media
//Adds additional media type support
//
//==========================================================================
;
(function($) {
    'use strict';
    // Formats matching url to final form
    var format = function(url, rez, params) {
        if (!url) {
            return;
        }
        params = params || '';
        if ($.type(params) === "object") {
            params = $.param(params, true);
        }
        $.each(rez, function(key, value) {
            url = url.replace('$' + key, value || '');
        });
        if (params.length) {
            url += (url.indexOf('?') > 0 ? '&' : '?') + params;
        }
        return url;
    };
    // Object containing properties for each media type
    var defaults = {
        youtube: {
            matcher: /(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,
            params: {
                autoplay: 1,
                autohide: 1,
                fs: 1,
                rel: 0,
                hd: 1,
                wmode: 'transparent',
                enablejsapi: 1,
                html5: 1
            },
            paramPlace: 8,
            type: 'iframe',
            url: '//www.youtube.com/embed/$4',
            thumb: '//img.youtube.com/vi/$4/hqdefault.jpg'
        },
        vimeo: {
            matcher: /^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,
            params: {
                autoplay: 1,
                hd: 1,
                show_title: 1,
                show_byline: 1,
                show_portrait: 0,
                fullscreen: 1,
                api: 1
            },
            paramPlace: 3,
            type: 'iframe',
            url: '//player.vimeo.com/video/$2'
        },
        metacafe: {
            matcher: /metacafe.com\/watch\/(\d+)\/(.*)?/,
            type: 'iframe',
            url: '//www.metacafe.com/embed/$1/?ap=1'
        },
        dailymotion: {
            matcher: /dailymotion.com\/video\/(.*)\/?(.*)/,
            params: {
                additionalInfos: 0,
                autoStart: 1
            },
            type: 'iframe',
            url: '//www.dailymotion.com/embed/video/$1'
        },
        vine: {
            matcher: /vine.co\/v\/([a-zA-Z0-9\?\=\-]+)/,
            type: 'iframe',
            url: '//vine.co/v/$1/embed/simple'
        },
        instagram: {
            matcher: /(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,
            type: 'image',
            url: '//$1/p/$2/media/?size=l'
        },
        // Examples:
        // http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16
        // https://www.google.com/maps/@37.7852006,-122.4146355,14.65z
        // https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572
        gmap_place: {
            matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,
            type: 'iframe',
            url: function(rez) {
                return '//maps.google.' + rez[2] + '/?ll=' + (rez[9] ? rez[9] + '&z=' + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\//, "&") : '') : rez[12]) + '&output=' + (rez[12] && rez[12].indexOf('layer=c') > 0 ? 'svembed' : 'embed');
            }
        },
        // Examples:
        // https://www.google.com/maps/search/Empire+State+Building/
        // https://www.google.com/maps/search/?api=1&query=centurylink+field
        // https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393
        gmap_search: {
            matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,
            type: 'iframe',
            url: function(rez) {
                return '//maps.google.' + rez[2] + '/maps?q=' + rez[5].replace('query=', 'q=').replace('api=1', '') + '&output=embed';
            }
        }
    };
    $(document).on('objectNeedsType.fxmb', function(e, instance, item) {
        var url = item.src || '',
            type = false,
            media,
            thumb,
            rez,
            params,
            urlParams,
            paramObj,
            provider;
        media = $.extend(true, {}, defaults, item.opts.media);
        // Look for any matching media type
        $.each(media, function(providerName, providerOpts) {
            rez = url.match(providerOpts.matcher);
            if (!rez) {
                return;
            }
            type = providerOpts.type;
            paramObj = {};
            if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {
                urlParams = rez[providerOpts.paramPlace];
                if (urlParams[0] == '?') {
                    urlParams = urlParams.substring(1);
                }
                urlParams = urlParams.split('&');
                for (var m = 0; m < urlParams.length; ++m) {
                    var p = urlParams[m].split('=', 2);
                    if (p.length == 2) {
                        paramObj[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
                    }
                }
            }
            params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);
            url = $.type(providerOpts.url) === "function" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);
            thumb = $.type(providerOpts.thumb) === "function" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);
            if (providerName === 'vimeo') {
                url = url.replace('&%23', '#');
            }
            return false;
        });
        // If it is found, then change content type and update the url
        if (type) {
            item.src = url;
            item.type = type;
            if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {
                item.opts.thumb = thumb;
            }
            if (type === 'iframe') {
                $.extend(true, item.opts, {
                    iframe: {
                        preload: false,
                        attr: {
                            scrolling: "no"
                        }
                    }
                });
                item.contentProvider = provider;
                item.opts.slideClass += ' fxModalBox-slide--' + (provider == 'gmap_place' || provider == 'gmap_search' ? 'map' : 'video');
            }
        } else if (url) {
            item.type = item.opts.defaultType;
        }
    });
}(window.jQuery || jQuery));

//==========================================================================
//
//Guestures
//Adds touch guestures, handles click and tap events
//
//==========================================================================
;
(function(window, document, $) {
    'use strict';
    var requestAFrame = (function() {
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            // if all else fails, use setTimeout
            function(callback) {
                return window.setTimeout(callback, 1000 / 60);
            };
    })();
    var cancelAFrame = (function() {
        return window.cancelAnimationFrame ||
            window.webkitCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            window.oCancelAnimationFrame ||
            function(id) {
                window.clearTimeout(id);
            };
    })();
    var pointers = function(e) {
        var result = [];
        e = e.originalEvent || e || window.e;
        e = e.touches && e.touches.length ? e.touches : (e.changedTouches && e.changedTouches.length ? e.changedTouches : [e]);
        for (var key in e) {
            if (e[key].pageX) {
                result.push({
                    x: e[key].pageX,
                    y: e[key].pageY
                });
            } else if (e[key].clientX) {
                result.push({
                    x: e[key].clientX,
                    y: e[key].clientY
                });
            }
        }
        return result;
    };
    var distance = function(point2, point1, what) {
        if (!point1 || !point2) {
            return 0;
        }
        if (what === 'x') {
            return point2.x - point1.x;
        } else if (what === 'y') {
            return point2.y - point1.y;
        }
        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
    };
    var isClickable = function($el) {
        if ($el.is('a,area,button,[role="button"],input,label,select,summary,textarea') || $.isFunction($el.get(0).onclick) || $el.data('selectable')) {
            return true;
        }
        // Check for attributes like data-fxModalBox-next or data-fxModalBox-close
        for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {
            if (atts[i].nodeName.substr(0, 14) === 'data-fxModalBox-') {
                return true;
            }
        }
        return false;
    };
    var hasScrollbars = function(el) {
        var overflowY = window.getComputedStyle(el)['overflow-y'];
        var overflowX = window.getComputedStyle(el)['overflow-x'];
        var vertical = (overflowY === 'scroll' || overflowY === 'auto') && el.scrollHeight > el.clientHeight;
        var horizontal = (overflowX === 'scroll' || overflowX === 'auto') && el.scrollWidth > el.clientWidth;
        return vertical || horizontal;
    };
    var isScrollable = function($el) {
        var rez = false;
        while (true) {
            rez = hasScrollbars($el.get(0));
            if (rez) {
                break;
            }
            $el = $el.parent();
            if (!$el.length || $el.hasClass('fxModalBox-stage') || $el.is('body')) {
                break;
            }
        }
        return rez;
    };
    var Guestures = function(instance) {
        var self = this;
        self.instance = instance;
        self.$bg = instance.$refs.bg;
        self.$stage = instance.$refs.stage;
        self.$container = instance.$refs.container;
        self.destroy();
        self.$container.on('touchstart.fxmb.touch mousedown.fxmb.touch', $.proxy(self, 'ontouchstart'));
    };
    Guestures.prototype.destroy = function() {
        this.$container.off('.fxmb.touch');
    };
    Guestures.prototype.ontouchstart = function(e) {
        var self = this;
        var $target = $(e.target);
        var instance = self.instance;
        var current = instance.current;
        var $content = current.$content;
        var isTouchDevice = (e.type == 'touchstart');
        // Do not respond to both (touch and mouse) events
        if (isTouchDevice) {
            self.$container.off('mousedown.fxmb.touch');
        }
        // Ignore right click
        if (e.originalEvent && e.originalEvent.button == 2) {
            return;
        }
        // Ignore taping on links, buttons, input elements
        if (!$target.length || isClickable($target) || isClickable($target.parent())) {
            return;
        }
        // Ignore clicks on the scrollbar
        if (!$target.is('img') && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {
            return;
        }
        // Ignore clicks while zooming or closing
        if (!current || self.instance.isAnimating || self.instance.isClosing) {
            e.stopPropagation();
            e.preventDefault();
            return;
        }
        self.realPoints = self.startPoints = pointers(e);

        if (!self.startPoints) {
            return;
        }
        e.stopPropagation();
        self.startEvent = e;
        self.canTap = true;
        self.$target = $target;
        self.$content = $content;
        self.opts = current.opts.touch;
        self.isPanning = false;
        self.isSwiping = false;
        self.isZooming = false;
        self.isScrolling = false;
        self.sliderStartPos = self.sliderLastPos || {
            top: 0,
            left: 0
        };
        self.contentStartPos = $.fxModalBox.getTranslate(self.$content);
        self.contentLastPos = null;
        self.startTime = new Date().getTime();
        self.distanceX = self.distanceY = self.distance = 0;
        self.canvasWidth = Math.round(current.$slide[0].clientWidth);
        self.canvasHeight = Math.round(current.$slide[0].clientHeight);
        $(document)
            .off('.fxmb.touch')
            .on(isTouchDevice ? 'touchend.fxmb.touch touchcancel.fxmb.touch' : 'mouseup.fxmb.touch mouseleave.fxmb.touch', $.proxy(self, "ontouchend"))
            .on(isTouchDevice ? 'touchmove.fxmb.touch' : 'mousemove.fxmb.touch', $.proxy(self, "ontouchmove"));
        if ($.fxModalBox.isMobile) {
            document.addEventListener('scroll', self.onscroll, true);
        }
        if (!(self.opts || instance.canPan()) || !($target.is(self.$stage) || self.$stage.find($target).length)) {
            // Prevent image ghosting while dragging
            if ($target.is('img')) {
                e.preventDefault();
            }
            return;
        }
        if (!($.fxModalBox.isMobile && (isScrollable($target) || isScrollable($target.parent())))) {
            e.preventDefault();
        }
        if (self.startPoints.length === 1) {
            if (current.type === 'image' && (self.contentStartPos.width > self.canvasWidth + 1 || self.contentStartPos.height > self.canvasHeight + 1)) {
                $.fxModalBox.stop(self.$content);
                self.$content.css('transition-duration', '');

                self.isPanning = true;

            } else {
                self.isSwiping = true;
            }

            self.$container.addClass('fxModalBox-controls--isGrabbing');
        }
        if (self.startPoints.length === 2 && !instance.isAnimating && !current.hasError && current.type === 'image' && (current.isLoaded || current.$ghost)) {
            self.canTap = false;
            self.isSwiping = false;
            self.isPanning = false;
            self.isZooming = true;
            $.fxModalBox.stop(self.$content);
            self.$content.css('transition-duration', '');
            self.centerPointStartX = ((self.startPoints[0].x + self.startPoints[1].x) * 0.5) - $(window).scrollLeft();
            self.centerPointStartY = ((self.startPoints[0].y + self.startPoints[1].y) * 0.5) - $(window).scrollTop();
            self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width;
            self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height;
            self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);
        }

    };
    Guestures.prototype.onscroll = function(e) {
        self.isScrolling = true;
    };
    Guestures.prototype.ontouchmove = function(e) {
        var self = this,
            $target = $(e.target);
        if (self.isScrolling || !($target.is(self.$stage) || self.$stage.find($target).length)) {
            self.canTap = false;
            return;
        }
        self.newPoints = pointers(e);
        if (!(self.opts || self.instance.canPan()) || !self.newPoints || !self.newPoints.length) {
            return;
        }
        if (!(self.isSwiping && self.isSwiping === true)) {
            e.preventDefault();
        }
        self.distanceX = distance(self.newPoints[0], self.startPoints[0], 'x');
        self.distanceY = distance(self.newPoints[0], self.startPoints[0], 'y');
        self.distance = distance(self.newPoints[0], self.startPoints[0])
        // Skip false ontouchmove events (Chrome)
        if (self.distance > 0) {
            if (self.isSwiping) {
                self.onSwipe(e);
            } else if (self.isPanning) {
                self.onPan();
            } else if (self.isZooming) {
                self.onZoom();
            }
        }
    };
    Guestures.prototype.onSwipe = function(e) {
        var self = this,
            swiping = self.isSwiping,
            left = self.sliderStartPos.left || 0,
            angle;
        // If direction is not yet determined
        if (swiping === true) {
            // We need at least 10px distance to correctly calculate an angle
            if (Math.abs(self.distance) > 10) {
                self.canTap = false;
                if (self.instance.group.length < 2 && self.opts.vertical) {
                    self.isSwiping = 'y';
                } else if (self.instance.isDragging || self.opts.vertical === false || (self.opts.vertical === 'auto' && $(window).width() > 800)) {
                    self.isSwiping = 'x';
                } else {
                    angle = Math.abs(Math.atan2(self.distanceY, self.distanceX) * 180 / Math.PI);
                    self.isSwiping = (angle > 45 && angle < 135) ? 'y' : 'x';
                }
                self.canTap = false;
                if (self.isSwiping === 'y' && $.fxModalBox.isMobile && (isScrollable(self.$target) || isScrollable(self.$target.parent()))) {
                    self.isScrolling = true;
                    return;
                }
                self.instance.isDragging = self.isSwiping;
                // Reset points to avoid jumping, because we dropped first swipes to calculate the angle
                self.startPoints = self.newPoints;
                $.each(self.instance.slides, function(index, slide) {
                    $.fxModalBox.stop(slide.$slide);
                    slide.$slide.css('transition-duration', '');
                    slide.inTransition = false;
                    if (slide.pos === self.instance.current.pos) {
                        self.sliderStartPos.left = $.fxModalBox.getTranslate(slide.$slide).left;
                    }
                });
                // Stop slideshow
                if (self.instance.SlideShow && self.instance.SlideShow.isActive) {
                    self.instance.SlideShow.stop();
                }
            }
            return;
        }
        // Sticky edges
        if (swiping == 'x') {
            if (self.distanceX > 0 && (self.instance.group.length < 2 || (self.instance.current.index === 0 && !self.instance.current.opts.loop))) {
                left = left + Math.pow(self.distanceX, 0.8);
            } else if (self.distanceX < 0 && (self.instance.group.length < 2 || (self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop))) {
                left = left - Math.pow(-self.distanceX, 0.8);
            } else {
                left = left + self.distanceX;
            }
        }
        self.sliderLastPos = {
            top: swiping == 'x' ? 0 : self.sliderStartPos.top + self.distanceY,
            left: left
        };
        if (self.requestId) {
            cancelAFrame(self.requestId);
            self.requestId = null;
        }
        self.requestId = requestAFrame(function() {
            if (self.sliderLastPos) {
                $.each(self.instance.slides, function(index, slide) {
                    var pos = slide.pos - self.instance.currPos;
                    $.fxModalBox.setTranslate(slide.$slide, {
                        top: self.sliderLastPos.top,
                        left: self.sliderLastPos.left + (pos * self.canvasWidth) + (pos * slide.opts.gutter)
                    });
                });
                self.$container.addClass('fxModalBox-is-sliding');
            }
        });
    };
    Guestures.prototype.onPan = function() {
        var self = this;
        // Sometimes, when tapping causally, image can move a bit and that breaks double tapping
        if (distance(self.newPoints[0], self.realPoints[0]) < ($.fxModalBox.isMobile ? 10 : 5)) {
            self.startPoints = self.newPoints;
            return;
        }
        self.canTap = false;
        self.contentLastPos = self.limitMovement();
        if (self.requestId) {
            cancelAFrame(self.requestId);
            self.requestId = null;
        }
        self.requestId = requestAFrame(function() {
            $.fxModalBox.setTranslate(self.$content, self.contentLastPos);
        });
    };
    // Make panning sticky to the edges
    Guestures.prototype.limitMovement = function() {
        var self = this;
        var canvasWidth = self.canvasWidth;
        var canvasHeight = self.canvasHeight;
        var distanceX = self.distanceX;
        var distanceY = self.distanceY;
        var contentStartPos = self.contentStartPos;
        var currentOffsetX = contentStartPos.left;
        var currentOffsetY = contentStartPos.top;
        var currentWidth = contentStartPos.width;
        var currentHeight = contentStartPos.height;
        var minTranslateX, minTranslateY,
            maxTranslateX, maxTranslateY,
            newOffsetX, newOffsetY;
        if (currentWidth > canvasWidth) {
            newOffsetX = currentOffsetX + distanceX;
        } else {
            newOffsetX = currentOffsetX;
        }
        newOffsetY = currentOffsetY + distanceY;
        // Slow down proportionally to traveled distance
        minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5);
        minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5);
        maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5);
        maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5);
        if (currentWidth > canvasWidth) {
            //   ->
            if (distanceX > 0 && newOffsetX > minTranslateX) {
                newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;
            }
            //    <-
            if (distanceX < 0 && newOffsetX < maxTranslateX) {
                newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;
            }
        }
        if (currentHeight > canvasHeight) {
            //   \/
            if (distanceY > 0 && newOffsetY > minTranslateY) {
                newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;
            }
            //   /\
            if (distanceY < 0 && newOffsetY < maxTranslateY) {
                newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;
            }
        }
        return {
            top: newOffsetY,
            left: newOffsetX,
            scaleX: contentStartPos.scaleX,
            scaleY: contentStartPos.scaleY
        };
    };
    Guestures.prototype.limitPosition = function(newOffsetX, newOffsetY, newWidth, newHeight) {
        var self = this;
        var canvasWidth = self.canvasWidth;
        var canvasHeight = self.canvasHeight;
        if (newWidth > canvasWidth) {
            newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;
            newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;
        } else {
            // Center horizontally
            newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2);
        }
        if (newHeight > canvasHeight) {
            newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;
            newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;
        } else {
            // Center vertically
            newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2);
        }
        return {
            top: newOffsetY,
            left: newOffsetX
        };
    };
    Guestures.prototype.onZoom = function() {
        var self = this;
        // Calculate current distance between points to get pinch ratio and new width and height
        var currentWidth = self.contentStartPos.width;
        var currentHeight = self.contentStartPos.height;
        var currentOffsetX = self.contentStartPos.left;
        var currentOffsetY = self.contentStartPos.top;
        var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);
        var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers;
        var newWidth = Math.floor(currentWidth * pinchRatio);
        var newHeight = Math.floor(currentHeight * pinchRatio);
        // This is the translation due to pinch-zooming
        var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;
        var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY;
        //Point between the two touches
        var centerPointEndX = ((self.newPoints[0].x + self.newPoints[1].x) / 2) - $(window).scrollLeft();
        var centerPointEndY = ((self.newPoints[0].y + self.newPoints[1].y) / 2) - $(window).scrollTop();
        // And this is the translation due to translation of the centerpoint
        // between the two fingers
        var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;
        var translateFromTranslatingY = centerPointEndY - self.centerPointStartY;
        // The new offset is the old/current one plus the total translation
        var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);
        var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);
        var newPos = {
            top: newOffsetY,
            left: newOffsetX,
            scaleX: self.contentStartPos.scaleX * pinchRatio,
            scaleY: self.contentStartPos.scaleY * pinchRatio
        };
        self.canTap = false;
        self.newWidth = newWidth;
        self.newHeight = newHeight;
        self.contentLastPos = newPos;
        if (self.requestId) {
            cancelAFrame(self.requestId);
            self.requestId = null;
        }
        self.requestId = requestAFrame(function() {
            $.fxModalBox.setTranslate(self.$content, self.contentLastPos);
        });
    };
    Guestures.prototype.ontouchend = function(e) {
        var self = this;
        var dMs = Math.max((new Date().getTime()) - self.startTime, 1);
        var swiping = self.isSwiping;
        var panning = self.isPanning;
        var zooming = self.isZooming;
        var scrolling = self.isScrolling;
        self.endPoints = pointers(e);
        self.$container.removeClass('fxModalBox-controls--isGrabbing');
        $(document).off('.fxmb.touch');
        document.removeEventListener('scroll', self.onscroll, true);
        if (self.requestId) {
            cancelAFrame(self.requestId);
            self.requestId = null;
        }
        self.isSwiping = false;
        self.isPanning = false;
        self.isZooming = false;
        self.isScrolling = false;
        self.instance.isDragging = false;
        if (self.canTap) {
            return self.onTap(e);
        }
        self.speed = 366;
        // Speed in px/ms
        self.velocityX = self.distanceX / dMs * 0.5;
        self.velocityY = self.distanceY / dMs * 0.5;
        self.speedX = Math.max(self.speed * 0.5, Math.min(self.speed * 1.5, (1 / Math.abs(self.velocityX)) * self.speed));
        if (panning) {
            self.endPanning();
        } else if (zooming) {
            self.endZooming();
        } else {
            self.endSwiping(swiping, scrolling);
        }
        return;
    };
    Guestures.prototype.endSwiping = function(swiping, scrolling) {
        var self = this,
            ret = false,
            len = self.instance.group.length;
        self.sliderLastPos = null;
        // Close if swiped vertically / navigate if horizontally
        if (swiping == 'y' && !scrolling && Math.abs(self.distanceY) > 50) {
            // Continue vertical movement
            $.fxModalBox.animate(self.instance.current.$slide, {
                top: self.sliderStartPos.top + self.distanceY + (self.velocityY * 150),
                opacity: 0
            }, 150);
            ret = self.instance.close(true, 300);
        } else if (swiping == 'x' && self.distanceX > 50 && len > 1) {
            ret = self.instance.previous(self.speedX);
        } else if (swiping == 'x' && self.distanceX < -50 && len > 1) {
            ret = self.instance.next(self.speedX);
        }
        if (ret === false && (swiping == 'x' || swiping == 'y')) {
            if (scrolling || len < 2) {
                self.instance.centerSlide(self.instance.current, 150);
            } else {
                self.instance.jumpTo(self.instance.current.index);
            }
        }
        self.$container.removeClass('fxModalBox-is-sliding');
    };
    // Limit panning from edges
    // ========================
    Guestures.prototype.endPanning = function() {
        var self = this;
        var newOffsetX, newOffsetY, newPos;
        if (!self.contentLastPos) {
            return;
        }
        if (self.opts.momentum === false) {
            newOffsetX = self.contentLastPos.left;
            newOffsetY = self.contentLastPos.top;
        } else {
            // Continue movement
            newOffsetX = self.contentLastPos.left + (self.velocityX * self.speed);
            newOffsetY = self.contentLastPos.top + (self.velocityY * self.speed);
        }
        newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);
        newPos.width = self.contentStartPos.width;
        newPos.height = self.contentStartPos.height;
        $.fxModalBox.animate(self.$content, newPos, 330);
    };
    Guestures.prototype.endZooming = function() {
        var self = this;
        var current = self.instance.current;
        var newOffsetX, newOffsetY, newPos, reset;
        var newWidth = self.newWidth;
        var newHeight = self.newHeight;
        if (!self.contentLastPos) {
            return;
        }
        newOffsetX = self.contentLastPos.left;
        newOffsetY = self.contentLastPos.top;
        reset = {
            top: newOffsetY,
            left: newOffsetX,
            width: newWidth,
            height: newHeight,
            scaleX: 1,
            scaleY: 1
        };
        // Reset scalex/scaleY values; this helps for perfomance and does not break animation
        $.fxModalBox.setTranslate(self.$content, reset);
        if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {
            self.instance.scaleToFit(150);
        } else if (newWidth > current.width || newHeight > current.height) {
            self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);
        } else {
            newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);
            // Switch from scale() to width/height or animation will not work correctly
            $.fxModalBox.setTranslate(self.content, $.fxModalBox.getTranslate(self.$content));
            $.fxModalBox.animate(self.$content, newPos, 150);
        }
    };
    Guestures.prototype.onTap = function(e) {
        var self = this;
        var $target = $(e.target);
        var instance = self.instance;
        var current = instance.current;
        var endPoints = (e && pointers(e)) || self.startPoints;
        var tapX = endPoints[0] ? endPoints[0].x - self.$stage.offset().left : 0;
        var tapY = endPoints[0] ? endPoints[0].y - self.$stage.offset().top : 0;
        var where;
        var process = function(prefix) {
            var action = current.opts[prefix];
            if ($.isFunction(action)) {
                action = action.apply(instance, [current, e]);
            }
            if (!action) {
                return;
            }
            switch (action) {
                case "close":
                    instance.close(self.startEvent);
                    break;
                case "toggleControls":
                    instance.toggleControls(true);
                    break;
                case "next":
                    instance.next();
                    break;
                case "nextOrClose":
                    if (instance.group.length > 1) {
                        instance.next();
                    } else {
                        instance.close(self.startEvent);
                    }
                    break;
                case "zoom":
                    if (current.type == 'image' && (current.isLoaded || current.$ghost)) {
                        if (instance.canPan()) {
                            instance.scaleToFit();
                        } else if (instance.isScaledDown()) {
                            instance.scaleToActual(tapX, tapY);
                        } else if (instance.group.length < 2) {
                            instance.close(self.startEvent);
                        }
                    }
                    break;
            }
        };
        // Ignore right click
        if (e.originalEvent && e.originalEvent.button == 2) {
            return;
        }
        // Skip if clicked on the scrollbar
        if (!$target.is('img') && tapX > $target[0].clientWidth + $target.offset().left) {
            return;
        }
        // Check where is clicked
        if ($target.is('.fxModalBox-bg,.fxModalBox-inner,.fxModalBox-outer,.fxModalBox-container')) {
            where = 'Outside';
        } else if ($target.is('.fxModalBox-slide')) {
            where = 'Slide';
        } else if (instance.current.$content && instance.current.$content.find($target).addBack().filter($target).length) {
            where = 'Content';
        } else {
            return;
        }
        // Check if this is a double tap
        if (self.tapped) {
            // Stop previously created single tap
            clearTimeout(self.tapped);
            self.tapped = null;
            // Skip if distance between taps is too big
            if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) {
                return this;
            }
            // OK, now we assume that this is a double-tap
            process('dblclick' + where);
        } else {
            // Single tap will be processed if user has not clicked second time within 300ms
            // or there is no need to wait for double-tap
            self.tapX = tapX;
            self.tapY = tapY;
            if (current.opts['dblclick' + where] && current.opts['dblclick' + where] !== current.opts['click' + where]) {
                self.tapped = setTimeout(function() {
                    self.tapped = null;
                    process('click' + where);
                }, 500);
            } else {
                process('click' + where);
            }
        }
        return this;
    };
    $(document).on('onActivate.fxmb', function(e, instance) {
        if (instance && !instance.Guestures) {
            instance.Guestures = new Guestures(instance);
        }
    });
}(window, document, window.jQuery || jQuery));

//==========================================================================
//
//SlideShow
//Enables slideshow functionality
//
//Example of usage:
//$.fxModalBox.getInstance().SlideShow.start()
//
//==========================================================================
;
(function(document, $) {
    'use strict';
    $.extend(true, $.fxModalBox.defaults, {
        btnTpl: {
            slideShow: '<button data-fxModalBox-play class="fxModalBox-button fxModalBox-button--play" title="{{PLAY_START}}">' +
                '<svg viewBox="0 0 40 40">' +
                '<path d="M13,12 L27,20 L13,27 Z" />' +
                '<path d="M15,10 v19 M23,10 v19" />' +
                '</svg>' +
                '</button>'
        },
        slideShow: {
            autoStart: false,
            speed: 3000
        }
    });
    var SlideShow = function(instance) {
        this.instance = instance;
        this.init();
    };
    $.extend(SlideShow.prototype, {
        timer: null,
        isActive: false,
        $button: null,
        init: function() {
            var self = this;
            self.$button = self.instance.$refs.toolbar.find('[data-fxModalBox-play]').on('click', function() {
                self.toggle();
            });
            if (self.instance.group.length < 2 || !self.instance.group[self.instance.currIndex].opts.slideShow) {
                self.$button.hide();
            }
        },
        set: function(force) {
            var self = this;
            // Check if reached last element
            if (self.instance && self.instance.current && (force === true || self.instance.current.opts.loop || self.instance.currIndex < self.instance.group.length - 1)) {
                self.timer = setTimeout(function() {
                    if (self.isActive) {
                        self.instance.jumpTo((self.instance.currIndex + 1) % self.instance.group.length);
                    }
                }, self.instance.current.opts.slideShow.speed);
            } else {
                self.stop();
                self.instance.idleSecondsCounter = 0;
                self.instance.showControls();
            }
        },
        clear: function() {
            var self = this;
            clearTimeout(self.timer);
            self.timer = null;
        },
        start: function() {
            var self = this;
            var current = self.instance.current;
            if (current) {
                self.isActive = true;
                self.$button
                    .attr('title', current.opts.i18n[current.opts.lang].PLAY_STOP)
                    .removeClass('fxModalBox-button--play')
                    .addClass('fxModalBox-button--pause');
                self.set(true);
            }
        },
        stop: function() {
            var self = this;
            var current = self.instance.current;
            self.clear();
            self.$button
                .attr('title', current.opts.i18n[current.opts.lang].PLAY_START)
                .removeClass('fxModalBox-button--pause')
                .addClass('fxModalBox-button--play');
            self.isActive = false;
        },
        toggle: function() {
            var self = this;
            if (self.isActive) {
                self.stop();
            } else {
                self.start();
            }
        }
    });
    $(document).on({
        'onInit.fxmb': function(e, instance) {
            if (instance && !instance.SlideShow) {
                instance.SlideShow = new SlideShow(instance);
            }
        },
        'beforeShow.fxmb': function(e, instance, current, firstRun) {
            var SlideShow = instance && instance.SlideShow;
            if (firstRun) {
                if (SlideShow && current.opts.slideShow.autoStart) {
                    SlideShow.start();
                }
            } else if (SlideShow && SlideShow.isActive) {
                SlideShow.clear();
            }
        },
        'afterShow.fxmb': function(e, instance, current) {
            var SlideShow = instance && instance.SlideShow;
            if (SlideShow && SlideShow.isActive) {
                SlideShow.set();
            }
        },
        'afterKeydown.fxmb': function(e, instance, current, keypress, keycode) {
            var SlideShow = instance && instance.SlideShow;
            // "P" or Spacebar
            if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is('button,a,input')) {
                keypress.preventDefault();
                SlideShow.toggle();
            }
        },
        'beforeClose.fxmb onDeactivate.fxmb': function(e, instance) {
            var SlideShow = instance && instance.SlideShow;
            if (SlideShow) {
                SlideShow.stop();
            }
        }
    });
    // Page Visibility API to pause slideshow when window is not active
    $(document).on("visibilitychange", function() {
        var instance = $.fxModalBox.getInstance();
        var SlideShow = instance && instance.SlideShow;
        if (SlideShow && SlideShow.isActive) {
            if (document.hidden) {
                SlideShow.clear();
            } else {
                SlideShow.set();
            }
        }
    });
}(document, window.jQuery || jQuery));

//==========================================================================
//
//FullScreen
//Adds fullscreen functionality
//
//==========================================================================
;
(function(document, $) {
    'use strict';
    // Collection of methods supported by user browser
    var fn = (function() {
        var fnMap = [
            [
                'requestFullscreen',
                'exitFullscreen',
                'fullscreenElement',
                'fullscreenEnabled',
                'fullscreenchange',
                'fullscreenerror'
            ],
            // new WebKit
            [
                'webkitRequestFullscreen',
                'webkitExitFullscreen',
                'webkitFullscreenElement',
                'webkitFullscreenEnabled',
                'webkitfullscreenchange',
                'webkitfullscreenerror'

            ],
            // old WebKit (Safari 5.1)
            [
                'webkitRequestFullScreen',
                'webkitCancelFullScreen',
                'webkitCurrentFullScreenElement',
                'webkitCancelFullScreen',
                'webkitfullscreenchange',
                'webkitfullscreenerror'

            ],
            [
                'mozRequestFullScreen',
                'mozCancelFullScreen',
                'mozFullScreenElement',
                'mozFullScreenEnabled',
                'mozfullscreenchange',
                'mozfullscreenerror'
            ],
            [
                'msRequestFullscreen',
                'msExitFullscreen',
                'msFullscreenElement',
                'msFullscreenEnabled',
                'MSFullscreenChange',
                'MSFullscreenError'
            ]
        ];
        var val;
        var ret = {};
        var i, j;
        for (i = 0; i < fnMap.length; i++) {
            val = fnMap[i];
            if (val && val[1] in document) {
                for (j = 0; j < val.length; j++) {
                    ret[fnMap[0][j]] = val[j];
                }
                return ret;
            }
        }
        return false;
    })();
    // If browser does not have Full Screen API, then simply unset default button template and stop
    if (!fn) {
        if ($ && $.fxModalBox) {
            $.fxModalBox.defaults.btnTpl.fullScreen = false;
        }
        return;
    }
    var FullScreen = {
        request: function(elem) {
            elem = elem || document.documentElement;
            elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);
        },
        exit: function() {
            document[fn.exitFullscreen]();
        },
        toggle: function(elem) {
            elem = elem || document.documentElement;
            if (this.isFullscreen()) {
                this.exit();
            } else {
                this.request(elem);
            }
        },
        isFullscreen: function() {
            return Boolean(document[fn.fullscreenElement]);
        },
        enabled: function() {
            return Boolean(document[fn.fullscreenEnabled]);
        }
    };
    $.extend(true, $.fxModalBox.defaults, {
        btnTpl: {
            fullScreen: '<button data-fxModalBox-fullscreen class="fxModalBox-button fxModalBox-button--fullscreen" title="{{FULL_SCREEN}}">' +
                '<svg viewBox="0 0 40 40">' +
                '<path d="M9,12 h22 v16 h-22 v-16 v16 h22 v-16 Z" />' +
                '</svg>' +
                '</button>'
        },
        fullScreen: {
            autoStart: false
        }
    });
    $(document).on({
        'onInit.fxmb': function(e, instance) {
            var $container;
            if (instance && instance.group[instance.currIndex].opts.fullScreen) {
                $container = instance.$refs.container;
                $container.on('click.fxmb-fullscreen', '[data-fxModalBox-fullscreen]', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    FullScreen.toggle($container[0]);
                });
                if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {
                    FullScreen.request($container[0]);
                }
                // Expose API
                instance.FullScreen = FullScreen;
            } else if (instance) {
                instance.$refs.toolbar.find('[data-fxModalBox-fullscreen]').hide();
            }
        },
        'afterKeydown.fxmb': function(e, instance, current, keypress, keycode) {
            // "P" or Spacebar
            if (instance && instance.FullScreen && keycode === 70) {
                keypress.preventDefault();
                instance.FullScreen.toggle(instance.$refs.container[0]);
            }
        },
        'beforeClose.fxmb': function(instance) {
            if (instance && instance.FullScreen) {
                FullScreen.exit();
            }
        }
    });
    $(document).on(fn.fullscreenchange, function() {
        var isFullscreen = FullScreen.isFullscreen(),
            instance = $.fxModalBox.getInstance();
        if (instance) {
            // If image is zooming, then force to stop and reposition properly
            if (instance.current && instance.current.type === 'image' && instance.isAnimating) {
                instance.current.$content.css('transition', 'none');

                instance.isAnimating = false;

                instance.update(true, true, 0);
            }
            instance.trigger('onFullscreenChange', isFullscreen);
            instance.$refs.container.toggleClass('fxModalBox-is-fullscreen', isFullscreen);
        }
    });
}(document, window.jQuery || jQuery));
//==========================================================================
//
//Thumbs
//Displays thumbnails in a grid
//
//==========================================================================
;
(function(document, $) {
    'use strict';
    // Make sure there are default values
    $.fxModalBox.defaults = $.extend(true, {
        btnTpl: {
            thumbs: '<button data-fxModalBox-thumbs class="fxModalBox-button fxModalBox-button--thumbs" title="{{THUMBS}}">' +
                '<svg viewBox="0 0 120 120">' +
                '<path d="M30,30 h14 v14 h-14 Z M50,30 h14 v14 h-14 Z M70,30 h14 v14 h-14 Z M30,50 h14 v14 h-14 Z M50,50 h14 v14 h-14 Z M70,50 h14 v14 h-14 Z M30,70 h14 v14 h-14 Z M50,70 h14 v14 h-14 Z M70,70 h14 v14 h-14 Z" />' +
                '</svg>' +
                '</button>'
        },
        thumbs: {
            autoStart: false, // Display thumbnails on opening
            hideOnClose: true, // Hide thumbnail grid when closing animation starts
            parentEl: '.fxModalBox-container', // Container is injected into this element
            axis: 'y' // Vertical (y) or horizontal (x) scrolling
        }
    }, $.fxModalBox.defaults);

    var FxModalThumbs = function(instance) {
        this.init(instance);
    };
    $.extend(FxModalThumbs.prototype, {
        $button: null,
        $grid: null,
        $list: null,
        isVisible: false,
        isActive: false,
        init: function(instance) {
            var self = this;
            self.instance = instance;
            instance.Thumbs = self;
            // Enable thumbs if at least two group items have thumbnails
            var first = instance.group[0],
                second = instance.group[1];
            self.opts = instance.group[instance.currIndex].opts.thumbs;
            self.$button = instance.$refs.toolbar.find('[data-fxModalBox-thumbs]');
            if (self.opts && first && second && (
                    (first.type == 'image' || first.opts.thumb || first.opts.$thumb) &&
                    (second.type == 'image' || second.opts.thumb || second.opts.$thumb)
                )) {
                self.$button.show().on('click', function() {
                    self.toggle();
                });
                self.isActive = true;
            } else {
                self.$button.hide();
            }
        },
        create: function() {
            var self = this,
                instance = self.instance,
                parentEl = self.opts.parentEl,
                list,
                src;
            self.$grid = $('<div class="fxModalBox-thumbs fxModalBox-thumbs-' + self.opts.axis + '"></div>').appendTo(instance.$refs.container.find(parentEl).addBack().filter(parentEl));
            // Build list HTML
            list = '<ul>';
            $.each(instance.group, function(i, item) {
                src = item.opts.thumb || (item.opts.$thumb ? item.opts.$thumb.attr('src') : null);
                if (!src && item.type === 'image') {
                    src = item.src;
                }
                if (src && src.length) {
                    list += '<li data-index="' + i + '"  tabindex="0" class="fxModalBox-thumbs-loading"><img data-src="' + src + '" alt="' + item.opts.$orig.context.dataset.alt + '" /></li>';
                }
            });
            list += '</ul>';
            self.$list = $(list).appendTo(self.$grid).on('click', 'li', function() {
                instance.jumpTo($(this).data('index'));
            });
            self.$list.find('img').hide().one('load', function() {
                    var $parent = $(this).parent().removeClass('fxModalBox-thumbs-loading'),
                        thumbWidth = $parent.outerWidth(),
                        thumbHeight = $parent.outerHeight(),
                        width,
                        height,
                        widthRatio,
                        heightRatio;
                    width = this.naturalWidth || this.width;
                    height = this.naturalHeight || this.height;
                    // Calculate thumbnail dimensions; center vertically and horizontally
                    widthRatio = width / thumbWidth;
                    heightRatio = height / thumbHeight;
                    if (widthRatio >= 1 && heightRatio >= 1) {
                        if (widthRatio > heightRatio) {
                            width = width / heightRatio;
                            height = thumbHeight;
                        } else {
                            width = thumbWidth;
                            height = height / widthRatio;
                        }
                    }
                    $(this).css({
                        width: Math.floor(width),
                        height: Math.floor(height),
                        'margin-top': height > thumbHeight ? (Math.floor(thumbHeight * 0.3 - height * 0.3)) : Math.floor(thumbHeight * 0.5 - height * 0.5),
                        'margin-left': Math.floor(thumbWidth * 0.5 - width * 0.5)
                    }).show();
                })
                .each(function() {
                    this.src = $(this).data('src');
                });
            if (self.opts.axis === 'x') {
                self.$list.width(parseInt(self.$grid.css("padding-right")) + (instance.group.length * self.$list.children().eq(0).outerWidth(true)) + 'px');
            }
        },
        focus: function(duration) {
            var self = this,
                $list = self.$list,
                thumb,
                thumbPos;
            if (self.instance.current) {
                thumb = $list.children()
                    .removeClass('fxModalBox-thumbs-active')
                    .filter('[data-index="' + self.instance.current.index + '"]')
                    .addClass('fxModalBox-thumbs-active');
                thumbPos = thumb.position();
                // Check if need to scroll to make current thumb visible
                if (self.opts.axis === 'y' && (thumbPos.top < 0 || thumbPos.top > ($list.height() - thumb.outerHeight()))) {
                    $list.stop().animate({
                        'scrollTop': $list.scrollTop() + thumbPos.top
                    }, duration);
                } else if (self.opts.axis === 'x' && (
                        thumbPos.left < $list.parent().scrollLeft() ||
                        thumbPos.left > ($list.parent().scrollLeft() + ($list.parent().width() - thumb.outerWidth()))
                    )) {
                    $list.parent().stop().animate({
                        'scrollLeft': thumbPos.left
                    }, duration);
                }
            }
        },
        update: function() {
            this.instance.$refs.container.toggleClass('fxModalBox-show-thumbs', this.isVisible);
            if (this.isVisible) {
                if (!this.$grid) {
                    this.create();
                }
                this.instance.trigger('onThumbsShow');
                this.focus(0);
            } else if (this.$grid) {
                this.instance.trigger('onThumbsHide');
            }
            // Update content position
            this.instance.update();
        },
        hide: function() {
            this.isVisible = false;
            this.update();
        },
        show: function() {
            this.isVisible = true;
            this.update();
        },
        toggle: function() {
            this.isVisible = !this.isVisible;
            this.update();
        }
    });
    $(document).on({
        'onInit.fxmb': function(e, instance) {
            var Thumbs;
            if (instance && !instance.Thumbs) {
                Thumbs = new FxModalThumbs(instance);
                if (Thumbs.isActive && Thumbs.opts.autoStart === true) {
                    Thumbs.show();
                }
            }
        },
        'beforeShow.fxmb': function(e, instance, item, firstRun) {
            var Thumbs = instance && instance.Thumbs;
            if (Thumbs && Thumbs.isVisible) {
                Thumbs.focus(firstRun ? 0 : 250);
            }
        },
        'afterKeydown.fxmb': function(e, instance, current, keypress, keycode) {
            var Thumbs = instance && instance.Thumbs;
            // "G"
            if (Thumbs && Thumbs.isActive && keycode === 71) {
                keypress.preventDefault();
                Thumbs.toggle();
            }
        },
        'beforeClose.fxmb': function(e, instance) {
            var Thumbs = instance && instance.Thumbs;
            if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {
                Thumbs.$grid.hide();
            }
        }
    });
}(document, window.jQuery));
////==========================================================================
//
//Share
//Displays simple form for sharing current url
//
//==========================================================================
;
(function(document, $) {
    'use strict';
    $.extend(true, $.fxModalBox.defaults, {
        btnTpl: {
            share: '<button data-fxModalBox-share class="fxModalBox-button fxModalBox-button--share" title="{{SHARE}}">' +
                '<svg viewBox="0 0 40 40">' +
                '<path d="M6,30 C8,18 19,16 23,16 L23,16 L23,10 L33,20 L23,29 L23,24 C19,24 8,27 6,30 Z">' +
                '</svg>' +
                '</button>'
        },
        share: {
            tpl: '<div class="fxModalBox-share">' +
                '<h1>{{SHARE}}</h1>' +
                '<p class="fxModalBox-share__links">' +
                '<a class="fxModalBox-share__button fxModalBox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}">' +
                '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg>' +
                '<span>Facebook</span>' +
                '</a>' +
                '<a class="fxModalBox-share__button fxModalBox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}">' +
                '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg>' +
                '<span>Pinterest</span>' +
                '</a>' +
                '<a class="fxModalBox-share__button fxModalBox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}">' +
                '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg>' +
                '<span>Twitter</span>' +
                '</a>' +
                '</p>' +
                '<p><input class="fxModalBox-share__input" type="text" value="{{url_raw}}" /></p>' +
                '</div>'
        }
    });

    function escapeHtml(string) {
        var entityMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '/': '&#x2F;',
            '`': '&#x60;',
            '=': '&#x3D;'
        };
        return String(string).replace(/[&<>"'`=\/]/g, function(s) {
            return entityMap[s];
        });
    }
    $(document).on('click', '[data-fxModalBox-share]', function() {
        var f = $.fxModalBox.getInstance(),
            url,
            tpl;
        if (f) {
            url = f.current.opts.hash === false ? f.current.src : window.location;
            tpl = f.current.opts.share.tpl
                .replace(/\{\{media\}\}/g, f.current.type === 'image' ? encodeURIComponent(f.current.src) : '')
                .replace(/\{\{url\}\}/g, encodeURIComponent(url))
                .replace(/\{\{url_raw\}\}/g, escapeHtml(url))
                .replace(/\{\{descr\}\}/g, f.$caption ? encodeURIComponent(f.$caption.text()) : '');
            $.fxModalBox.open({
                src: f.translate(f, tpl),
                type: 'html',
                opts: {
                    animationEffect: "fade",
                    animationDuration: 250,
                    afterLoad: function(instance, current) {
                        // Opening links in a popup window
                        current.$content.find('.fxModalBox-share__links a').click(function() {
                            window.open(this.href, "Share", "width=550, height=450");
                            return false;
                        });
                    }
                }
            });
        }
    });
}(document, window.jQuery || jQuery));
//==========================================================================
//
//Hash
//Enables linking to each modal
//
//==========================================================================
;
(function(document, window, $) {
    'use strict';
    // Simple $.escapeSelector polyfill (for jQuery prior v3)
    if (!$.escapeSelector) {
        $.escapeSelector = function(sel) {
            var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
            var fcssescape = function(ch, asCodePoint) {
                if (asCodePoint) {
                    // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                    if (ch === "\0") {
                        return "\uFFFD";
                    }
                    // Control characters and (dependent upon position) numbers get escaped as code points
                    return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                }
                // Other potentially-special ASCII characters get backslash-escaped
                return "\\" + ch;
            };
            return (sel + "").replace(rcssescape, fcssescape);
        };
    }
    // Create new history entry only once
    var shouldCreateHistory = true;
    // Variable containing last hash value set by fxModalBox
    // It will be used to determine if fxModalBox needs to close after hash change is detected
    var currentHash = null;
    // Throttling the history change
    var timerID = null;
    // Get info about gallery name and current index from url
    function parseUrl() {
        var hash = window.location.hash.substr(1);
        var rez = hash.split('-');
        var index = rez.length > 1 && /^\+?\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1;
        var gallery = rez.join('-');
        // Index is starting from 1
        if (index < 1) {
            index = 1;
        }
        return {
            hash: hash,
            index: index,
            gallery: gallery
        };
    }
    // Trigger click evnt on links to open new fxModalBox instance
    function triggerFromUrl(url) {
        var $el;
        if (url.gallery !== '') {
            // If we can find element matching 'data-fxModalBox' atribute, then trigger click event for that ..
            $el = $("html").find("[data-fxModalBox='" + $.escapeSelector(url.gallery) + "']").eq(url.index - 1);
            if (!$el.length) {
                // .. if not, try finding element by ID
                $el = $("html").find("#" + $.escapeSelector(url.gallery) + "");
            }
            if ($el.length) {
                shouldCreateHistory = false;
                $el.trigger('click');
            }
        }
    }
    // Get gallery name from current instance
    function getGalleryID(instance) {
        var opts;
        if (!instance) {
            return false;
        }
        opts = instance.current ? instance.current.opts : instance.opts;
        return opts.hash || (opts.$orig ? opts.$orig.data('fxModalBox') : '');
    }
    // Start when DOM becomes ready
    $(function() {
        // Check if user has disabled this module
        if ($.fxModalBox.defaults.hash === false) {
            return;
        }
        // Update hash when opening/closing fxModalBox
        $(document).on({
            'onInit.fxmb': function(e, instance) {
                var url, gallery;
                if (instance.group[instance.currIndex].opts.hash === false) {
                    return;
                }
                url = parseUrl();
                gallery = getGalleryID(instance);
                // Make sure gallery start index matches index from hash
                if (gallery && url.gallery && gallery == url.gallery) {
                    instance.currIndex = url.index - 1;
                }
            },
            'beforeShow.fxmb': function(e, instance, current) {
                var gallery;
                if (!current || current.opts.hash === false) {
                    return;
                }
                gallery = getGalleryID(instance);
                // Update window hash
                if (gallery && gallery !== '') {
                    if (window.location.hash.indexOf(gallery) < 0) {
                        instance.opts.origHash = window.location.hash;
                    }
                    currentHash = gallery + (instance.group.length > 1 ? '-' + (current.index + 1) : '');
                    if ('replaceState' in window.history) {
                        if (timerID) {
                            clearTimeout(timerID);
                        }
                        timerID = setTimeout(function() {
                            window.history[shouldCreateHistory ? 'pushState' : 'replaceState']({}, document.title, window.location.pathname + window.location.search + '#' + currentHash);
                            timerID = null;
                            shouldCreateHistory = false;
                        }, 300);
                    } else {
                        window.location.hash = currentHash;
                    }
                }
            },
            'beforeClose.fxmb': function(e, instance, current) {
                var gallery, origHash;
                if (timerID) {
                    clearTimeout(timerID);
                }
                if (current.opts.hash === false) {
                    return;
                }
                gallery = getGalleryID(instance);
                origHash = instance && instance.opts.origHash ? instance.opts.origHash : '';
                // Remove hash from location bar
                if (gallery && gallery !== '') {
                    if ('replaceState' in history) {
                        window.history.replaceState({}, document.title, window.location.pathname + window.location.search + origHash);
                    } else {
                        window.location.hash = origHash;
                        // Keep original scroll position
                        $(window).scrollTop(instance.scrollTop).scrollLeft(instance.scrollLeft);
                    }
                }
                currentHash = null;
            }
        });
        // Check if need to close after url has changed
        $(window).on('hashchange.fxmb', function() {
            var url = parseUrl();
            if ($.fxModalBox.getInstance()) {
                if (currentHash && currentHash !== url.gallery + '-' + url.index && !(url.index === 1 && currentHash == url.gallery)) {
                    currentHash = null;
                    $.fxModalBox.close();
                }
            } else if (url.gallery !== '') {
                triggerFromUrl(url);
            }
        });
        // Check current hash and trigger click event on matching element to start fxModalBox, if needed
        setTimeout(function() {
            triggerFromUrl(parseUrl());
        }, 50);
    });
}(document, window, window.jQuery || jQuery));;
(function(document, $) {
    'use strict';
    var prevTime = new Date().getTime();
    $(document).on({
        'onInit.fxmb': function(e, instance, current) {
            instance.$refs.stage.on('mousewheel DOMMouseScroll wheel MozMousePixelScroll', function(e) {
                var current = instance.current,
                    currTime = new Date().getTime();
                if (instance.group.length < 1 || current.opts.wheel === false || (current.opts.wheel === 'auto' && current.type !== 'image')) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                if (current.$slide.hasClass('fxModalBox-animated')) {
                    return;
                }
                e = e.originalEvent || e;
                if (currTime - prevTime < 250) {
                    return;
                }
                prevTime = currTime;
                instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? 'next' : 'previous']();
            });
        }
    });
}(document, window.jQuery || jQuery));
/* This is the FedEx.com image component javascript file.
 The global FDX object must already be defined

 Author: shawn.tao@vml.com
 Created: 2017-10-10
 */
if (!FDX) {
    var FDX = {};
}

FDX.IMAGE = {
    imageComponentClass: 'fxg-image-component__image',
    imageClass: 'fxg-img',
    imageCaptionClass: 'fxg-image-component__caption',

    setImageCaptionWidth: function() {
        var imageCaption = $('.' + FDX.IMAGE.imageCaptionClass);
        var width = imageCaption.siblings('.' + FDX.IMAGE.imageComponentClass).children('.' + FDX.IMAGE.imageClass).width();
        imageCaption.css({
            width: "inherit"
        });
    }
};

$(document).ready(function() {
    FDX.IMAGE.setImageCaptionWidth();
    $(window).bind('resize', function() {
        FDX.IMAGE.setImageCaptionWidth();
    });
});

$(window).bind('load', function() {
    var defaultImagePath = '/content/dam/fedex-com/images/default-image/image-placeholder.jpg';
    var imgs = document.querySelectorAll('img');

    setTimeout(function() {
        Array.from(imgs).forEach(function(imgValue) {
            if ((typeof imgValue.naturalWidth != "undefined" && imgValue.naturalWidth == 0 && imgValue.naturalHeight == 0)) {

                var handleNonSVGImagesInImgComp = function(img) {
                    var img_rendition = img.getAttribute('src');
                    var data_rendition = img.getAttribute('data-rendition');
                    var data_renmatch = data_rendition.match(/jcr:(.*)/) || data_rendition.match(/_jcr(.*)/); // Later check the extensions also 

                    if (data_renmatch != null) {
                        if (data_renmatch[0].indexOf('_jcr_content') !== -1) {
                            data_renmatch[0] = data_renmatch[0].replace('_jcr_content', 'jcr:content');
                        }
                        img_rendition = '/' + data_renmatch[0];
                        img.setAttribute('src', FDX.contextPath + '' + defaultImagePath + img_rendition);
                        img.addEventListener('error', function(e) {
                            img.setAttribute('src', FDX.contextPath + '' + defaultImagePath);
                        });
                    }
                }

                var handleSVGImagesInImgComp = function(img) {
                    img.setAttribute('src', img.getAttribute('src'));

                    img.addEventListener('error', function(e) {
                        e.target.setAttribute('src', FDX.contextPath + '' + defaultImagePath);
                    });
                }

                if (imgValue.getAttribute('src')) {
                    var img_altValue = imgValue.getAttribute('alt');

                    // to handle broken images in image component which are NOT svgs
                    if (imgValue.getAttribute('data-rendition') && imgValue.src.indexOf('svg') < 0) {
                        handleNonSVGImagesInImgComp(imgValue);
                    }
                    //to handle broken images in image component which are svgs
                    else if (imgValue.getAttribute('data-rendition') || typeof imgValue.getAttribute('data-rendition') === "undefined" && imgValue.src.indexOf('svg') >= 0) {
                        handleSVGImagesInImgComp(imgValue);
                    } else { // to handle broken images on page which are not within image component
                        imgValue.setAttribute('src', FDX.contextPath + '' + defaultImagePath);
                    }

                    // always execute this condition and set alt value and remove the title
                    if (typeof img_altValue == "undefined" || img_altValue == '') {
                        imgValue.setAttribute('alt', '');
                    } else {
                        imgValue.setAttribute('alt', 'FedEx owned and licensed image');
                    }

                    if (imgValue.getAttribute('title')) {
                        imgValue.removeAttribute('title');
                    }
                }
            }
        })
    }, 600);
});
/* This is the FedEx.com icon link component javascript file.
 The global FDX object must already be defined.

 

 */

if (!FDX) {
    var FDX = {};
}



FDX.ICON = {
    iconClass: "fxg-icon",
    customIconClass: "fxg-icon--custom"
};


$(document).ready(function() {
    $('.' + FDX.ICON.iconClass + '.' + FDX.ICON.customIconClass).each(function() {
        var imagePath = $(this).css('background-image');
        if (imagePath.indexOf('.svg') != -1)
            $(this).attr('role', 'presentation');
    });
});

/* This is the FedEx.com hero component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com, joey.dukeminier@vml.com
 Created: 2017-04-11
 */
if (!FDX) {
    var FDX = {};
}

FDX.HERO = {
    heroClass: "fxg-hero",
    homepageHeroClass: "fxg-hero_homepage",
    imgClass: "fxg-hero__image",

    setHeroHeight: function() {
        console.warn('setHeroHeight() is obsolete, and will be removed in future.');
    },

    removeHeroHeight: function() {
        console.warn('removeHeroHeight() is obsolete, and will be removed in future.');
    },

    setMobileBackgroundImage: function() {
        var targetElem = $('.' + FDX.HERO.homepageHeroClass + " ." + FDX.HERO.imgClass);
        var mobileImg = targetElem.attr('data-mobile-image');
        var mobileImgFocal = targetElem.attr('data-mobile-image-focal');
        targetElem.css('background-image', 'url(' + mobileImg + ')');
        targetElem.css('background-position', mobileImgFocal);
        targetElem.show();
    },

    setMainBackgroundImage: function() {
        var targetElem = $('.' + FDX.HERO.homepageHeroClass + " ." + FDX.HERO.imgClass);
        var mainImg = targetElem.attr('data-main-image');
        var mainImgFocal = targetElem.attr('data-main-image-focal');
        targetElem.css('background-image', 'url(' + mainImg + ')');
        targetElem.css('background-position', mainImgFocal);
        targetElem.show();
    },

    mobileBreakpointChanged: function(mq) {
        if (mq.matches) {
            FDX.HERO.setMobileBackgroundImage();
        } else {
            FDX.HERO.setMainBackgroundImage();
        }
    },
    convertSVGImageToCode: function() {
        $(".svg_convert").each(function(index) {
            var imageObj = $(this),
                imagePath = imageObj.attr("src");
            $.get(imagePath, function(data) {
                var svgData = $("html").find(data).find('svg');
                svgData.attr("class", "fxg-cube__icon");
                imageObj.replaceWith(svgData);
            });
        });
    }
};

$(document).ready(function() {

    $('.fxg-wrapper').parents('.container').css({
        "padding-top": "0px",
        "padding-bottom": "0px"
    });
    //Set correct hero image (desktop vs mobile)
    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.HERO.mobileBreakpointChanged);

    // init
    FDX.HERO.mobileBreakpointChanged(FDX.BREAKPOINTS.getMobileMediaQuery());
    // Convert SVGImage to SVGCode
    FDX.HERO.convertSVGImageToCode();
    if (fdx_browserType == 'trident' || fdx_browserType == 'msie') {
        $(" .fxg-app__single-tracking .fxg-form").css("overflow", "hidden");

    }
    $('.fxg-cube__content svg').attr('tabindex', -1);
    $('.fxg-cube__content svg').attr('focusable', "false");

});

/* This is the FedEx.com help component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-04-11
 */

if (!FDX) {
    var FDX = {};
}

FDX.HELP = {
    helpClass: 'fxg-help',
    helpOpenClass: 'fxg-help--open',
    helpTitleClass: 'fxg-help__title',
    helpCloseButton: 'fxg-help__message-close',

    openHelp: function(element) {
        $(element).addClass(FDX.HELP.helpOpenClass);
    },

    closeHelp: function(element) {
        $(element).removeClass(FDX.HELP.helpOpenClass);
    }
};

$(document).ready(function() {
    $('.' + FDX.HELP.helpTitleClass).on('click', function() {
        FDX.HELP.openHelp($(this).closest('.' + FDX.HELP.helpClass));
    });

    $('.' + FDX.HELP.helpCloseButton).on('click', function() {
        FDX.HELP.closeHelp($(this).closest('.' + FDX.HELP.helpClass));
    });
});
/* This is the FedEx.com header component javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-03-13
 */
if (!FDX) {
    var FDX = {};
}

FDX.HEADER = {
    headerClass: 'fxg-header',
    headerWikiClass: 'fxg-wiki-header',
    shrunkClass: 'fxg-header--shrunk',
    stickyClass: 'fxg-header--sticky',
    height: 0,
    events: {
        heightChanged: 'heightChanged'
    },

    calcHeight: function() {
        var height = $('.' + FDX.HEADER.headerClass).height();
        if (height !== FDX.HEADER.height) {
            FDX.HEADER.height = height;

            // on header height change reset the content wrapper top margin
            FDX.CORE.setContentWrapperTopMargin();

            // trigger height changed event
            $(FDX.HEADER.events).trigger(FDX.HEADER.events.heightChanged, FDX.HEADER.height);
        }
    },

    shrink: function() {
        var $header = $('.' + FDX.HEADER.headerClass);
        if ($header.hasClass(FDX.HEADER.shrunkClass)) return;
        $header.addClass(FDX.HEADER.shrunkClass);

        // calculate height after .25s (css transition time)
        setTimeout(function() {
            FDX.HEADER.calcHeight();
        }, 250);
    },

    grow: function() {
        var $header = $('.' + FDX.HEADER.headerClass);
        if (!$header.hasClass(FDX.HEADER.shrunkClass)) return;
        $header.removeClass(FDX.HEADER.shrunkClass);

        // calculate height after .25s (css transition time)
        setTimeout(function() {
            FDX.HEADER.calcHeight();
        }, 250);
    },

    scrollCheck: function() {
        if (($(window).scrollTop() > 1) && !$('.' + FDX.HEADER.headerClass).hasClass(FDX.HEADER.shrunkClass)) {
            FDX.HEADER.shrink();
        } else if ($(window).scrollTop() <= 1) {
            FDX.HEADER.grow();
        }
    },
    signUpUnfocus: function() {
        $('.fxg-user-options__sign-in span').attr('tabindex', '-1');

        $('.fxg-user-options a.fxg-dropdown-js').addClass('fxg-keyboard');
        var signContent = $('.fxg-user-options a.fxg-dropdown-js').html();
        //var SignSpan = '<div class="fxg-mouse" tabindex="-1">'+signContent+'</div>';
        //$('.fxg-user-options a.fxg-dropdown-js').html(SignSpan);

    },

    resizeMobileMenu: function() {
        var h = $("html").height() - $("header").outerHeight() - $(".fxg-search").outerHeight();
        $(".fxg-user-options .fxg-global-nav").height(h)
    },

    desktopBreakpointChange: function(mq) {
        if (mq.matches) {
            $(".fxg-dropdown.fxg-global-nav").css('height', 'inherit');
        }
    }
}

$(document).ready(function() {

    // shrink or grow on load and scroll
    FDX.HEADER.scrollCheck();
    $(window).on('scroll', _.debounce(function() {
        FDX.HEADER.scrollCheck();
    }, 200));

    // calculate height on load and window resize
    FDX.HEADER.calcHeight();
    $(window).on('resize', _.debounce(function() {
        FDX.HEADER.calcHeight();
    }, 200));

    (function() {
        var hmbgBox = $('.hamburger-box')[0];
        var hmbgInner = $('span.hamburger-inner')[0];
        var signUpModule = $('#global-login-wrapper>a.fxg-dropdown-js');
        /* to hide link focus ring for mouse interactions in header*/
        var links = $('a.fxg-header__logo_wrapper, .fxg-dropdown a.fxg-dropdown-js, .fxg-user-options__search-btn a, a.fxg-search-close-btn');
        $(links).each(function(index, arrVal) {
            $(arrVal).addClass('fxg-keyboard');
            var content = $(arrVal).html();
            var span = '<span class="fxg-mouse" tabindex="-1">' + content + '</span>';
            $(arrVal).html(span);
        });

        function removeFocus(item) {
            $(item).focusout(function() {
                $(item).attr('style', null);
            });
        };

        /* to hide link focus ring for mouse interactions in header Sign up module*/
        $(signUpModule).mousedown(function() {
            $(this).css('outline-color', 'transparent');
            removeFocus(this);
        });

        var fdxLogoDiv = $('.fxg-header__logo_wrapper, .fxg-search-close-btn');
        var fdxClsDiv = $('.fxg-search-close-btn');
        var fdxLogoImg = $('.fxg-header__logo');
        var fdxCloseImg = $('.fxg-user-options__icon .fxg-close-btn');

        $(fdxLogoDiv, fdxClsDiv).mousedown(function() {
            $(fdxLogoImg).css('outline', 'none');
            $('.fxg-nav').focus();
            removeFocus(this);
        });

        //setting position:static as IE doesn't support position:unset
        var ua = navigator.userAgent;
        var is_ie = ua.indexOf("MSIE ") > -1 || ua.indexOf("Trident/") > -1;
        if (is_ie) {
            $('.fxg-header__logo_wrapper .fxg-mouse').css('position', 'static');
            $('button#fxg-mobile-menu-btn').on('mousedown', function() {
                $(hmbgBox).css('outline', 'none');
                removeFocus(this);
            });
        }
    })();
    /* removing span focus to hide link focus ring for mouse interactions in header Sign up module*/

    FDX.HEADER.signUpUnfocus();
    /* adding code to adjust height while alert is open for dropdowns*/
    $(".hamburger, .fxg-alert__details-btn, .fxg-alert__close-btn").on("click", function() {
        setTimeout(function() {
            FDX.HEADER.resizeMobileMenu();
        }, 300);

    })

    /*Remove dropdown height for desktop viewport coming from mobile view*/
    FDX.BREAKPOINTS.getDesktopMediaQuery().addListener(FDX.HEADER.desktopBreakpointChange);

    $(window).on('keyup', function(e) {
        var signInLink = $("#fxg-dropdown-signIn");
        if (e.keyCode == 9 && e.target.id == 'fxg-dropdown-signIn') {
            $(signInLink).css({
                'outline': 'dashed 1px #ffffff',
                'outline-offset': '-10px'
            });
            $(signInLink).on('focusout', function() {
                $(this).css('outline', 'none');
            })
        }
    });
});
/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }

        function _toConsumableArray(arr) {
            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        }

        function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }

        function _iterableToArray(iter) {
            if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
        }

        function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        }

        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            }
            return arr2;
        }

        /**
         * GUIDED NAVIGATION
         * 
         * A horizontally oriented navigation to help users find topics more easily
         */
        (function($, _) {
            window.FDX.components.guidednavigation = function() {
                /**
                 * @type {Object[]} list of instances
                 */
                var instances = [];
                /**
                 * @type {string} root selector
                 */

                var selector = '.fxg-guidednavigation';
                var SETTINGS = {
                    component: 'guidednavigation',
                    namespace: 'fxg'
                };
                var SELECTORS = {
                    buttonBack: "js-".concat(SETTINGS.component, "-back"),
                    buttonExpand: "js-".concat(SETTINGS.component, "-expand"),
                    component: "js-".concat(SETTINGS.component),
                    link: "js-".concat(SETTINGS.component, "-link"),
                    list: "js-".concat(SETTINGS.component, "-list"),
                    listItem: "js-".concat(SETTINGS.component, "-list-item"),
                    item: "js-".concat(SETTINGS.component, "-item"),
                    panel: "js-".concat(SETTINGS.component, "-panel"),
                    panelContent: "js-".concat(SETTINGS.component, "-panel-content")
                };
                var CLASSES = {
                    isActive: 'is-active',
                    isCollapsed: 'is-collapsed',
                    isHidden: 'is-hidden',
                    itemIsActive: 'fxg-guidednavigation__item-is-active'
                };
                var TAGS = {
                    prefix: 'gnav'
                };
                /**
                 * Create component instance
                 *
                 * @public
                 * @return {Object} instance
                 */

                function create() {
                    /**
                     * @type {Object} configuration
                     */
                    var config = {};
                    /**
                     * @type {Object} jQuery DOM root element
                     */

                    var $root = null;
                    /**
                     * Set configuration
                     *
                     * @public
                     * @param {Object} _config - key/value pair
                     * @return {Object} instance
                     */

                    function setConfig(_config) {
                        var defaultConfig = {};
                        config = $.extend({}, defaultConfig, _config);
                    }

                    ;
                    /**
                     * Render HTML
                     *
                     * @private
                     * @return {Promise<string>} - A promise that resolves with rendered HTML
                     */

                    function render() {}
                    /**
                     * Initialize component instance
                     *
                     * @public
                     * @param {Object} [_$root] - component root element (optional)
                     * @return {Promise} - A promise that resolves when instance is initiated
                     */


                    function init(_$root) {
                        var promise = $.Deferred();
                        $root = _$root; //////////////////////////////
                        ////// START GNAV LOGIC //////
                        //////////////////////////////

                        var element = $root[0];
                        var activeLevel = 0;
                        var panel1Activated = false;
                        var panel2Activated = false;
                        var panels = element.querySelectorAll(".".concat(SELECTORS.panel));
                        var siblingButtonsPanel1 = panels[0].querySelectorAll(".".concat(SELECTORS.item));
                        var siblingButtonsPanel2 = panels[1].querySelectorAll(".".concat(SELECTORS.item));
                        var firstPanel = getPanel(activeLevel);
                        addPanelListeners(firstPanel);
                        addGeneralListeners();
                        /**
                         * Get Panel
                         *
                         * @param {Integer} level - Panel level
                         */

                        function getPanel(level) {
                            var levelString = level.toString();
                            return panels[levelString];
                        }
                        /**
                         * Get Panel Content
                         *
                         * @param {String} id - Content id
                         * @param {HTMLElement} panel - DOM element (panel)
                         */


                        function getPanelContent(id, panel) {
                            return panel.querySelector("[data-parent=\"".concat(id, "\"]"));
                        }
                        /**
                         * Reset Panel Content
                         *
                         * @param {HTMLElement} panel - DOM element (panel)
                         */


                        function resetPanelContent(panel) {
                            var contentPanels = panel.querySelectorAll('[data-parent]');
                            contentPanels.forEach(function(item) {
                                item.classList.add(CLASSES.isHidden);
                            });
                        }
                        /**
                         * Add General Listeners
                         *
                         */


                        function addGeneralListeners() {
                            element.addEventListener('keydown', function(event) {
                                return handleKeyEscape(event);
                            });
                        }
                        /**
                         * Handle Escape Key
                         * Collapse the active panel on Escape key if it's not the main panel
                         *
                         * @param {Object} event - Key down event (on component level)
                         */


                        function handleKeyEscape(event) {
                            if (event.keyCode === 27 && activeLevel > 0) {
                                collapsePanel(activeLevel);
                            }
                        }
                        /**
                         * Add Panel Listeners
                         *
                         * @param {HTMLElement} panel - DOM element (panel)
                         */


                        function addPanelListeners(panel) {
                            var backButton = _toConsumableArray(panel.querySelectorAll(".".concat(SELECTORS.buttonBack)));

                            var buttonsExpand = _toConsumableArray(panel.querySelectorAll(".".concat(SELECTORS.buttonExpand)));

                            var links = _toConsumableArray(panel.querySelectorAll(".".concat(SELECTORS.link)));

                            backButton.map(function(button) {
                                return button.addEventListener('click', function() {
                                    return handleBackClick(button);
                                });
                            });
                            buttonsExpand.map(function(button) {
                                return button.addEventListener('click', function() {
                                    return handleButtonClick(button);
                                });
                            });
                            buttonsExpand.map(function(button) {
                                return button.addEventListener('keyup', function(event) {
                                    return handleKeys(event, button);
                                });
                            });
                            links.map(function(link) {
                                return link.addEventListener('click', function(event) {
                                    return handleLinkClick(event, link);
                                });
                            });
                        }
                        /**
                         * Handle Keys
                         * Handling the navigation with buttons
                         *
                         * @param {Object} event - Key down event (on button level)
                         * @param {HTMLElement} button - Clicked button element
                         */


                        function handleKeys(event, button) {
                            if (event.keyCode === 13) {
                                var dataId = button.dataset.id;
                                var focusItem = panels[activeLevel].querySelector("[data-parent=\"".concat(dataId, "\"] > .fxg-guidednavigation__list > .fxg-guidednavigation__list-item > :first-child"));
                                if (focusItem != null) focusItem.focus();
                            }
                        }
                        /**
                         * Handle Button Click
                         *
                         * @param {HTMLElement} button - Clicked button element
                         */


                        function handleButtonClick(button) {
                            var activePanel = button.closest(".".concat(SELECTORS.panel)); // Wipe highlighted active states in panel 1 (in case of a click in panel 1)

                            if (activePanel === panels[0]) {
                                siblingButtonsPanel1.forEach(function(item) {
                                    item.classList.remove(CLASSES.itemIsActive);
                                });
                            } // Wipe highlighted active state in panel 2 (in case of a click in panel 1 + panel 2)


                            siblingButtonsPanel2.forEach(function(item) {
                                item.classList.remove(CLASSES.itemIsActive);
                            });
                            button.classList.add(CLASSES.itemIsActive);
                            var targetPanel = parseInt(button.dataset.targetPanel);
                            var id = button.dataset.id;
                            activeLevel = targetPanel ? parseInt(targetPanel) : 0;
                            renderPanelContent(id); // Analytics

                            var payloadId = id ? "".concat(id) : 'no-id';
                            var payloadLabel = button.innerText ? ":".concat(button.innerText) : ':no-label';
                            var payload = payloadId + payloadLabel;
                            fireGenericInteraction(payload);
                        }
                        /**
                         * Handle Link Click
                         *
                         * @param {Object} event - event from link click
                         * @param {HTMLElement} link - clicked link element
                         */


                        function handleLinkClick(event, link) {
                            // Analytics
                            var id = link.dataset.id ? ":".concat(link.dataset.id) : ':no-id';
                            var viewAll = link.dataset.viewAll === 'true' ? ':all' : '';
                            var label = link.innerText ? ":".concat(link.innerText) : ':no-label';
                            var identifier = TAGS.prefix + id + viewAll + label;
                            var url = link.href ? link.href : 'none';
                            var payload = {
                                identifier: identifier,
                                url: url
                            };
                            fireLinkInteraction(payload);
                        }
                        /**
                         * Handle Back Click
                         *
                         * @param {HTMLElement} backButton - clicked back button element
                         */


                        function handleBackClick(backButton) {
                            collapsePanel(activeLevel); // Analytics

                            var label = backButton.innerText ? ":".concat(backButton.innerText.trim()) : ':no-label';
                            var payload = 'no-id' + label;
                            fireGenericInteraction(payload);
                        }
                        /**
                         * Render Panel Content
                         *
                         * @param {String} id - Content id
                         */


                        function renderPanelContent(id) {
                            var panel = getPanel(activeLevel);
                            var panelContent = getPanelContent(id, panel); // Collapse if the last panel is opened when the main panel is clicked

                            if (activeLevel === 1 && panels[2].classList.contains(CLASSES.isActive)) {
                                panels[2].classList.remove(CLASSES.isActive);
                                panels[2].classList.add(CLASSES.isCollapsed);
                            }

                            panels[activeLevel - 1].classList.remove(CLASSES.isActive);
                            resetPanelContent(panel);
                            panel.classList.remove(CLASSES.isCollapsed);
                            panel.classList.add(CLASSES.isActive);
                            panelContent.classList.remove(CLASSES.isHidden); // Add eventlisteners (only once)

                            if (activeLevel === 1 && !panel1Activated) {
                                panel1Activated = true;
                                addPanelListeners(panel);
                            }

                            if (activeLevel === 2 && !panel2Activated) {
                                panel2Activated = true;
                                addPanelListeners(panel);
                            }
                        }
                        /**
                         * Collapse Panel
                         *
                         * @param {string} level - Panel level
                         */


                        function collapsePanel(level) {
                            var activePanel = getPanel(level);
                            var previousLevel = activeLevel - 1;
                            var previousPanel = getPanel(previousLevel);
                            activePanel.classList.add(CLASSES.isCollapsed);
                            activePanel.classList.remove(CLASSES.isActive);
                            previousPanel.classList.add(CLASSES.isActive);
                            activeLevel = previousLevel; // Set all content items of the panels to 'is-hidden' and focus on the last active item of the previous panel

                            var panelContentItems = activePanel.querySelectorAll(".".concat(SELECTORS.panelContent));
                            panelContentItems.forEach(function(item) {
                                return item.classList.add("".concat(CLASSES.isHidden));
                            });
                            previousPanel.querySelector(".".concat(CLASSES.itemIsActive)).focus();
                        }
                        /**
                         * Fire Generic Interaction
                         * Fires the GDL Generic Interaction event
                         *
                         * Docs: https://gdl-master.devapp.paas.fedex.com/testbed.generic-interaction.html
                         *
                         * @param {String} payload - The string to be sent with this GDL event
                         */


                        function fireGenericInteraction(payload) {
                            if (_typeof(window.FDX.GDL) !== 'object') return;
                            window.FDX.GDL.push(['event:publish', ['interaction', 'click', {
                                name: TAGS.prefix,
                                value: payload
                            }]]);
                        }
                        /**
                         * Fire Link Interaction
                         * Fires the following GDL link tracking event.
                         *
                         * Docs: https://gdl-master.devapp.paas.fedex.com/testbed.link.html
                         *
                         * @param {Object} payload - The data to be sent to GDL
                         */


                        function fireLinkInteraction(payload) {
                            if (_typeof(window.FDX.GDL) !== 'object') return;
                            window.FDX.GDL.push(['event:publish', ['link', 'click/auto', {
                                url: payload.url,
                                linkIdentifier: "link|".concat(payload.identifier)
                            }]]);
                        } ////////////////////////////
                        ////// END GNAV LOGIC //////
                        ////////////////////////////
                        // Initialized


                        $root.data('initialized', true);
                        promise.resolve();
                        return promise;
                    }
                    /**
                     * Get component element
                     *
                     * @public
                     * @return {Object} jQuery DOM element
                     */


                    function getElement() {
                        return $root;
                    } // add and return instance


                    var instance = {
                        setConfig: setConfig,
                        init: init,
                        getElement: getElement
                    };
                    instances.push(instance);
                    return instance;
                }
                /**
                 * Create instances
                 *
                 * @public
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function createInstances() {
                    var promise = $.Deferred();
                    var initPromises = []; // find all related elements

                    $(selector).each(function() {
                        // skip already initialized elements
                        var $element = $(this);
                        if ($element.data('initialized')) return; // create instance

                        var instance = window.FDX.components.guidednavigation.create(); // Set configuration

                        var $config = $('[data-config="js-guidednavigation-config"]', $element);

                        if ($config.length) {
                            instance.setConfig($.parseJSON($config.html().trim()));
                        } // initialize instance


                        var initPromise = instance.init($element);
                        initPromises.push(initPromise);
                    }); // resolve after all inits

                    $.when.apply($, initPromises).then(function() {
                        promise.resolve();
                    });
                    return promise;
                } // return component


                return {
                    create: create,
                    instances: instances,
                    createInstances: createInstances,
                    selector: selector
                };
            }();
        })(window.jQuery, window._);

        /***/
    }),
    /* 2 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // extracted by mini-css-extract-plugin


        /***/
    })
    /******/
]);
/* This is the FedEx.com global navigation component javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-03-13
 */
if (!FDX) {
    var FDX = {};
}

FDX.GLOBALNAV = {
    mobileMenuBtnId: 'fxg-mobile-menu-btn',
    wrapperClass: 'fxg-nav',
    wrapperOpenClass: 'fxg-nav--mobile-menu-open fxg-wiki-nav--mobile-menu-open',
    isActiveClass: 'is-active',

    openMobileNav: function() {
        if (typeof(FDX.DROPDOWN) !== 'undefined') {
            FDX.DROPDOWN.closeAllDropdowns();
            FDX.DROPDOWN.showOverlay();
        }
        $('#' + FDX.GLOBALNAV.mobileMenuBtnId).addClass(FDX.GLOBALNAV.isActiveClass);
        $('.' + FDX.GLOBALNAV.wrapperClass).addClass(FDX.GLOBALNAV.wrapperOpenClass);
        $($('#' + FDX.GLOBALNAV.mobileMenuBtnId)["0"].children["0"].children["0"]).text('Close')


    },

    closeMobileNav: function() {
        $('#' + FDX.GLOBALNAV.mobileMenuBtnId).removeClass(FDX.GLOBALNAV.isActiveClass);
        $('.' + FDX.GLOBALNAV.wrapperClass).removeClass(FDX.GLOBALNAV.wrapperOpenClass);
        $($('#' + FDX.GLOBALNAV.mobileMenuBtnId)["0"].children["0"].children["0"]).text('Menu')

        // For IOS 11, the pos is set to fixed on focus to any field in dropdown.
        // Resetting pos back to none once navigation is closed.
        $('html, body').css('position', '');
    },
}

function schLoadTracking() {
    var trackNum = document.getElementById('fxg-search-text').value;
    var trackUrl = document.getElementById("fxg-track-url").value;
    var searchURL = document.getElementById("fxg-search-url").value;
    trackNum = trackNum.trim();
    var key_country = FDX.DATALAYER.page.country;
    if (typeof(key_country) !== 'undefined') {
        key_country = 'us';
    }
    var isDtTrackNum = false;
    var dt_trackNum = trackNum.replace(/ /g, "");
    //Oct16: check if the query parameter is door tag number 
    if (dt_trackNum.slice(0, 2).toLowerCase() == "dt" && $.isNumeric(dt_trackNum.slice(2)) && dt_trackNum.slice(2).length == 12) {
        isDtTrackNum = true;
    }

    /*
     * For Cloud apps and other apps not running on the assumed host
     * If normal host is not used FDX_HOSTNAME will need to be set before including the header.
     * Usecase - Cloud apps development environments.
     */
    var FDX_HOSTNAME = FDX_HOSTNAME || "",
        host = window.location.host;
    if (FDX_HOSTNAME !== "") {
        host = FDX_HOSTNAME;
    }
    //check if the query parameter have a numeric of 5 to 30 digits
    var cusTrackUrl = encodeURI("https://" + host + trackUrl + "?action=track&tracknumbers=" + trackNum + "&cntry_code=" + key_country + "&wsch=true");
    if (isDtTrackNum || ($.isNumeric(trackNum)) && (trackNum.length < 30) && (trackNum.length > 5)) {
        if (trackUrl == "" || trackUrl == "#") {
            window.location = encodeURI("https://" + host + "/apps/fedextrack/?action=track&tracknumbers=" + trackNum + "&cntry_code=" + key_country + "&wsch=true");
        } else {
            window.location = cusTrackUrl;
        }
    } else {
        FDX.DTM.updateSearchTerm();
        //	window.location.href=FDX.contextPath
        //  +'/content/fedex-com/sites/us/en_us/search.html?q=' +
        //  trackNum;
        if (trackNum !== '') {
            //trackNum='+';
            var cusSearchUrl = encodeURI(window.location.protocol + '//' + host + '/' + FDX.DATALAYER.page.pageInfo.language + '-' + FDX.DATALAYER.page.pageInfo.country + '/' + searchURL + '?q=' + trackNum + '&cc=' + FDX.DATALAYER.page.pageInfo.locale);
            if (searchURL == "" || searchURL == "#") {
                window.open(encodeURI(window.location.protocol + '//' + host + '/' + FDX.DATALAYER.page.pageInfo.language + '-' + FDX.DATALAYER.page.pageInfo.country + '/search.html?q=' + trackNum + '&cc=' + FDX.DATALAYER.page.pageInfo.locale), '_self');
            } else {
                window.location = cusSearchUrl;
            }
        }
    }
}


$(document).ready(function() {
    $('#' + FDX.GLOBALNAV.mobileMenuBtnId).on('click', function(e) {

        if ($(this).hasClass(FDX.GLOBALNAV.isActiveClass)) {
            if ($('.' + FDX.UTILNAV.searchResultsClass).hasClass(FDX.UTILNAV.searchResultsShowClass)) {
                $('.' + FDX.UTILNAV.searchResultsClass).removeClass(FDX.UTILNAV.searchResultsShowClass);
            }
            FDX.GLOBALNAV.closeMobileNav();
            FDX.DROPDOWN.hideOverlay();
        } else {
            FDX.GLOBALNAV.openMobileNav();
            FDX.DROPDOWN.showOverlay();
        }
    });
    //for global search 
    $('#fxg-search-header').on('submit', function(e) {
        e.preventDefault();
        schLoadTracking();

    });

    $('#fxg-search-icon').click(function(e) {
        schLoadTracking();
        //FDX.DTM.updateSearchTerm();	
    });



});
/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * Hello World
         *
         * This component is created for demonstration purpose
         */
        (function($, _, $fetch, $session) {
            window.FDX.components.geolocator = function() {
                /**
                 * @type {Object[]} list of instances
                 */
                var instances = [];
                /**
                 * @type {string} root selector
                 */

                var selector = 'fedex-geo-locator';
                /**
                 * @type {string} service path
                 */

                var servicePath = '/etc/services/geolocator';
                /**
                 * Cookies
                 */

                var GEO_COOKIE_XACC = 'xacc';
                var GEO_COOKIE_SELECT = 'fdx_geo_select';
                var GEO_COOKIE_HIDE = 'fdx_geo_hide';
                /**
                 * CSS classnames
                 */

                var GEO_CLASS_BUTTON_LABEL = 'fxg-geo-locator__button-label';
                var GEO_CLASS_COUNTRY_URL = 'fxg-geo-locator__country-url';
                var GEO_CLASS_FOCUS = 'fxg-geo-locator__focus';
                var GEO_CLASS_ITEM = 'fxg-geo-locator__link';
                var GEO_CLASS_LINK = 'fxg-geo-locator__link-anchor';
                var GEO_CLASS_LINK_LABEL = 'fxg-geo-locator__link-label';
                var GEO_CLASS_MODAL_CLOSE = 'js-modal-close';
                /**
                 * Collections of classnames
                 */

                var GEO_CLASSES_BUTTON_LINK_PHYSICAL = 'fxg-geo-locator__button cc-aem-c-button cc-aem-c-button--primary';
                var GEO_CLASSES_BUTTON_LINK_LOGICAL = 'fxg-geo-locator__button cc-aem-c-button cc-aem-c-button--primary-outline';
                /**
                 * Data attributes
                 */

                var GEO_DATA_COUNTRY_CODE = 'data-country-code';
                /**
                 * Get current page locale
                 *
                 * @private
                 * @return {string} current locale, e.g. 'en_us'
                 */

                function pageLocale() {
                    return FDX.DATALAYER.page.pageInfo.locale;
                }
                /**
                 * Get current page country
                 *
                 * @private
                 * @return {string} current country, e.g. 'us'
                 */


                function pageCountry() {
                    return FDX.DATALAYER.page.pageInfo.country;
                }
                /**
                 * Get current user country based on cookie set by Akamai
                 *
                 * @private
                 * @return {string} current country, e.g. 'US'
                 */


                function userCountry() {
                    var _$session$getCookie;

                    var country = (_$session$getCookie = $session.getCookie(GEO_COOKIE_XACC)) === null || _$session$getCookie === void 0 ? void 0 : _$session$getCookie.toLowerCase();
                    return country;
                }
                /**
                 * Check if we can show the geolocator
                 *
                 * @private
                 * @return {boolean} can be shown or not
                 */


                function canBeShown() {
                    // if already closed by user in this session for current page country, we wont bother the user again
                    var closedInCountry = $session.getCookie(GEO_COOKIE_HIDE);
                    if (closedInCountry === pageCountry()) return false; // if user has already opted for the current page country we wont show

                    var optedCountry = $session.getCookie(GEO_COOKIE_SELECT);
                    if (optedCountry === pageCountry()) return false; // if user country differs from page country we will show

                    var canBeShown = userCountry() !== pageCountry();
                    return canBeShown;
                }
                /**
                 * Get API path
                 *
                 * @private
                 * @return {string} api path, e.g. '/etc/services/geolocator.us.en_us./en-us/home.html.jsonp'
                 */


                function getApiPath() {
                    // get current user country code based on cookie set by Akamai
                    var country = userCountry();
                    if (!country) return null; // compose path

                    var path = servicePath + '.' + country + '.' + pageLocale() + '.' + window.location.pathname + '.jsonp';
                    return path;
                }
                /**
                 * Fetch the GEO config from the API
                 *
                 * @private
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function fetchConfig() {
                    // get path
                    var promise = $.Deferred();
                    var path = getApiPath();

                    if (!path) {
                        promise.reject();
                        return promise;
                    } // fetch


                    $fetch.ajax(path).then(function(config) {
                        promise.resolve(config);
                    });
                    return promise;
                }
                /**
                 * Create component instance
                 *
                 * @public
                 * @return {Object} instance
                 */


                function create() {
                    /**
                     * @type {Object} configuration
                     */
                    var config = {};
                    /**
                     * @type {Object} jQuery DOM root element
                     */

                    var $root = null;
                    /**
                     * @type {Object} FDX.MODAL instance
                     */

                    var modal;
                    /**
                     * Set configuration
                     *
                     * @public
                     * @param {Object} _config - key/value pair
                     * @return {Object} instance
                     */

                    function setConfig(_config) {
                        var defaultConfig = {
                            globalAnalyticsText: '',
                            enableGeoModal: '',
                            globallocationurl: '',
                            globalLocationAriaLabel: '',
                            description: '',
                            globalLocation: '',
                            title: '',
                            physical: {},
                            logical: {},
                            locales: []
                        };
                        config = $.extend({}, defaultConfig, _config);
                        processLocales();
                    }
                    /**
                     * Populate locale links in config
                     */


                    function processLocales() {
                        config.locales.push(processLocale(config.physical, 'physical'));
                        config.locales.push(processLocale(config.logical, 'logical'));
                    }
                    /**
                     * Populate locale data
                     *
                     * @param {Object} locale - the locale object from the API response
                     * @param {string} type - the type of locale (physical or logical location)
                     * @return {Object} processed locale data object
                     */


                    function processLocale(locale, type) {
                        var defaultLanguage = locale.defaultLanguage ? locale.defaultLanguage : '';
                        var processedLanguages = []; // Process languages

                        locale.language.map(function(language) {
                            var languageData = {
                                defaultLanguage: defaultLanguage,
                                language: language,
                                type: type
                            };
                            var processedLanguage = processLanguage(languageData);

                            if (processedLanguage.code === defaultLanguage) {
                                // Move language to first position in array to render it as tge first language
                                processedLanguages.unshift(processedLanguage);
                            } else {
                                processedLanguages.push(processedLanguage);
                            }
                        }); // Set up data object to use in template

                        var localeData = {
                            countryCode: locale.countryCode,
                            countryName: locale.countryName,
                            defaultLanguage: defaultLanguage,
                            languages: processedLanguages,
                            type: type
                        };
                        return localeData;
                    }
                    /**
                     * Populate process language
                     *
                     * @param {object} languageData - unprocessed language data
                     * @return {object} processed lanugage data object
                     */


                    function processLanguage(languageData) {
                        var language = languageData.language;
                        var type = languageData.type;
                        var processedLanguage = {
                            ariaLabel: language.name,
                            analyticsText: language.analyticsText,
                            text: language.name,
                            code: language.languageCode,
                            linkType: 'link',
                            // link by default
                            classes: {
                                item: GEO_CLASS_ITEM,
                                link: GEO_CLASS_LINK,
                                label: GEO_CLASS_LINK_LABEL
                            },
                            url: language.url
                        }; // Set button link data

                        if (language.languageCode === languageData.defaultLanguage) {
                            processedLanguage.classes = {}; // reset defaults

                            processedLanguage.classes.label = GEO_CLASS_BUTTON_LABEL;
                            processedLanguage.linkLabel = '';
                            processedLanguage.linkType = 'button'; // Add button variation based on locale type

                            if (type === 'physical') {
                                processedLanguage.classes.link = GEO_CLASSES_BUTTON_LINK_PHYSICAL;
                            } else if (type === 'logical') {
                                processedLanguage.classes.link = GEO_CLASSES_BUTTON_LINK_LOGICAL;
                            }
                        }

                        return processedLanguage;
                    }
                    /**
                     * Render HTML
                     *
                     * @private
                     * @return {Promise<string>} A promise that resolves with rendered HTML
                     */


                    function render() {
                        var promise = $.Deferred();
                        var html = "\n          <div class=\"fxg-geo-locator\">\n            <div class=\"fxg-geo-locator__body\">\n              <p class=\"fxg-geo-locator__focus\" tabindex=\"0\">focus</p>\n              <h3 class=\"fxg-geo-locator__title\"><%= title %></h3>\n              <p class=\"fxg-geo-locator__description\"><%= description %></p>\n              <div class=\"fxg-geo-locator__countries\">\n                <% // Loop through locales %>\n                <% _.each(locales, function(locale) { %>\n                  <div class=\"fxg-geo-locator__country\">\n                    <h4 class=\"fxg-geo-locator__country-title\"><%= locale.countryName %></h4>\n                    <ul class=\"fxg-geo-locator__country-list\">\n                      <% // Loop through languages %>\n                      <% _.each(locale.languages, function(language) { %>\n                        <li class=\"<%= language.classes.item %> fxg-geo-locator__country-list-item\">\n                          <a class=\"<%= language.classes.link %> fxg-geo-locator__country-url\" href=\"<%= language.url %>\" data-analytics=\"link|<%= language.analyticsText %>\" onclick=\"FDX.DTM.pushLinkInfo(this)\" data-country-code=\"<%= locale.countryCode %>\"  aria-label=\"<%= language.ariaLabel %>\">\n                            <span class=\"<%= language.classes.label %>\"><%= language.text %><span>\n                          </a>\n                        </li>\n                      <% }); %>\n                    </ul>\n                  </div>\n                <% }); %>\n              </div>\n              <p>\n                <% // The link to the overview of countries %>\n                <a class=\"fxg-geo-locator__global-link\" href=\"<%= globallocationurl %>\" data-analytics=\"link|<%= globalAnalyticsText %>\" onclick=\"FDX.DTM.pushLinkInfo(this); FDX.SESSION.removeRedirectCookie();\" aria-label=\"<%= globalLocationAriaLabel %>\"><%= globalLocation %></a>\n              </p>\n            </div>\n          </div>\n        ";

                        var rendered = _.template(html)(config);

                        return promise.resolve(rendered);
                    }
                    /**
                     * Bind interactions events
                     *
                     * @private
                     */


                    function bindInteractions() {
                        // Handle click on country links
                        $root.find('.' + GEO_CLASS_COUNTRY_URL + '[' + GEO_DATA_COUNTRY_CODE + ']').on('click', function() {
                            var country = $(this).attr(GEO_DATA_COUNTRY_CODE);
                            selectCountry(country);
                        }); // Handle click on modal close button

                        modal.getElement().on('click', '.' + GEO_CLASS_MODAL_CLOSE, function() {
                            hide();
                        });
                    }
                    /**
                     * Initialize component instance
                     *
                     * @public
                     * @param {Object} [_$root] - component root element (optional)
                     * @return {Promise} A promise that resolves when instance is initiated
                     */


                    function init(_$root) {
                        var promise = $.Deferred(); // create DOM element

                        render().then(function(html) {
                            $root = $(html);
                            modal = FDX.MODAL.init()();
                            modal.set($root);
                            show();
                            bindInteractions();
                            setFocus(); // initialized

                            $root.data('initialized', true);
                            promise.resolve();
                        });
                        return promise;
                    }
                    /**
                     * Get component element
                     *
                     * @public
                     * @return {Object} jQuery DOM element
                     */


                    function getElement() {
                        return $root;
                    }
                    /**
                     * Shows the geolocator
                     *
                     * @param {Object} $container - jQuery DOM container element
                     * @public
                     */


                    function show($container) {
                        // open modal
                        modal.open();
                    }
                    /**
                     * Hides the geolocator
                     *
                     * @public
                     */


                    function hide() {
                        // close modal
                        modal.close(); // sets a cookie to remember in which page country geolocator was closed
                        // by the user so we wont bother the user for this page country any more

                        $session.setCookie(GEO_COOKIE_HIDE, pageCountry());
                    }
                    /**
                     * Set focus
                     */


                    function setFocus() {
                        var $focusElement = $root.find('.' + GEO_CLASS_FOCUS);
                        setTimeout(function() {
                            $focusElement.focus();
                        }, 500);
                    }
                    /**
                     * Remember the selected country by setting a cookie
                     *
                     * @public
                     * @param {string} country - country code
                     */


                    function selectCountry(country) {
                        // sets a cookie to remember the selected country (expires in 30 days)
                        $session.setCookie(GEO_COOKIE_SELECT, country, 30);
                    } // add and return instance


                    var instance = {
                        setConfig: setConfig,
                        init: init,
                        getElement: getElement,
                        show: show,
                        hide: hide,
                        selectCountry: selectCountry
                    }; // pass private attributes and methods to jest

                    if (typeof jest !== 'undefined') {
                        pageLocale = jest.fn(pageLocale);
                        pageCountry = jest.fn(pageCountry);
                        userCountry = jest.fn(userCountry);
                        canBeShown = jest.fn(canBeShown);
                        getApiPath = jest.fn(getApiPath);
                        fetchConfig = jest.fn(fetchConfig);
                        bindInteractions = jest.fn(bindInteractions);
                        show = jest.fn(show);
                        hide = jest.fn(hide);
                        setFocus = jest.fn(setFocus);
                        selectCountry = jest.fn(selectCountry);

                        instance.$private = function() {
                            return {
                                pageLocale: pageLocale,
                                pageCountry: pageCountry,
                                userCountry: userCountry,
                                canBeShown: canBeShown,
                                getApiPath: getApiPath,
                                fetchConfig: fetchConfig,
                                bindInteractions: bindInteractions,
                                show: show,
                                hide: hide,
                                setFocus: setFocus,
                                selectCountry: selectCountry
                            };
                        };
                    }

                    instances.push(instance);
                    return instance;
                }
                /**
                 * Create instances
                 *
                 * @public
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function createInstances() {
                    var promise = $.Deferred();
                    var initPromises = []; // does container exist, and can geolocator be shown?

                    var $container = $(selector);

                    if (!$container.length || !canBeShown()) {
                        promise.reject();
                        return promise;
                    } // fetch config


                    fetchConfig().then(function(config) {
                        // create instance
                        var instance = FDX.components.geolocator.create();
                        instance.setConfig(config); // initialize

                        instance.init().then(function() {
                            promise.resolve();
                        });
                    });
                    return promise;
                } // return component


                return {
                    create: create,
                    instances: instances,
                    createInstances: createInstances,
                    selector: selector
                };
            }();
        })(jQuery, _, FDX.services.fetch, FDX.services.session);

        /***/
    }),
    /* 2 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // extracted by mini-css-extract-plugin


        /***/
    })
    /******/
]);

/* This is the FedEx.com Footer component javascript file.
The global FDX object must already be defined

Author: quantrell.sanford@vml.com
Created: 2017-05-9
*/
if (!FDX) {
    var FDX = {};
}


FDX.FOOTER = {
    socialClass: ".fxg-footer__social",
    socialInnerClass: "fxg-footer__social-inner",
    socialWrapperClass: "fxg-footer__social-wrapper",
    socialIndicatorClass: "fxg-footer__social-indicator",
    leftIndicatorClass: "fxg-footer__social-indicator--left",
    rightIndicatorClass: "fxg-footer__social-indicator--right",
    footerClass: ".fxg-footer",
    aemLinkClass: ".icon_link",
    wrapperSize: 0,
    socialSize: 0,
    rightToLeftValue: "" + $('#footerIconRtl').val() + "",

    showLeftIndicator: function() {
        //contolled by z-index because it is layered
        $('.' + FDX.FOOTER.leftIndicatorClass).css('z-index', '2');
    },
    hideLeftIndicator: function() {
        $('.' + FDX.FOOTER.leftIndicatorClass).css('z-index', '-1');
    },
    showRightIndicator: function() {
        $('.' + FDX.FOOTER.rightIndicatorClass).css('display', 'inline-flex');
    },
    hideRightIndicator: function() {
        $('.' + FDX.FOOTER.rightIndicatorClass).css('display', 'none');
    },
    mobileBreakpointChanged: function(mq) {
        if (mq.matches) {
            //Wrap
            $(FDX.FOOTER.footerClass + ' ' + FDX.FOOTER.socialClass + ' .' + FDX.COLUMN_CONTROL.columnClass).each(function(i, e) {
                $(e).find(FDX.FOOTER.aemLinkClass)
                    .wrapAll("<div class='" + FDX.FOOTER.socialWrapperClass + "' />")
                    .wrapAll("<div class='wrap' />")
                    .wrapAll("<div class='" + FDX.FOOTER.socialInnerClass + "' />");
            });

            var left;
            var right;
            //Add indicators
            if (FDX.FOOTER.rightToLeftValue !== "true") {
                left = '<div class="' + FDX.FOOTER.socialIndicatorClass + ' ' + FDX.FOOTER.leftIndicatorClass + '">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="22" viewBox="0 0 12 22"><desc>  Created with Sketch.</desc><g fill="none"><g style="stroke-width:2;stroke:#333333"><polyline transform="translate(-291 -317)translate(0 284.5)translate(297 43.89421)rotate(-90)translate(-297 -43.89421)" points="287 39 297.1 48.8 307 39.1"/></g></g></svg>' +
                    '</div>';
                right = '<div class="' + FDX.FOOTER.socialIndicatorClass + ' ' + FDX.FOOTER.rightIndicatorClass + '">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="22" viewBox="0 0 12 22"><desc>  Created with Sketch.</desc><g fill="none"><g style="stroke-width:2;stroke:#333333"><polyline transform="translate(-291 -317)translate(0 284.5)translate(297 43.89421)rotate(-90)translate(-297 -43.89421)" points="287 39 297.1 48.8 307 39.1"/></g></g></svg>' +
                    '</div>';
            } else {
                left = '<div class="' + FDX.FOOTER.socialIndicatorClass + ' ' + FDX.FOOTER.leftIndicatorClass + '">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="22" viewBox="0 0 12 22"><desc>  Created with Sketch.</desc><g fill="none"><g style="stroke-width:2;stroke:#333333"><polyline transform="translate(-291 -317)translate(0 284.5)translate(297 43.89421)rotate(90)translate(-297 -43.89421)" points="287 39 297.1 48.8 307 39.1"/></g></g></svg>' +
                    '</div>';
                right = '<div class="' + FDX.FOOTER.socialIndicatorClass + ' ' + FDX.FOOTER.rightIndicatorClass + '">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="22" viewBox="0 0 12 22"><desc>  Created with Sketch.</desc><g fill="none"><g style="stroke-width:2;stroke:#333333"><polyline transform="translate(-291 -317)translate(0 284.5)translate(297 43.89421)rotate(90)translate(-297 -43.89421)" points="287 39 297.1 48.8 307 39.1"/></g></g></svg>' +
                    '</div>';

            }
            $('.' + FDX.FOOTER.socialWrapperClass).after(right).before(left);

            //set variables for calculations
            FDX.FOOTER.wrapperSize = $('.' + FDX.FOOTER.socialWrapperClass).width() - 10;
            $('.' + FDX.FOOTER.socialInnerClass).children().width(function(i, w) {
                FDX.FOOTER.socialSize += w;
            });
        } else {
            //Unwrap
            if ($(FDX.FOOTER.footerClass + ' ' + FDX.FOOTER.socialClass + ' ' + FDX.FOOTER.aemLinkClass).parent().hasClass(FDX.FOOTER.socialInnerClass)) {
                $(FDX.FOOTER.footerClass + ' ' + FDX.FOOTER.socialClass + ' ' + FDX.FOOTER.aemLinkClass).unwrap().unwrap().unwrap();
            }

            $('.' + FDX.FOOTER.leftIndicatorClass).remove();
            $('.' + FDX.FOOTER.rightIndicatorClass).remove();
        }
    },
    iconFocusCheck: function() {
        var parentElement = $('.' + FDX.FOOTER.socialInnerClass).children();
        if (this === parentElement[5]) {
            FDX.FOOTER.hideRightIndicator();
            FDX.FOOTER.showLeftIndicator();
            $('.' + FDX.FOOTER.socialInnerClass).css('left', '-239px');
        } else if (this === parentElement[4]) {
            $('.' + FDX.FOOTER.socialInnerClass).css('left', '-158px');
            $('.' + FDX.FOOTER.socialInnerClass).animate({
                right: 0
            }, 50);
        } else if (this === parentElement[3]) {
            $('.' + FDX.FOOTER.socialInnerClass).css('left', '-79px');
        } else if ((this === parentElement[2]) || (this === parentElement[1]) ||
            (this === parentElement[0])) {
            $('.' + FDX.FOOTER.socialInnerClass).css('left', '0px');
            FDX.FOOTER.showRightIndicator();
            FDX.FOOTER.hideLeftIndicator();
        }
    },
    indicatorCheck: function() {
        if (FDX.FOOTER.socialSize < FDX.FOOTER.wrapperSize) {
            $('.' + FDX.FOOTER.rightIndicatorClass).hide();
            FDX.FOOTER.hideRightIndicator();
        } else if ($(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
            $('.' + FDX.FOOTER.rightIndicatorClass).css('display', '');
            FDX.FOOTER.showRightIndicator();
        }
    }
}

$(document).ready(function() {
    var startX = -1;

    document.body.addEventListener("touchmove", handleMove, false);
    document.body.addEventListener("touchstart", handleStart, false);

    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.FOOTER.mobileBreakpointChanged);
    FDX.FOOTER.mobileBreakpointChanged(FDX.BREAKPOINTS.getMobileMediaQuery());
    $(FDX.FOOTER.aemLinkClass).keydown(function(e) {
        if (e.which === 9) {
            FDX.FOOTER.iconFocusCheck();
        }
    });
    $('.' + FDX.FOOTER.leftIndicatorClass).on('click', function() {
        if (FDX.FOOTER.rightToLeftValue !== "true") {
            $('.' + FDX.FOOTER.socialInnerClass).animate({
                left: 0
            }, 250);
        } else {
            $('.' + FDX.FOOTER.socialInnerClass).animate({
                right: 0
            }, 250);
        }
        FDX.FOOTER.showRightIndicator();
        FDX.FOOTER.hideLeftIndicator();
    });

    $('.' + FDX.FOOTER.rightIndicatorClass).on('click', function() {
        if (FDX.FOOTER.rightToLeftValue !== "true") {
            $('.' + FDX.FOOTER.socialInnerClass).animate({
                left: -(FDX.FOOTER.socialSize - FDX.FOOTER.wrapperSize)
            }, 250);
        } else {
            $('.' + FDX.FOOTER.socialInnerClass).animate({
                right: -(FDX.FOOTER.socialSize - FDX.FOOTER.wrapperSize)
            }, 250);
        }
        FDX.FOOTER.showLeftIndicator();
        FDX.FOOTER.hideRightIndicator();
    });

    $(window).on('resize', function() {
        FDX.FOOTER.wrapperSize = $('.' + FDX.FOOTER.socialWrapperClass).width() - 10;
        FDX.FOOTER.indicatorCheck();
    });

    function handleMove(evt) {
        if (startX >= 0) {

            if (FDX.FOOTER.socialSize < FDX.FOOTER.wrapperSize)
                return;

            var move = evt.changedTouches[0].pageX - startX;
            startX = evt.changedTouches[0].pageX;
            var position;
            if (FDX.FOOTER.rightToLeftValue !== "true") {

                position = parseInt($('.' + FDX.FOOTER.socialInnerClass).css('left')) + move || 0 + move;
            } else {
                position = parseInt($('.' + FDX.FOOTER.socialInnerClass).css('right')) - move || 0 + move;
            }

            if (position < -(FDX.FOOTER.socialSize - FDX.FOOTER.wrapperSize)) {
                position = -(FDX.FOOTER.socialSize - FDX.FOOTER.wrapperSize);
                FDX.FOOTER.hideRightIndicator();
                FDX.FOOTER.showLeftIndicator();
            } else if (position > 0) {
                position = 0;
                FDX.FOOTER.showRightIndicator();
                FDX.FOOTER.hideLeftIndicator();
            } else {
                FDX.FOOTER.showRightIndicator();
                FDX.FOOTER.showLeftIndicator();
            }
            if (FDX.FOOTER.rightToLeftValue !== "true") {
                $('.' + FDX.FOOTER.socialInnerClass).css('left', position + 'px');
            } else {
                $('.' + FDX.FOOTER.socialInnerClass).css('right', position + 'px');
            }

        }
    }

    function handleStart(evt) {
        if ($('.' + FDX.FOOTER.socialWrapperClass).length < 1)
            return;
        var elementBox = {};
        elementBox.top = $('.' + FDX.FOOTER.socialWrapperClass).offset().top;
        elementBox.bottom = $('.' + FDX.FOOTER.socialWrapperClass).offset().top + $('.' + FDX.FOOTER.socialWrapperClass).height();
        elementBox.left = $('.' + FDX.FOOTER.socialWrapperClass).offset().left;
        elementBox.right = $('.' + FDX.FOOTER.socialWrapperClass).offset().left + $('.' + FDX.FOOTER.socialWrapperClass).width();

        var touchX = evt.changedTouches[0].pageX;
        var touchY = evt.changedTouches[0].pageY;

        if ((touchX >= elementBox.left && touchX <= elementBox.right) &&
            (touchY >= elementBox.top && touchY <= elementBox.bottom) &&
            $(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
            startX = touchX;
        } else {
            startX = -1;
        }
    }

    (function() {
        /* to hide link focus ring for mouse interaction in footer*/
        var links = $('.fxg-copyright a');
        $(links).each(function(index, arrVal) {
            $(arrVal).addClass('fxg-keyboard');
            var content = $(arrVal).html();
            var span = '<span class="fxg-mouse" tabindex="-1">' +
                content + '</span>';
            $(arrVal).html(span);
        });
    })();
});
/**
 * ajax Service MODULE
 * fires ajax requests and avoids duplicate requests.
 */
(function($, _, window) {

    window.FDX = window.FDX || {};

    var fetchService = function() {

        // per url we will setup the service, since it could happen both urls are not the same...
        var deferred = {};
        var data = {};
        var xhr = {};

        // Default is JSON format.
        var $get = $.getJSON;

        function get(url, type) {
            if (type) {
                // other formats like html.
                $get = $.get;
            }

            // setup promise if not set allready
            if (!deferred[url]) {
                deferred[url] = $.Deferred();
            }

            if (data[url]) {
                // When we allready stored data we simply return this
                deferred[url].resolve(data[url]);
                return deferred[url];
            } else if (xhr[url]) {
                // When no data is set but request being made again (page and bar component on same page) we simply return xhr call
                return deferred[url];
            } else {
                // When checkig this service for the first time we will store it to xhr and return promise
                xhr[url] = $get(url)
                    .done(function(response) {
                        // we did succeed in retrieving any data
                        data[url] = response;
                        deferred[url].resolve(response);
                    })
                    .fail(function() {
                        // reject on error
                        deferred[url].reject();
                    });

                return deferred[url];

            }
        }

        // expose the service
        return {
            get: get
        };

    };


    // expose 'interimForms' module
    window.FDX.FetchService = fetchService();

}(window.jQuery, _, window));
/* This is the FedEx.com featured offer component javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-06-12
 Updated: 2017-08-09 (VMLNAFEDEXW-925)
 */

if (!FDX) {
    var FDX = {};
}

FDX.FEATUREDOFFER = {
    offerWrapperClass: '.fxg-featured-offer-wrapper',
    offerImageImageClass: '.fxg-featured-offer__detail-image .fxg-image',
    offerMainVideoClass: '.fxg-featured-offer__detail-image.fxg-main-video',
    offerMobileVideoClass: '.fxg-featured-offer__detail-image.fxg-mobile-video',

    setMainAsset: function() {
        $(FDX.FEATUREDOFFER.offerWrapperClass).each(function() {
            var $wrapper = $(this),
                $image = $wrapper.find(FDX.FEATUREDOFFER.offerImageImageClass);
            if ($image.length > 0) {
                var $imageWrapper = $image.parent();
                FDX.FEATUREDOFFER.setImage($image, $imageWrapper.attr('data-main-image'), $imageWrapper.attr('data-main-alt'));
            } else {
                $wrapper.find(FDX.FEATUREDOFFER.offerMainVideoClass).show();
                $wrapper.find(FDX.FEATUREDOFFER.offerMobileVideoClass).hide();
            }
        });
    },

    setMobileAsset: function() {
        $(FDX.FEATUREDOFFER.offerWrapperClass).each(function() {
            var $wrapper = $(this),
                $image = $wrapper.find(FDX.FEATUREDOFFER.offerImageImageClass);
            if ($image.length > 0) {
                var $imageWrapper = $image.parent();
                FDX.FEATUREDOFFER.setImage($image, $imageWrapper.attr('data-mobile-image'), $imageWrapper.attr('data-mobile-alt'));
            } else {
                $wrapper.find(FDX.FEATUREDOFFER.offerMainVideoClass).addClass(FDX.FEATUREDOFFER.offerMobileVideoClass);
                $wrapper.find(FDX.FEATUREDOFFER.offerMainVideoClass).show();
            }
        });
    },

    setImage: function($img, src, alt) {
        $img.attr('src', src);
        $img.attr('alt', alt);
        $img.show();
    },

    mobileBreakpointChange: function() {
        if ($(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
            FDX.FEATUREDOFFER.setMobileAsset();
        } else {
            FDX.FEATUREDOFFER.setMainAsset();
        }
    },

    desktopBreakpointChange: function() {
        if ($(document).width() > FDX.BREAKPOINTS.MobileMediaQuery) {
            FDX.FEATUREDOFFER.setMainAsset();
        } else {
            FDX.FEATUREDOFFER.setMobileAsset();
        }
    }
};

$(document).ready(function() {

    $(FDX.FEATUREDOFFER.offerMainVideoClass).hide();
    $(FDX.FEATUREDOFFER.offerMobileVideoClass).hide();
    $(FDX.FEATUREDOFFER.offerMainVideoClass).removeClass('fxg-hidden');
    $(FDX.FEATUREDOFFER.offerMobileVideoClass).removeClass('fxg-hidden');

    FDX.BREAKPOINTS.getMobileMediaQuery().addListener(FDX.FEATUREDOFFER.mobileBreakpointChange);
    FDX.FEATUREDOFFER.mobileBreakpointChange();

    FDX.BREAKPOINTS.getDesktopMediaQuery().addListener(FDX.FEATUREDOFFER.desktopBreakpointChange);
    FDX.FEATUREDOFFER.desktopBreakpointChange();

    //To show Image if Feature Offer is added through Target
    document.addEventListener('readystatechange', function(ev) {
        if (document.readyState === 'complete') {
            setTimeout(function() {
                if ((typeof(adobe) != 'undefined') && (typeof(adobe.target) != 'undefined') && (typeof(adobe.target.VERSION) != 'undefined')) {
                    if (FDX.BREAKPOINTS.viewPortType != 'smallViewPort') {
                        FDX.FEATUREDOFFER.desktopBreakpointChange();
                    } else {
                        FDX.FEATUREDOFFER.mobileBreakpointChange();
                    }
                }
            }, 300);
        }
    });
});
/* This is the FedEx.com expandable columns component javascript file.
 The global FDX object must already be defined.

 Author: quantrell.sanford@vml.com
 Created: 2017-03-27
 */
if (!FDX) {
    var FDX = {};
}

FDX.EXP_COLUMNS = {
    optionsClass: "fxg-expandable-cols",
    optionsItemClass: "fxg-expandable-cols__item",
    optionsItemInnerClass: "fxg-expandable-cols__item-inner",
    optionsItemContentClass: "fxg-expandable-cols__inner-right",
    optionsItemTitleClass: "fxg-expandable-cols__title",
    optionsItemOpenClass: "fxg-expandable-cols__item--open",
    optionsItemClosedClass: "fxg-expandable-cols__item--close",
    optionsCloseBtnClass: "fxg-expandable-cols__close",
    optionWrapperClass: "fxg-expandable-cols__wrapper",
    optionsWrapperCenteredClass: "fxg-expandable-cols__wrapper--centered",
    optionsItemOpenedWidth: 465,
    rightToLeftValue: "" + $('#expandableRtl').val() + "",
    optionsCloseOpenBtn: "fxg-expClsAriaLbl",


    // column refers to an element '.fxg-expandable-cols__item'
    expandColumn: function($column) {
        var closedWidth = $column.width();
        if (!$column.hasClass(FDX.EXP_COLUMNS.optionsItemOpenClass)) {
            //Close all open items
            $('.' + FDX.EXP_COLUMNS.optionsItemOpenClass).addClass(FDX.EXP_COLUMNS.optionsItemClosedClass).removeClass(FDX.EXP_COLUMNS.optionsItemOpenClass);
            $('.' + FDX.EXP_COLUMNS.optionsItemTitleClass).attr('aria-expanded', 'false');
            $('.' + FDX.EXP_COLUMNS.optionsCloseOpenBtn).attr('aria-expanded', 'false');
            //Open this item
            $column.removeClass(FDX.EXP_COLUMNS.optionsItemClosedClass).addClass(FDX.EXP_COLUMNS.optionsItemOpenClass);
            $column.find('.' + FDX.EXP_COLUMNS.optionsItemTitleClass).attr('aria-expanded', 'true');
            $column.find('.' + FDX.EXP_COLUMNS.optionsCloseOpenBtn).attr('aria-expanded', 'true');

            //if mobile, halt execution
            if ($(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
                $column.parent().css('transform', '');
                return;
            }

            //If item in position 3 or 4 of 4 items
            if ($column.index() > 1 && $column.siblings().length == 3) {
                var trans;
                if (FDX.EXP_COLUMNS.rightToLeftValue !== "true") {
                    trans = trans = "translateX(-" + (FDX.EXP_COLUMNS.optionsItemOpenedWidth - closedWidth) + "px)";
                } else {
                    trans = trans = "translateX(" + (FDX.EXP_COLUMNS.optionsItemOpenedWidth - closedWidth) + "px)";
                }
                $column.parent().css('transform', trans);
            } else {
                $column.parent().css('transform', '');
            }
        } else {
            // toggle expand/collapse - for accessibility
            FDX.EXP_COLUMNS.collapseColumn($column);
        }
    },

    // column refers to an element '.fxg-expandable-cols__item'
    collapseColumn: function($column) {
        if ($column.hasClass(FDX.EXP_COLUMNS.optionsItemOpenClass)) {
            $column.addClass(FDX.EXP_COLUMNS.optionsItemClosedClass).removeClass(FDX.EXP_COLUMNS.optionsItemOpenClass);
            $column.closest('.' + FDX.EXP_COLUMNS.optionWrapperClass).css('transform', '');
            $column.find('.' + FDX.EXP_COLUMNS.optionsItemTitleClass).attr('aria-expanded', 'false');
            $column.find('.' + FDX.EXP_COLUMNS.optionsCloseOpenBtn).attr('aria-expanded', 'false');
        } else {
            // toggle expand/collapse - for accessibility
            FDX.EXP_COLUMNS.expandColumn($column);
        }
    }
}

$(document).ready(function() {
    //If less then 4, add centered class
    $('.' + FDX.EXP_COLUMNS.optionsClass + ' .' + FDX.EXP_COLUMNS.optionWrapperClass).each(function(index) {
        if ($(this).children().length < 4) {
            $(this).addClass(FDX.EXP_COLUMNS.optionsWrapperCenteredClass);
        }
    });

    $('.' + FDX.EXP_COLUMNS.optionsItemClass).on('click', function(e) {
        if ($(e.target).is("a")) {
            // let links follow their natural flow
            return;
        }

        if ($(e.target).hasClass("fxg-expandable-cols__inner-left") ||
            $(e.target).closest(".fxg-expandable-cols__inner-left").length === 1) {
            FDX.EXP_COLUMNS.expandColumn($(this));
        }

    });

    // for accessibility
    $('.' + FDX.EXP_COLUMNS.optionsItemClass).on('keydown', function(e) {
        if (e.type === 'keydown' && e.which !== 13) {
            // if keydown, ignore other than 'enter'
            return;
        }

        if (!$(e.target).hasClass(FDX.EXP_COLUMNS.optionsItemTitleClass) &&
            !$(e.target).hasClass(FDX.EXP_COLUMNS.optionsCloseBtnClass) &&
            !$(e.target).hasClass(FDX.EXP_COLUMNS.optionsItemInnerClass)) {
            // discard 'enter' triggered from the above elements
            return;
        }
        FDX.EXP_COLUMNS.expandColumn($(this));
    });

    //  for accessibility - note the 'keydown' listener
    $('.' + FDX.EXP_COLUMNS.optionsClass + ' .' + FDX.EXP_COLUMNS.optionsCloseBtnClass).on('click keydown', function(e) {
        e.stopPropagation();
        if (e.type === 'keydown' && e.which !== 13) {
            // if keydown, ignore other than 'enter'
            return;
        }
        var $column = $(this).parents('.' + FDX.EXP_COLUMNS.optionsItemClass);
        FDX.EXP_COLUMNS.collapseColumn($column);
    });

    /* Set + icon inside expand/close button div */
    (function() {
        var expClsDivs = $('.fxg-expandable-cols__wrapper .fxg-expandable-cols__close-sign');
        $(expClsDivs).each(function(ind, arrVal) {
            $(arrVal).html('+');
        });
    })();

});
/* This is the FedEx.com Dynamic Table component javascript file.

 Author: troy.gottier.osv@fedex.com
 Created: 2018-04-17
 */
if (!FDX) {
    var FDX = {};
}
$(document).ready(function() {
    var dynamicTable = $(".fx-dt_dynamic_table");
    // Only proceed if there is a dynamic table to build.
    if (dynamicTable.length > 0) {
        // build each dynamic table found on page
        $.each(dynamicTable, function() {
            var dtData = $(this).find(".fx-dt_data"), // Data container
                dtData_api = $.trim(dtData.find(".fx-dt_api").text()), // API url
                dtData_useCustom = $.trim(dtData.find(".fx-dt_useCustom").text()), // check if using API or custom JSON
                dtData_customData = $.trim(dtData.find(".fx-dt_customData").text()), // Custom JSON
                dtHeadersDataVal = [], // The Json Headers
                dtHeadersDisplayVal = [], // What author wants each header called
                dtHeaders = headersToList($.trim(dtData.find(".fx-dt_headers").text())), // Author headers config			
                dtHeadersContainer = $(this).find("thead").find("tr"), // where to build out headers
                dtDataContainer = $(this).find("tbody"), // where to build out the data
                dtDisplayCount = parseInt($.trim(dtData.find(".fx-dt_displayCount").text())), // How many rows from your data to display
                dtRowToHighlight = $.trim(dtData.find(".fx-dt_highlight").text()), // The row of data that is highlighted and always displayed
                dtCellPadding = $.trim(dtData.find(".fx-dt_cssPadding").text()), // user setting of custom cell padding
                dtFontSize = $.trim(dtData.find(".fx-dt_fontSize").text()), // user setting of custom css
                dtCustomCSS = "";

            // check for custom cell padding 
            if (dtCellPadding != "") {
                dtCellPadding = "padding:" + dtCellPadding + "; ";
            }

            dtCustomCSS = "style='" + dtCellPadding + "font-size:" + dtFontSize + "px;'";

            // useCustom toggles API or custom JSON
            if (dtData_useCustom == "no") {
                // Use Api
                $.getJSON(dtData_api).done(function(data) {
                    dataToTable(data);
                }).fail(function(xhr, textStatus, errorThrown) {
                    errorHandler();
                });

            } else {
                // Use Custom JSON
                dataToTable(JSON.parse(dtData_customData));
            }

            function dataToTable(data) {
                if (data.length == 0) {
                    // No result data
                    errorHandler();
                    return false;
                }

                // if author didn't supply headers to use, use all the headers from the data
                // depending on data this is not going to give you very good table headers
                if (dtHeadersDataVal.length == 0) {
                    headersToList(getHeadersFromData(data[0]));
                }

                buildTableHeaders(dtHeadersContainer, dtHeadersDisplayVal); // build the table headers
                buildTableData(dtDataContainer, dtHeadersDataVal, data); // Build the table data
            }

            function headersToList(headerList) {
                // Take headers to display from dialog and convert to 2 lists
                // one being list of header title you want
                // other being a list of the header titles from data 
                if (headerList.length > 0) {
                    var list = headerList.split(",");
                    for (var i in list) {
                        if (list[i].indexOf(":") >= 0) {
                            dtHeadersDisplayVal.push($.trim(list[i].split(":")[0]));
                            dtHeadersDataVal.push($.trim(list[i].split(":")[1]));
                        } else {
                            dtHeadersDisplayVal.push($.trim(list[i]));
                            dtHeadersDataVal.push($.trim(list[i]));
                        }
                    }
                }
            }

            function buildTableData(container, headers, data) {
                // takes JSON data and build the table. Will only build columns of the headers the author choses.
                // Will only display number of rows that the author chose.
                var foundHighlight = false,
                    iterations = 0,
                    highlightField = $.trim(dtRowToHighlight.split(":")[0]),
                    highlightValue = $.trim(dtRowToHighlight.split(":")[1]);

                $.each(data, function(idx, val) {
                    // iterate through all data until the total to display is reached
                    if (iterations < dtDisplayCount) {
                        var html = '',
                            highlightClass = '';

                        $.each(headers, function(idx, header) {
                            // only create mark-up for the data that matched the headers to display
                            var dataValue = val[header];
                            if (dataValue == undefined) {
                                dataValue = "";
                            }
                            html += "<td " + dtCustomCSS + ">" + dataValue + "</td>";
                            if (val[highlightField] == highlightValue) {
                                foundHighlight = true;
                                highlightClass = "class='fx-dt_content_highlighted'";
                                //html += "<td " + dtCustomCSS + " class='fx-dt_content_highlighted'>" + dataValue + "</td>";
                            }
                        });
                        container.append("<tr " + highlightClass + ">" + html + "</tr>");
                        highlightClass = '';
                    } else {
                        // if the row to highlight was found - done - else keep going until you find it.
                        if (foundHighlight == true) {
                            // if row to highlight has been found stop parsing table data
                            return false;
                        }
                        var html = '';

                        $.each(headers, function(idx, header) {
                            var dataValue = val[header];
                            if (dataValue == undefined) {
                                dataValue = "";
                            }
                            if (val[highlightField] == highlightValue) {
                                foundHighlight = true;
                                html += "<td " + dtCustomCSS + ">" + dataValue + "</td>";
                            }
                        });

                        if (foundHighlight == true) {
                            // replace the last table row with the row to highlight.
                            dtDataContainer.children().last().remove();
                            container.append("<tr class='fx-dt_content_highlighted'>" + html + "</tr>");
                        }
                    }
                    iterations++;
                });
            }

            function buildTableHeaders(container, headers) {
                // create the mark up for table headers
                for (var i in headers) {
                    container.append("<th " + dtCustomCSS + ">" + $.trim(headers[i]) + "</th>")
                }
            }
        });
    }

    function getHeadersFromData(data) {
        // take user specified comma list and turn it into an array object list
        return Object.keys(data).join(",");
    }

    function errorHandler() {
        // if data fetching fails display an error
        dynamicTable.append("<span>Unable to display Data</span>");
    }
});
/* This is the FedEx.com dropdown component javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-03-13
 */
if (!FDX) {
    var FDX = {};
}

FDX.DROPDOWN = {
    dropdownClass: 'fxg-dropdown-js',
    openClass: 'fxg-dropdown__item--open',
    subMenuClass: 'fxg-dropdown__sub-menu',
    overlayClass: 'fxg-overlay',
    navClass: 'fxg-nav',
    headerClass: 'fxg-header',
    signInButtonClass: 'fxg-user-options__sign-in',
    bootstrapDropdownClass: 'fxg-bootstrap-dropdown',

    toggleDropdown: function(elem, e) {
        e.preventDefault();

        var isNavMobileMenuActive = $('.' + FDX.DROPDOWN.navClass).hasClass(FDX.GLOBALNAV.wrapperOpenClass);

        if ($(elem).parent().hasClass(FDX.DROPDOWN.openClass)) {
            $(elem).parent().removeClass(FDX.DROPDOWN.openClass);
            if (!isNavMobileMenuActive) {
                FDX.DROPDOWN.hideOverlay();
            }
        } else {
            FDX.DROPDOWN.closeAllDropdowns();
            $(elem).parent().addClass(FDX.DROPDOWN.openClass);
            $(elem).parent().find('#NavLoginUserId').focus();
            FDX.DROPDOWN.showOverlay();
        }
    },

    closeAllDropdowns: function() {
        $('.' + FDX.DROPDOWN.openClass).removeClass(FDX.DROPDOWN.openClass);
        FDX.DROPDOWN.hideOverlay();
        if (!FDX.SESSION.userAuthenticated)
            FDX.LOGIN.loginResourceFun = "";
        // This will close the pre defined search options if opened.
        FDX.UTILNAV.hideResults();
        //IOS scroll in case not cleared from after it was set to 'fixed' by tracking module.
        $('html, body').css('position', '');
    },
    showOverlay: function() {
        if ($('.' + FDX.DROPDOWN.overlayClass).length == 0) {
            $('<div class="' + FDX.DROPDOWN.overlayClass + '"></div>').insertAfter('.' + FDX.DROPDOWN.navClass);
        }
    },
    hideOverlay: function() {
        $('.' + FDX.DROPDOWN.overlayClass).remove();
    },
    //adjustDropdown Tab adjust the Tab Press for Dropdown in Header for ADA comppliant.
    adjustDropdownTab: function() {
        var screenWidth = window.innerWidth;
        var ua = navigator.userAgent;
        var mobilePatt = /mobile/i;
        var isMobile = mobilePatt.test(ua);
        var headerHeight = $('.fxg-header').height(),
            windowHeight = $(window).innerHeight(),
            dropdownHeight = windowHeight - headerHeight;
        if (screenWidth > 992) {
            $(window).keyup(function(e) {
                if (e.which == 9 || e.keyCode == 9) {
                    if ($(".global_navigation").has(".fxg-nav--mobile-menu-open").length < 1) {
                        if ($('.' + FDX.DROPDOWN.subMenuClass).has($(':focus')).length < 1) {
                            FDX.GLOBALNAV.closeMobileNav();
                            FDX.DROPDOWN.closeAllDropdowns();
                        }
                    }
                }
            });


            /* Below If condition is removed to fix the problem for sign-up/search icons shifting down to the page while navigation*/

            //if(isMobile){
            // Bring back the position of Navigation list incase, the user change the view of screen.
            $(".fxg-dropdown.fxg-global-nav").insertAfter('.fxg-header__logo_wrapper');
            //}
            //Set height to auto for dropdown
            $('.' + FDX.DROPDOWN.subMenuClass).css({
                'height': 'auto',
                'overflow-y': ''
            });
        } else {
            // Changing position of Navigation list in order to keep the order correct after the Menu Btn.
            $(".fxg-dropdown.fxg-global-nav").insertAfter('.fxg-user-options .fxg-search');
            $(window).keyup(function(e) {
                if (e.which == 9 || e.keyCode == 9) {
                    if (($(".global_navigation").has(".fxg-nav--mobile-menu-open").length > 1) || window.innerWidth < 993) {
                        if (($(".fxg-dropdown__sub-menu").has($(":focus")).length < 1) &&
                            ($(".fxg-global-nav").has($(':focus')).length < 1) && ($(".fxg-search").has($(':focus')).length < 1)) {
                            FDX.GLOBALNAV.closeMobileNav();
                            FDX.DROPDOWN.closeAllDropdowns();
                        }
                    }
                }
            });
            //Make dropdown content scrollable when it has more content in it
            $('.' + FDX.DROPDOWN.subMenuClass).css({
                'height': '${dropdownHeight}' + 'px',
                'overflow-y': 'scroll'
            });
        }
    }
}

$(document).ready(function() {

    //Close dropdown when user tabs away
    FDX.DROPDOWN.adjustDropdownTab();

    $(window).resize(function() {
        FDX.DROPDOWN.adjustDropdownTab();
    });


    $('.' + FDX.DROPDOWN.dropdownClass).on('click', function(e) {
        FDX.DROPDOWN.toggleDropdown(this, e);
    });

    $(document).on('click touchend', function(e) {
        if ($(e.target).hasClass(FDX.DROPDOWN.overlayClass)) {
            FDX.GLOBALNAV.closeMobileNav();
            FDX.DROPDOWN.closeAllDropdowns();

            if (typeof(FDX.SECUREPAGECHECK) !== "undefined") {
                FDX.SECUREPAGECHECK.clearSessionStorage();
            }

        }
    });

    $('.' + FDX.DROPDOWN.signInButtonClass).on('click', function(e) {
        if ($(document).width() <= FDX.BREAKPOINTS.TabletMediaQuery) {
            FDX.GLOBALNAV.closeMobileNav();
        }
    });

    $('.' + FDX.DROPDOWN.bootstrapDropdownClass + ' a').click(function(e) {
        e.preventDefault();
        var parent = $(this).parent();
        parent.addClass('active').siblings().removeClass('active');
        var selected = parent.parent().parent().find('.dropdown-toggle')
        $(selected).html($(this).html() + '<span class="fxg-icon"></span>');

        //In form, populate select option
        var select = $(parent).parent().siblings('select');
        if (select.length) {
            var value = $(this).attr('data-value');
            $(select).children().attr('selected', false).find('option[value="' + value + '"]').attr('selected', true);
        } else {
            window.location = $(this).attr('href');
        }
    });
});
/* This is the FedEx.com drawer component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-05-01
 */

if (!FDX) {
    var FDX = {};
}

FDX.DRAWER = {
    drawerClass: 'fxg-drawer',
    drawerContentClass: 'fxg-drawer__content',
    drawerOpenClass: 'fxg-drawer--open',
    drawerButtonClass: 'fxg-drawer__button',
    drawerCloseButtonClass: 'fxg-drawer__close-button',
    brightCovePlayControlClass: 'button.vjs-control.vjs-button.vjs-playing',
    kalturaVideoPlayControlClass: '.mwPlayerContainer .controlBarContainer .controlsContainer button.playPauseBtn',

    toggleDrawer: function(link, loc) {

        var $drawer = $(link).closest('.' + FDX.DRAWER.drawerClass);
        var imagePath = loc;

        $drawer.toggleClass(FDX.DRAWER.drawerOpenClass, function() {

            if ($drawer.hasClass(FDX.DRAWER.drawerOpenClass)) {
                // send focus to the first child
                var imgFirst = $drawer.find('.fxg-drawer-offer').children(":first").hasClass('fxg-drawer__detail-image') ? $drawer.find('.fxg-drawer-offer').children(":first") : false;
                var titleFirst = $drawer.find('.fxg-drawer-offer').children(":first").hasClass('fxg-drawer__detail') ? $drawer.find('.fxg-drawer-offer').children(":first") : false;

                if (imgFirst) { //if img is on left
                    $(imgFirst).attr('aria-live', 'polite');
                    var imgEleDrawer = $drawer.find('.fxg-drawer__detail-image').children(":first");
                    var altVal = $(imgEleDrawer).attr('alt');
                    if (altVal) { //if img is non-decorative
                        $(imgEleDrawer).focus();
                        setTimeout(function() {
                            $(imgEleDrawer).attr('aria-label', altVal + '.');
                        }, 500);
                        setTimeout(function() {
                            $(imgFirst).removeAttr('aria-live');
                            $(imgEleDrawer).removeAttr('aria-label');
                        }, 1000);
                    } else { //if img is decorative
                        FDX.DRAWER.titleFirst_drawer(imgFirst, titleFirst);
                    }

                } else if (titleFirst) { //if title is on left
                    FDX.DRAWER.titleFirst_drawer(imgFirst, titleFirst);
                }

                $drawer.css('background-image', imagePath);
                $drawer.css('background-color', $drawer.find(".fxg-drawer-layout-one").css('background-color'));
                $drawer.find('.fxg-drawer-layout-one').show('slow');
                if ($(this).css("display") == "inline" || $(this).css("display") == "none") return;
            }
        });
    },

    titleFirst_drawer: function(imgFirst, titleFirst) {
        var $drawer = $(link).closest('.' + FDX.DRAWER.drawerClass);
        if (imgFirst) { //if decorative img on left
            var titleContainer = $drawer.find('.fxg-drawer-offer').find('.fxg-drawer__detail');
            var title = $(titleContainer).children(":first");
            $(title).attr('aria-live', 'polite');
            setTimeout(function() {
                var titleVal = $(title).text();
                $(title).html(titleVal);
            }, 500);
            setTimeout(function() {
                $(title).focus();
                $(title).removeAttr('aria-live');
            }, 1000);
        } else if (titleFirst) { //if title on left
            var title = $(titleFirst).children(":first");
            $(title).attr('aria-live', 'polite');
            setTimeout(function() {
                var titleVal = $(title).text();
                $(title).html(titleVal);
            }, 500);

            setTimeout(function() {
                $(title).focus();
                $(title).removeAttr('aria-live');
            }, 1000);
        }
    }
};

$(document).ready(function() {

    /*Changes to drawer video component*/
    var image_location = '';

    if ($('.fxg-drawer').length == 0) {
        image_location = '';
    } else {
        var fxg_drawerClass = document.getElementsByClassName('fxg-drawer');
        image_location = fxg_drawerClass[0].style.backgroundImage;
        $('.' + FDX.DRAWER.drawerCloseButtonClass).bind("click", function() {
            $(this).closest('.fxg-drawer').css('background-image', 'none');
            var stage1BGClr = $(this).closest(".fxg-drawer").attr('data-color');
            if (stage1BGClr == 'default' || stage1BGClr == '') {
                $(this).closest(".fxg-drawer").css('background-color', '');
            } else {
                $(this).closest(".fxg-drawer").css('background-color', stage1BGClr);
            }
            $(this).closest('.fxg-drawer').find('.fxg-drawer-layout-one').hide();
            $(this).siblings('div.fxg-drawer__title-wrapper').children('a.fxg-drawer__button').focus();
        });

        if (!$('.fxg-drawer').hasClass(FDX.DRAWER.drawerOpenClass)) {
            $('.fxg-drawer').css('background-image', 'none');
        } else {
            $('.fxg-drawer').css('background-image', image_location);
            //  $(this).closest(".fxg-drawer").css('background-color',$(this).closest(".fxg-drawer-layout-one").css('background-color'));
        }

        $('.' + FDX.DRAWER.drawerButtonClass).on('click', function(event) {
            event.preventDefault();
            FDX.DRAWER.toggleDrawer(this, image_location);

        });

        $('.' + FDX.DRAWER.drawerCloseButtonClass).on('click keydown', function(e) {
            if (e.type === 'keydown') {
                return;
            }
            e.preventDefault();
            //stop playing video when click on close button
            if ($(this).prev().find('.brightcove-container .video-js').hasClass('vjs-playing')) {
                $(this).prev().find(FDX.DRAWER.brightCovePlayControlClass).click();
            };
            var iFrameContent = $(this).prev().find('.kWidgetIframeContainer.mavice-kp-player iframe').contents(),
                playPauseBtn = iFrameContent.find(FDX.DRAWER.kalturaVideoPlayControlClass);

            if (playPauseBtn.hasClass('icon-pause')) {
                playPauseBtn.click();
            }
            FDX.DRAWER.toggleDrawer(this, image_location);
        });
    }
});

/*
DATEPICKER
----------
Adds and removes a calendar view on date input fields using jQuery UI Datepicker widget.
The global FDX object must already be defined.

jQuery UI Datepicker Documentation: https://api.jqueryui.com/datepicker/
*/

if (!window.FDX) {
    window.FDX = {};
}

// PUBLIC MODULE
window.FDX.DATEPICKER = (function($, _, window) {
    'use strict';

    /**
     * datePicker Module
     *
     * Default's:
     * Max and Min dates will be configured in 'Day's
     * Sunday is start day of a week.
     * format: "dd/mm/yy"
     */
    var datePickerModule = function($element) {
        var $root = $element;
        var $dPicker = $root.find('.js-fxg-date-picker');
        var $config = $root.find('[data-config="js-localised-datepicker-config"]').html() || '';
        var applyRTL = $('html').attr('dir') === 'rtl' ? true : false;
        var isInitiated = false;

        if (!$config) {
            return;
        } else {
            var data = $config.replace(/\n|\r|\t/g, '');
            data = decodeURI(data.trim());
            $config = $.parseJSON(data);
        }

        // Set date picker configurations with default values
        var dpConfigs = {
            minDate: '0d',
            maxDate: '0d',
            dateFormat: 'dd/mm/yy',
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
            firstDay: 0
        };

        // fetch the data from configurations else set some default values.
        dpConfigs.monthNames = $.trim($config.monthNames) !== '' ? $config.monthNames.split(',') : dpConfigs.monthNames;
        dpConfigs.dayNamesMin = $.trim($config.dayShortNames) !== '' ? $config.dayShortNames.split(',') : dpConfigs.dayNamesMin;
        dpConfigs.firstDay = $config.weekFirstDay ? 1 : dpConfigs.firstDay;
        dpConfigs.minDate = $dPicker.data('minDate') ? '-' + $dPicker.data('minDate') + 'd' : dpConfigs.minDate;
        dpConfigs.maxDate = $dPicker.data('maxDate') ? '+' + $dPicker.data('maxDate') + 'd' : dpConfigs.maxDate;
        dpConfigs.dateFormat = $dPicker.data('dateFormat') ? $dPicker.data('dateFormat') : dpConfigs.dateFormat;

        // Set up date picker
        initCreate();

        // Re-initiate (or destroy) on orientation change (mobile only)
        $(window).on('orientationchange', function() {
            initCreate();
        });

        function initCreate() {
            var isMobile = /Android|webOS|iPhone|iPod|Opera Mini/i.test(navigator.userAgent);
            var isLandscape = window.matchMedia('(orientation: landscape)').matches;

            // Destroy datepicker if on mobile landscape mode
            if (isMobile && isLandscape) {
                // Destroy datepicker UI to prevent layout issues on mobile landscape
                if (isInitiated) {
                    destroy();
                }

                // Set keyboard focus on input field
                setFocus();

                // Initiate jQuery UI Datepicker if it has not yet been initiated
            } else if (!isInitiated) {
                initiate();
            }
        }

        function initiate() {
            $dPicker.datepicker({
                minDate: dpConfigs.minDate,
                maxDate: dpConfigs.maxDate,
                dateFormat: dpConfigs.dateFormat,
                monthNames: dpConfigs.monthNames,
                showAnim: '',
                autoSize: true,
                firstDay: dpConfigs.firstDay,
                dayNamesMin: dpConfigs.dayNamesMin,
                changeYear: true,
                yearRange: dpConfigs.minDate + ':' + dpConfigs.maxDate,
                isRTL: applyRTL,
                onSelect: function(dateText, dpInstance) {
                    // triggers the cms-c-form custom validation functionality from FDX.INTERIMFORM
                    $(this).blur();

                    // widget state, required for overriding the current selected date and today date hightlight (purple circular background) styles
                    $(dpInstance.dpDiv[0]).addClass('is-widget-created');
                },
                beforeShow: function(dpInput, dpInstance) {
                    // widget class name, required for overriding the widget styles
                    $(dpInstance.dpDiv[0]).addClass('fxg-date-picker-widget').attr('aria-hidden', 'true');
                }
            });

            isInitiated = true;
        }

        // Hide & destroy jQuery UI Datepicker
        function destroy() {
            $dPicker.datepicker('hide');
            $dPicker.datepicker('destroy');
            $dPicker.removeClass('hasDatepicker');
            $dPicker.unbind();
            isInitiated = false;
        }

        function setFocus() {
            // Set keyboard focus on datepicker input field ...
            $dPicker.focus(function() {
                // ... and clear the default value
                if ($dPicker.val() === 'DD/MM/YYYY' || $dPicker.val() === 'MM/DD/YYYY') {
                    $dPicker.val('');
                }
            });
        }
    };

    // INIT Component
    var initComponent = function($element) {
        return datePickerModule($element);
    };

    return {
        init: initComponent
    };
})(window.jQuery, _, window);

// initiate all component instances on DOM ready
$(document).ready(function() {
    var $components = $('.js-fxg-date-picker-wrapper');

    $components.each(function(index, component) {
        window.FDX.DATEPICKER.init($(component));
    });
});
/* This is the FedEx.com cube component javascript file.
 The global FDX object must already be defined

 Author: quantrell.sanford@vml.com
 Created: 2017-03-21
 */

if (!FDX) {
    var FDX = {};
}

FDX.CUBE = {
    cubeClass: 'fxg-cube',
    cubeContainerClass: 'fxg-cube-container',
    appClass: 'fxg-app-container',
    appWrapperClass: 'fxg-app__wrapper',
    openAppClass: 'fxg-app-container--open',
    appErrorClass: 'fxg-app-container--error',
    activeCubeClass: 'fxg-cube--active',
    cubeContentClass: 'fxg-cube__content',
    noCubeClass: 'fxg-app_nocube',
    noCubeTrackClass: 'tracking_app',
    appNoCubeResult: 'fxg-app_noCubeResult',
    appActiveClass: 'fxg-app--active',
    heroClass: 'fxg-hero',
    rateShipAppClass: 'rate_ship_app',

    isShippingCall: false,
    adminUrl: "",
    altUrl: "",
    activeCube: 2,
    cubeOneAdminUrl: "",
    cubeOneAltUrl: "",
    cubeTwoAdminUrl: "",
    cubeTwoAltUrl: "",
    cubeThreeAdminUrl: "",
    cubeThreeAltUrl: "",
    clientId: "",
    cubeOneclientId: "",
    cubeTwoclientId: "",
    cubeThreeclientId: "",

    cubeOneSecureClass: "fxg-cube__onesecure",
    cubeTwoSecureClass: "fxg-cube__twosecure",
    cubeThreeSecureClass: "fxg-cube__threesecure",
    cubeOneMboxid: "",
    cubeTwoMboxid: "",
    cubeThreeMboxid: "",
    fclPagePath: "",


    /*setValues : function(cube1AdminUrl,cube1AltUrl,cube2AdminUrl,cube2AltUrl,cube3AdminUrl,cube3AltUrl,cube1ClientID,cube2ClientID,cube3ClientID,Cube1Mbox,Cube2Mbox,Cube3Mbox,fclPage){


    	FDX.CUBE.cubeOneAdminUrl = cube1AdminUrl;
		FDX.CUBE.cubeOneAltUrl = cube1AltUrl;
		
		FDX.CUBE.cubeTwoAdminUrl = cube2AdminUrl;
		FDX.CUBE.cubeTwoAltUrl = cube2AltUrl;

		FDX.CUBE.cubeThreeAdminUrl = cube3AdminUrl;
		FDX.CUBE.cubeThreeAltUrl = cube3AltUrl;
		
		FDX.CUBE.cubeOneclientId = cube1ClientID;
		FDX.CUBE.cubeTwoclientId = cube2ClientID;
		FDX.CUBE.cubeThreeclientId = cube3ClientID;
		
		FDX.CUBE.cubeOneMboxid = Cube1Mbox;
		FDX.CUBE.cubeTwoMboxid = Cube2Mbox;
		FDX.CUBE.cubeThreeMboxid = Cube3Mbox;


        console.log("cube1 clientid -->"+FDX.CUBE.cubeOneclientId+"cube2 clientid -->"+FDX.CUBE.cubeTwoclientId+"cube3 clientid -->"+FDX.CUBE.cubeThreeclientId)

        FDX.CUBE.fclPagePath = fclPage;
		
    },*/


    setActiveCube: function(elem) {
        var linkUrl = $(elem).attr('data-link-path');
        var linkTarget = $(elem).attr('data-link-target');
        if (typeof linkUrl !== typeof undefined && linkUrl !== false && linkUrl != '') {
            if (typeof linkTarget == typeof undefined || linkTarget == false || linkTarget == '') {
                linkTarget = "_self";
            }
            window.open(linkUrl, linkTarget);
        } else {
            $('.' + FDX.CUBE.activeCubeClass).removeClass(FDX.CUBE.activeCubeClass);
            $("." + FDX.CUBE.appClass).removeClass(FDX.CUBE.appActiveClass);
            $(elem).addClass(FDX.CUBE.activeCubeClass);
            var cudeId = $(elem).attr('id');
            $('#' + cudeId + '-tab').addClass(FDX.CUBE.appActiveClass);

            /*if(!$('.'+FDX.CUBE.activeCubeClass).hasClass('notTarget')){


                $('.' + FDX.DROPDOWN.dropdownClass).trigger("click");

            }*/

            FDX.APPBASE.loadAppData();

            var isRateAppActive = $('.' + FDX.CUBE.appClass + '.' + FDX.CUBE.appActiveClass + ' .' + FDX.CUBE.rateShipAppClass).length > 0;
            if (isRateAppActive) {

                FDX.APPBASE.loadAppBaseData();
                if (!FDX.APPBASE.appThrottled) {
                    FDX.RATE_SHIP.loadRateShipScripts().done(function() {
                        if (window.top.location.href.indexOf('/editor.html/') < 0) {
                            setTimeout(function() {
                                FDX.RATE_SHIP.loadRateShipApp();
                                FDX.CUBE.openApp();
                            }, 200);
                        }

                    });
                }
            }
        }

        // add hero active cube class
        FDX.CUBE.activeCube = ($(elem).index() + 1);
        var cubeClass = 'fxg-hero--cube-' + FDX.CUBE.activeCube + '-active';
        $('.' + FDX.CUBE.heroClass).removeClass('fxg-hero--cube-1-active fxg-hero--cube-2-active fxg-hero--cube-3-active');
        $('.' + FDX.CUBE.heroClass).addClass(cubeClass);
    },

    setAppError: function() {
        $(' .' + FDX.CUBE.appClass + '.' + FDX.CUBE.appActiveClass).addClass(FDX.CUBE.appErrorClass);
    },

    openApp: function() {

        // add app open cube class
        $('.' + FDX.CUBE.appClass + '.' + FDX.CUBE.appActiveClass).addClass(FDX.CUBE.openAppClass);
        $('.' + FDX.CUBE.appClass + '.' + FDX.CUBE.noCubeClass).addClass(FDX.CUBE.openAppClass);

        // add hero open cube class
        var cubeClass = 'fxg-hero--cube-' + FDX.CUBE.activeCube + '-open';
        $('.' + FDX.CUBE.heroClass).addClass(cubeClass);

        // focus on first "multi-tracking input box"
        $('.fxg-tracking-app__multi-tracking div:nth-child(1) div input.fxg-field__input-text').focus();
    },

    closeApp: function() {

        // remove app open cube class
        $('.' + FDX.CUBE.appClass + '.' + FDX.CUBE.appActiveClass).removeClass(FDX.CUBE.openAppClass);
        $('.' + FDX.CUBE.appClass + '.' + FDX.CUBE.noCubeClass).removeClass(FDX.CUBE.openAppClass);

        // remove hero open cube class
        var cubeClass = 'fxg-hero--cube-' + FDX.CUBE.activeCube + '-open';
        $('.' + FDX.CUBE.heroClass).removeClass(cubeClass);
    },
    getTargetAttributes: function(targetInfoAttributes) {


        var targetinfo = targetInfoAttributes.split(",");

        var ev1 = {};
        for (var x = 0; x < targetinfo.length; x++) {
            var kv1 = targetinfo[x].split("|");

            if (kv1.length == 2) {
                var b = kv1[1];
                switch (kv1[0]) {
                    case "cubeOneAdminLinkPath":
                        FDX.CUBE.cubeOneAdminUrl = b;
                        break;
                    case "cubeOneAlternateLinkPath":
                        FDX.CUBE.cubeOneAltUrl = b;
                        break;
                    case "cubeTwoAdminLinkPath":
                        FDX.CUBE.cubeTwoAdminUrl = b;
                        break;
                    case "cubeTwoAlternateLinkPath":
                        FDX.CUBE.cubeTwoAltUrl = b;
                        break;
                    case "cubeThreeAdminLinkPath":
                        FDX.CUBE.cubeThreeAdminUrl = b;
                        break;
                    case "cubeThreeAlternateLinkPath":
                        FDX.CUBE.cubeThreeAltUrl = b;
                        break;
                    case "cubeOneClientId":
                        FDX.CUBE.cubeOneclientId = b;
                        break;
                    case "cubeTwoClientId":
                        FDX.CUBE.cubeTwoclientId = b;
                        break;
                    case "cubeThreeClientId":
                        FDX.CUBE.cubeThreeclientId = b;
                        break;
                    case "cubeOneMboxId":
                        FDX.CUBE.cubeOneMboxid = b;
                        break;

                    case "cubeTwoMboxId":
                        FDX.CUBE.cubeTwoMboxid = b;
                        break;
                    case "cubeThreeMboxId":
                        FDX.CUBE.cubeThreeMboxid = b;
                        break;
                    case "fclPagePath":
                        FDX.CUBE.fclPagePath = b;
                        break;
                }
            }
        }
    },
    checkSecureLink: function(elem, cubeClicked) {
        FDX.CUBE.getTargetAttributes($(elem).attr('data-target'));
        var isWlgnLink = FDX.DATALAYER.page.pageInfo.useWLGN;

        if (FDX.SESSION.targetRedirectAuth == false && FDX.SESSION.userAuthenticated == false) {

            if (isWlgnLink === "true") {
                window.open(FDX.DATALAYER.page.pageInfo.wlgnURL, '_self', '', true);
            } else {
                if ($(document).width() <= FDX.BREAKPOINTS.TabletMediaQuery) {
                    if (!$(elem).hasClass('notTarget')) {

                        $('.fxg-app-container').on('click', function(evt) {
                            evt.stopPropagation();
                        });
                        //$('.' + FDX.DROPDOWN.dropdownClass).trigger("click");
                        $('.fxg-user-options__option.fxg-user-options__sign-in').toggleClass('fxg-dropdown__item--open');
                        $('input#NavLoginUserId').focus();
                    }
                } else {
                    if (!$(elem).hasClass('notTarget')) {
                        $('.fxg-app-container').on('click', function(evt) {
                            evt.stopPropagation();
                        });
                        $('.' + FDX.DROPDOWN.dropdownClass).trigger("click");
                    }

                }


            }
        }

        if (cubeClicked == 1) {
            FDX.CUBE.adminUrl = FDX.CUBE.cubeOneAdminUrl;
            FDX.CUBE.altUrl = FDX.CUBE.cubeOneAltUrl;
            FDX.CUBE.mBoxID = FDX.CUBE.cubeOneMboxid;
            FDX.CUBE.clientId = FDX.CUBE.cubeOneclientId;

            if (FDX.CUBE.cubeOneclientId == "LSHP") {
                FDX.SESSION.cubeShippipng = true;
            } else if (FDX.CUBE.cubeOneclientId == "TRACK") { // yet to implement
                //FDX.CUBE.isTrackCall = true;;
            } else if (FDX.CUBE.cubeOneclientId == "LOCATIONS") { // yet to implement
                //FDX.CUBE.isLocationCall = true;
            }
        }

        if (cubeClicked == 2) {
            FDX.CUBE.adminUrl = FDX.CUBE.cubeTwoAdminUrl;
            FDX.CUBE.altUrl = FDX.CUBE.cubeTwoAltUrl;
            FDX.CUBE.mBoxID = FDX.CUBE.cubeTwoMboxid;
            FDX.CUBE.clientId = FDX.CUBE.cubeTwoclientId;
            if (FDX.CUBE.cubeTwoclientId == "LSHP") {
                FDX.SESSION.cubeShippipng = true;
            } else if (FDX.CUBE.cubeTwoclientId == "TRACK") { // yet to implement
                //FDX.CUBE.isTrackCall = true;
            } else if (FDX.CUBE.cubeTwoclientId == "LOCATIONS") { // yet to implement
                // FDX.CUBE.isLocationCall = true;
            }
        }
        if (cubeClicked == 3) {
            FDX.CUBE.adminUrl = FDX.CUBE.cubeThreeAdminUrl;
            FDX.CUBE.altUrl = FDX.CUBE.cubeThreeAltUrl;
            FDX.CUBE.mBoxID = FDX.CUBE.cubeThreeMboxid;
            FDX.CUBE.clientId = FDX.CUBE.cubeThreeclientId;

            if (FDX.CUBE.cubeThreeclientId == "LSHP") {
                FDX.SESSION.cubeShippipng = true;
            } else if (FDX.CUBE.cubeThreeclientId == "TRACK") { // yet to implement
                //FDX.CUBE.isTrackCall = true;
            } else if (FDX.CUBE.cubeThreeclientId == "LOCATIONS") { // yet to implement
                // FDX.CUBE.isLocationCall = true;
            }
        }

        //code changes for 528073 : Modify AEM code to call the new JS
        if (FDX.SHIPPINGROUTING) {
            FDX.SHIPPINGROUTING.setPaths(FDX.CUBE.adminUrl, FDX.CUBE.altUrl, FDX.CUBE.mBoxID, FDX.CUBE.fclPagePath, FDX.CUBE.clientId);
            FDX.SHIPPINGROUTING.setSecureClientId(true);
        }

        if (FDX.SESSION.targetRedirectAuth || FDX.SESSION.userAuthenticated) {
            // $('.fxg-user-options__option.fxg-user-options__sign-in').toggleClass('fxg-dropdown__item--open');
            //528073 : Modify AEM code to call the new JS
            if (FDX.SHIPPINGROUTING) {
                FDX.SHIPPINGROUTING.doAPIShipingUserisLoggedIn(elem);
            }
        } else {

            if (isWlgnLink === "true") {
                //WLGN is enabled
                window.open(FDX.DATALAYER.page.pageInfo.wlgnURL, '_self', '', true);
            } else {
                // FDX.LOGIN.setLoginResource("window.open('" + $(elem).attr("href") + "','" + $(elem).attr("target") + "','',true)");
                FDX.LOGIN.setLoginResource($(elem), 'OPEN')
                $('input#NavLoginUserId').focus();
            }
            /*   if ($(document).width() <= FDX.BREAKPOINTS.TabletMediaQuery){
               $('.fxg-user-options__option.fxg-user-options__sign-in').toggleClass('fxg-dropdown__item--open');
               $('input#NavLoginUserId').focus();

           }*/
        }

    },
    //retrieving the active cube data from session storage after user comes back to home page from WLGN login
    //called on window load 
    getAppInfo: function() {
        if (FDX.DATALAYER.page.pageInfo.useWLGN === "true" && sessionStorage.getItem("storeActiveCube") !== null) {
            var activeCube = document.getElementById(sessionStorage.getItem("storeActiveCube"));
            if (activeCube !== null) {
                if (sessionStorage.getItem("activeSingleTrackInput") === "true") {
                    FDX.TRACKING.showSingleTracking();
                }
                sessionStorage.removeItem("activeSingleTrackInput");
                if (sessionStorage.getItem("activeMultiTrackInput") === "true") {
                    FDX.TRACKING.showMultiTracking();
                }
                sessionStorage.removeItem("activeMultiTrackInput");
                if (!$(activeCube).hasClass(FDX.CUBE.activeCubeClass)) {
                    FDX.CUBE.setActiveCube(activeCube);
                }
                sessionStorage.removeItem("storeActiveCube");
            }
        }
    },
    //storing the active cube data in session storage when user clicks on WLGN login
    //called in preLogin call in login js
    storeAppInfo: function() {
        if (FDX.DATALAYER.page.pageInfo.useWLGN === "true") {
            //check for active cube
            var activeCube = document.querySelector('.fxg-cube--active');
            var multiTrackClass = document.querySelector('.fxg-tracking-app__multi-tracking');
            var oldTrackClass = document.querySelectorAll('.redesignSnapshotTVC');
            var newTrackClass = document.querySelector('.track-shared-wrapper');
            if (activeCube !== null && activeCube.getAttribute('data-link-path') === null) {
                sessionStorage.setItem("storeActiveCube", activeCube.getAttribute('id'));
                //check for Multi-tracking
                if (multiTrackClass !== null && multiTrackClass.style !== null && multiTrackClass.style.display !== "none") {
                    sessionStorage.setItem("activeMultiTrackInput", true);
                }
                //check for single tracking results
                else if ((oldTrackClass[0] !== undefined && oldTrackClass.length > 0) || (newTrackClass !== null && !$(newTrackClass).is(':empty'))) {
                    sessionStorage.setItem("activeSingleTrackInput", true);
                }
            }
        }
    }
};

$(document).ready(function() {
    //On change of active cube
    $('.' + FDX.CUBE.cubeClass).on('click', function() {
        if (!$(this).hasClass(FDX.CUBE.activeCubeClass))
            FDX.CUBE.setActiveCube(this);
    });

    $('.' + FDX.CUBE.cubeOneSecureClass).on('click', function() {
        FDX.CUBE.checkSecureLink(this, 1);

    });
    $('.' + FDX.CUBE.cubeTwoSecureClass).on('click', function() {
        FDX.CUBE.checkSecureLink(this, 2);

    });
    $('.' + FDX.CUBE.cubeThreeSecureClass).on('click', function() {
        FDX.CUBE.checkSecureLink(this, 3);

    });

    $('.notTarget, .fxg-user-options__sign-in-text, .fxg-user-options__icon').on('click', function() {
        FDX.SESSION.cubeShippipng = false;
        // yet to implement below
        //FDX.CUBE.isTrackCall = false; 
        //FDX.CUBE.isLocationCall = false 
    });

    $('.' + FDX.CUBE.cubeClass).on('keydown', function(e) {
        if (e.keyCode === 13) {
            $(this).click();
        }
    });

});


window.addEventListener('load', function() {
    //loading active cube data
    FDX.CUBE.getAppInfo();
});

/*
 // script to trigger cookie MODAL
 // this needs to be added to DOM after fedex clientlibs loaded using any 3rd party tools or tag managers.

  function _succes(item){
    console.log('SUCCESS CALLED WITH ITEM: ', item);
    // ...additional actions to be done when on success
  }
  function _error(){
    console.log('Error and CLOSING the modal');
     // ...additional actions to be done when on error 
  }

  // additional configurations from external source
  // TODO: need to discuss how we can make use of it
  var cookieOptions = [
    {id: 'option_1', value: '123', checked: false},
    {id: 'option_2', value: '456', checked: true},
    {id: 'option_3', value: '789', checked: false}
  ];

  // open    -> on page load user can see modal by default without any click or user actions.
  // trigger -> user needs to clicks on the element with class 'js-init-cookie-modal' to open the cookie modal.
                This element needs to be configured on page some where by author or via script.
  var type = 'open' // 'open' or 'trigger'

  // init CookieModal
  var ckModal = window.FDX.CookieModal();
  ckModal.init([type, cookieOptions, _succes, _error]);
*/
(function($, _, window) {
    if (!window.FDX) {
        window.FDX = {};
    }

    /**
     * Cookie modal
     */
    window.FDX.CookieModal = function() {
        // instances of cookie MODAL
        var modalInst = {};

        var Service = window.FDX.FetchService;
        var locale = FDX.DATALAYER.page.pageInfo.locale;
        var cookieOpted = '';

        if (FDX.contextPath === undefined) {
            if (typeof(fdx) !== 'undefined') {
                FDX.contextPath = fdx.context.envtVar;
            }
        }

        var COOKIE_JSON_PATH = FDX.contextPath + '/etc/services/cookiemodal.' + locale + '.jsonp';

        // CONFIG
        var configs = [];
        var type = 'trigger'; // 'open' or 'trigger';
        var cookieOptions = [];
        var _succes;
        var _error;

        // cookie modal template
        var cookieTemplate = function() {
            return '<div class="fxg-cookie-modal">' +
                '<h2 class="fxg-cookie-modal__title" id="fxg-cookiebar-title"><%= title %></h2>' +

                '<p class="fxg-cookie-modal__description"><%= description %></p>' +

                '<form>' +

                '<h5 class="fxg-cookie-modal__settings__title"><%= settingsTitle %></h5>' +

                '<div class="fxg-cookie-modal__settings">' +

                '<% _.each(cookies, function (item, key) { %>' +
                '<div class="fxg-cookie-modal__cookie js-cookie-option">' +

                '<div class="fxg-radio">' +
                '<input <% if (recommendedOption == item.id ) { %> checked <% } %> id="<%= item.id %>" name="<%= radioFor %>" type="radio" value="<%= item.value %>" class="fxg-form__checkbox--round">' +

                '<label for="<%= item.id %>">' +
                '<span class="fxg-radio-text fxg-cookie-modal__cookie__name"><%= item.name %> <% if (recommendedOption == item.id && recommendedLabel != "") { %> (<%= recommendedLabel %>) <% } %></span>' +
                '</label>' +
                '</div>' +

                '<% if(item.description) { %>' +
                '<div class="fxg-cookie-modal__cookie__description js-cookie-description  <% if (recommendedOption == item.id) { %> is-selected <% } %> ">' +
                '<%= item.description %>' +
                '</div>' +
                '<% } %>' +

                '</div>' +

                '<% }); %>' +
                '</div>' +

                '<div class="fxg-cookie-modal__footer">' +
                '<div class="fxg-cookie-modal__actions">' +
                '<button class="fxg-cookie-modal__save fxg-button fxg-button--orange js-fxg-cookie-save"><%= saveButtonText %></button>' +
                '<a target="_blank" class="fxg-cookie-modal__link js-fxg-cookie-link" href="<%= readMoreLink %>"><%= readMoreText %></a>' +
                '</div>' +
                '</div>' +

                '</form>' +
                '</div>';
        };

        // construct cookie modal context/data as configured in the template.
        var cookieModalData = function(response) {
            var data = {};
            if (response) {
                data.title = response.title;
                data.description = response.description;
                data.settingsTitle = response.settingsTitle;
                data.recommendedLabel = response.recommendedLabel;
                data.recommendedOption = response.recommendedOption;
                data.saveButtonText = response.saveButtonText;
                data.readMoreText = response.readMoreText;
                data.readMoreLink = response.readMoreLink;

                for (var i in cookieOptions) {
                    var index = _.findIndex(response.cookies, {
                        id: cookieOptions[i].id
                    });
                    if (index !== -1) {
                        response.cookies[index].value = cookieOptions[i].value;
                    }
                }

                data.cookies = response.cookies;
            }

            return data;
        };

        var succesHandler = function() {
            if (_.isFunction(_succes)) {
                // external callback handlers for SUCCESS
                _succes(cookieOpted.val());
            } else {
                console.log('NO external callback handlers for SUCCESS: ' + cookieOpted.val());
            }
        };

        var errorHandler = function() {
            if (_.isFunction(_error)) {
                // external callback handlers for ERROR
                _error();
            } else {
                console.log('NO external callback handlers for ERROR');
            }
        };

        var loadCookieModal = function(appId) {
            var Modal = window.FDX.MODAL.init();
            var Template = cookieTemplate();

            function loadModal(data) {
                // create a modal Instance
                modalInst[appId] = Modal();
                var ckData = data;

                var ckTemplate = $(_.template(Template)(ckData));

                if (ckTemplate) {
                    // set application (string)
                    var $modalContent = modalInst[appId].set(ckTemplate);

                    // set application event listeners
                    $modalContent.on('click', '.js-cookie-option', function(e) {
                        $modalContent.find('.js-cookie-description').removeClass('is-selected');
                        $(e.currentTarget).find('.js-cookie-description').addClass('is-selected');
                    });

                    $modalContent.on('click', '.js-fxg-cookie-save', function(e) {
                        e.preventDefault();
                        modalInst[appId].close();

                        cookieOpted = $modalContent.find("input:checked");
                        if (cookieOpted) {
                            succesHandler();
                        } else {
                            errorHandler();
                        }
                    });

                    // open modal
                    modalInst[appId].open();
                }
            }

            if (Service) {
                // fetch the cookie JSON data
                Service.get(COOKIE_JSON_PATH)
                    .done(function(response) {
                        if (!_.isEmpty(response)) {

                            var data = cookieModalData(response);

                            if (!_.isEmpty(data)) {
                                data.radioFor = 'cookieOption_' + appId;
                                loadModal(data);
                            }
                        }
                    }).fail(function(resp) {
                        errorHandler();
                        console.log('cookie settings data is not configured');
                    });
            }
        };

        // Init cookie modal by default in OPEN state
        var initCookieModalFromLink = function() {
            // link Trigger
            var $modalTriggers = $('.js-init-cookie-modal');

            // listen for the modal trigger buttons click events
            // and load the cookie modal.
            $.each($modalTriggers, function(index, item) {
                // check if modal instance already created for the respective button(modal trigger)
                if ($(this).attr('data-init-modal') !== 'done') {
                    $(item).click(function() {
                        var id = $(this).attr('id') || 'id';
                        var appId = id + '_cookieModalInst_' + index;

                        $(this).attr('data-init-modal', 'done');
                        $(this).attr('data-app-id', appId);

                        if (modalInst[appId]) {
                            modalInst[appId].open();
                        } else {
                            loadCookieModal(appId);
                        }
                    });

                }
            });
        };

        // Init cookie modal by default in OPEN state
        var initCookieModalOpenState = function() {
            // per page only single instance of cookie modal, so appID will be same
            var appId = 'cookieModal_default_open';

            if (modalInst[appId]) {
                modalInst[appId].open();
            } else {
                loadCookieModal(appId);
            }
        };

        var init = function() {
            // configurations from external source
            // TODO: need to discuss how we can make use of it
            if (arguments.length) {
                configs = arguments[0];
                type = configs[0] || type;
                cookieOptions = configs[1] || cookieOptions;
                _succes = configs[2] || _succes;
                _error = configs[3] || _error;
            }

            if (type === 'open') {
                initCookieModalOpenState();
            } else {
                initCookieModalFromLink();
            }
        };

        return {
            init: init
        };
    };

    // init cookie modal only if we have any link on DOM to trigger/open modal on click.
    // Here, type='trigger' by default, so we no need to pass any arguments.
    if ($('.js-init-cookie-modal').length !== 0) {
        var ckModal = window.FDX.CookieModal();
        ckModal.init(); // or ckModal.init(['trigger']);
    }

}(window.jQuery, _, window));
/*
  // Cookie consent bar

  // To initiate Cookie consent bar, create cookie consent object and then call the init() function as shown below.
  
  // ckConsent Object
  var ckConsent = window.FDX.CookieConsent();
  
  // CASE 1: Cookie consent bar will be shown only when there are empty cookie settings in R42
  ckConsent.init();
  
  // CASE 2: we need to pass true to show the Cookie consent bar for whatever cookie settings done previously.
  ckConsent.init(true);

  // On save, below is the payload format which will be sent to R42
  {'1': true, '2': true, '3': false}
*/

(function($, _, window) {
    if (!window.FDX) {
        window.FDX = {};
    }

    // Cookie Consent Module
    window.FDX.CookieConsent = function() {
        var $cookieConsent;
        var $cookieConsentWrapper;
        var $body = $('body');

        // send user CookiePref to R42
        function saveHandler(userCookiePref) {
            if (window._st && window._st.cookiepermission) {
                _st.cookiepermission.setCookiePreferences(userCookiePref);
                _st.core.executeTags();
            } else {
                console.log('NO R42 tag to process data');
            }
            console.log('User accepted cookies: ' + JSON.stringify(userCookiePref));
        }

        function setPosition(wrapperElement) {
            if (!wrapperElement) return;

            // RESET the position before we calculate the position
            wrapperElement.css('top', 'auto');

            var top = $('.' + FDX.HEADER.headerClass).outerHeight();
            var wrapperHeight = wrapperElement.outerHeight() + top;
            var viewportHeight = window.innerHeight;

            if (wrapperHeight < viewportHeight) {
                // leave space between header and Cookie Consent if Cookie Consent is smaller than viewport height 
                wrapperElement.css('top', 'auto');
            } else {
                wrapperElement.css('top', top + 'px');
            }
        }

        function setEvents() {
            // Cookie consent CTA events
            $cookieConsent.on('click', '.js-fxg-cookie-save', function(e) {
                e.preventDefault();

                var $button = $(this);
                var userCookiePref = {};
                var $cookies = $cookieConsent.find('input');
                $cookies.each(function(index, item) {
                    if ($button.hasClass('is-save-all')) {
                        userCookiePref[index + 1] = true;
                    } else {
                        userCookiePref[index + 1] = item.checked;
                    }
                });

                // send cookie preference to r42.
                saveHandler(userCookiePref);
                $cookieConsent.removeClass('is-active');
                $('body').removeClass('has-cookie-consent-open');
            });

            // RESIZE
            $(window).resize(function() {
                setPosition($cookieConsentWrapper);
            });
        }

        function init(modify) {
            // cookie Content component on DOM.
            $cookieConsent = $('.js-init-fdx-cookie-consent');
            $cookieConsentWrapper = $cookieConsent.find('.fxg-cookie-consent__wrapper');

            if ($cookieConsent.length > 0) {
                $cookieConsent.removeClass('is-active');

                var cookiePref = {};
                var doModify = modify || false;

                // configurations from external source - TODO (not need to be mandatory)
                if (window._st && window._st.cookiepermission) {
                    cookiePref = _st.cookiepermission.getCookiePreferences();
                }

                // if no config then show
                if (_.isEmpty(cookiePref) || doModify) {
                    $cookieConsent.addClass('is-active');
                }

                // Override the default cookie pref with user past cookie pref.
                if (doModify && !_.isEmpty(cookiePref)) {
                    var $cookies = $cookieConsent.find('input');
                    $cookies.each(function(index, item) {
                        item.checked = cookiePref[index + 1] || false;
                    });
                }

                setPosition($cookieConsentWrapper);
            }

            setEvents();
        }

        // finds and returns the relay42 script tag
        function getRelayScriptTag() {
            var scripts = document.querySelectorAll('script');
            var relay42Script = ([].filter.call(scripts, function(script) {
                return script.src.indexOf('tdn.r42tag.com/lib') > -1;
            }) || [])[0];

            return relay42Script;
        }

        var checkInit = function(modify) {
            /* @NOTE: For local testing disable the relay42 checks below, but be sure to 
            re-enable before pushing changes. */

            if (!window._st) {
                // no relay at all. DO nothing
                return;
            }

            if (!window._st.cookiepermission) {
                // must wait. relay is being loaded but not ready.
                var relayScript = getRelayScriptTag();
                if (relayScript) {
                    // Attach onload handler for r42 script and on finish init the cookie consent.
                    relayScript.addEventListener('load', function() {
                        init(modify);
                    }, false);
                }
                return;
            }

            init(modify);
        };

        // register button event for Cookie Consent on cookie policy page
        // Author need to "js-fxg-cookie-modify" class to the link or button.
        $body.on('click', '.js-fxg-cookie-modify', function(e) {
            e.preventDefault();

            var doModify = true;
            checkInit(doModify);
        });

        return {
            checkInit: checkInit,
            setPosition: setPosition
        };
    };

}(window.jQuery, _, window));

/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * CONTENT NAVIGATION
         * 
         * A (side) navigation to help users easily navigate through pages
         */
        (function($, _) {
            window.FDX.components.contentnavigation = function() {
                /**
                 * @type {Object[]} list of instances
                 */
                var instances = [];
                /**
                 * @type {string} root selector
                 */

                var selector = '.fxg-contentnavigation';
                var SETTINGS = {
                    component: 'contentnavigation'
                };
                var SELECTORS = {
                    menuButton: "js-".concat(SETTINGS.component, "-menu-button"),
                    menuIcon: "js-".concat(SETTINGS.component, "-menu-icon"),
                    menuContent: "js-".concat(SETTINGS.component, "-content")
                };
                var CLASSES = {
                    mobileHide: 'fxg-mobile--hide',
                    rotate180: 'cc-aem-u-rotate--180'
                };
                /**
                 * Create component instance
                 *
                 * @public
                 * @return {Object} instance
                 */

                function create() {
                    /**
                     * @type {Object} configuration
                     */
                    var config = {};
                    /**
                     * @type {Object} jQuery DOM root element
                     */

                    var $root = null;
                    /**
                     * Set configuration
                     *
                     * @public
                     * @param {Object} _config - key/value pair
                     * @return {Object} instance
                     */

                    function setConfig(_config) {
                        var defaultConfig = {};
                        config = $.extend({}, defaultConfig, _config);
                    }

                    ;
                    /**
                     * Render HTML
                     *
                     * @private
                     * @return {Promise<string>} - A promise that resolves with rendered HTML
                     */

                    function render() {}
                    /**
                     * Initialize component instance
                     *
                     * @public
                     * @param {Object} [_$root] - component root element (optional)
                     * @return {Promise} - A promise that resolves when instance is initiated
                     */


                    function init(_$root) {
                        var promise = $.Deferred();
                        $root = _$root; //////////////////////////////
                        ////// START CNAV LOGIC //////
                        //////////////////////////////

                        var element = $root[0];
                        var menuButton = element.querySelector(".".concat(SELECTORS.menuButton));
                        var menuContent = element.querySelector(".".concat(SELECTORS.menuContent));
                        var menuIcon = menuButton.querySelector(".".concat(SELECTORS.menuIcon));
                        menuButton.addEventListener('click', function() {
                            menuContent.classList.toggle(CLASSES.mobileHide);
                            menuIcon.classList.toggle(CLASSES.rotate180);
                        }); //////////////////////////////
                        /////// END CNAV LOGIC ///////
                        //////////////////////////////
                        // Initialized

                        $root.data('initialized', true);
                        promise.resolve();
                        return promise;
                    }
                    /**
                     * Get component element
                     *
                     * @public
                     * @return {Object} jQuery DOM element
                     */


                    function getElement() {
                        return $root;
                    } // add and return instance


                    var instance = {
                        setConfig: setConfig,
                        init: init,
                        getElement: getElement
                    };
                    instances.push(instance);
                    return instance;
                }
                /**
                 * Create instances
                 *
                 * @public
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function createInstances() {
                    var promise = $.Deferred();
                    var initPromises = []; // find all related elements

                    $(selector).each(function() {
                        // skip already initialized elements
                        var $element = $(this);
                        if ($element.data('initialized')) return; // create instance

                        var instance = window.FDX.components.contentnavigation.create(); // Set configuration

                        var $config = $('[data-config="js-contentnavigation-config"]', $element);

                        if ($config.length) {
                            instance.setConfig($.parseJSON($config.html().trim()));
                        } // initialize instance


                        var initPromise = instance.init($element);
                        initPromises.push(initPromise);
                    }); // resolve after all inits

                    $.when.apply($, initPromises).then(function() {
                        promise.resolve();
                    });
                    return promise;
                } // return component


                return {
                    create: create,
                    instances: instances,
                    createInstances: createInstances,
                    selector: selector
                };
            }();
        })(window.jQuery, window._);

        /***/
    }),
    /* 2 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // extracted by mini-css-extract-plugin


        /***/
    })
    /******/
]);
/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * Conditional form
         */
        try {
            (function($, _, $analytics, $fetch) {
                window.FDX.components.conditionalform = function() {
                    /**
                     * @type {Object[]} list of instances
                     */
                    var instances = [];
                    /**
                     * @type {string} root selector
                     */

                    var selector = '.js-conditional-form';
                    /**
                     * @type {string} Interim form selector
                     */

                    var FORM = '.js-c-form';
                    /**
                     * Create component instance
                     *
                     * @public
                     * @return {Object} instance
                     */

                    function create() {
                        /**
                         * @type {Object} configuration
                         */
                        var $config = {};
                        /**
                         * @type {Object} jQuery DOM root element
                         */

                        var $root = null;
                        /**
                         * @type {Object} component properties or data-attributes
                         */

                        var properties = {
                            dropDownChoose: '',
                            dropDownLabel: '',
                            errorMessage: 'Not Applicable'
                        };
                        /**
                         * @type {Object} jQuery DOM conditional dropdown wrapper
                         */

                        var $conditionalDropdown;
                        /**
                         * @type {Object} jQuery DOM conditional content container
                         */

                        var $contentContainer;
                        /**
                         * @type {Object} jQuery DOM Loader/Spinner element
                         */

                        var $loader;
                        /**
                         * @type {string} CSS class name for hidden elements
                         */

                        var IS_HIDDEN = 'fxg-hidden';
                        /**
                         * @type {string} CSS class name for conditional-dropdown <select> element
                         */

                        var SELECT = '.js-conditional-dropdown';
                        /**
                         * @type {Object[]} list of visible dropdown items configuration
                         */

                        var $visibleItems = [];
                        /**
                         * @type {Object} conled configuration
                         */

                        var clonedConfig = {};
                        /**
                         * @type {number} positon of the opted item in the list of visible dropdown items
                         */

                        var position = 1;
                        /**
                         * @type {Object} INTERIMFORM Module
                         */

                        var FormModule = window.FDX.INTERIMFORM;
                        /**
                         * @type {Object} DATEPICKER module
                         */

                        var DatePicker = window.FDX.DATEPICKER;
                        /**
                         * Set configuration
                         *
                         * @public
                         * @param {Object} _config - key/value pair
                         * @return {Object} instance
                         */

                        function setConfig(_config) {
                            var defaultConfig = {};
                            $config = $.extend({}, defaultConfig, _config);
                        }
                        /**
                         * Render HTML
                         *
                         * @private
                         * @param {Object} data - configurations
                         * @return {Promise<string>} A promise that resolves with rendered HTML
                         */


                        function render(data) {
                            var promise = $.Deferred();
                            var html = "\n        <div class=\"js-form-selection fxg-conditional-form__dropdown cc-aem-c-form-group cc-aem-c-form-group--select cc-aem-c-form-group--float-label cc-aem-c-form-group--has-value \">\n          <span class=\"cc-aem-c-form-group__item\">\n            <select class=\"js-conditional-dropdown cc-aem-c-form-group__select\" aria-labelledby=\"conditionalform\" id=\"INPUT\" name=\"conditional-forms\" data-index=\"<%= index %>\">\n              <option disabled=\"\" selected=\"\"><%= defaultOption %></option>\n              <% _.each(selection, function (item) { %>\n                <option <% if(item.isSelected) { %>  selected aria-selected=\"true\" <% } %> value=\"<%= item.label %>\"><%= item.label %></option>\n              <% }); %>\n              </select>\n\n              <fdx-icon class=\"cc-aem-c-form-group__icon\" aria-hidden=\"true\">\n                <svg class=\"cc-aem-c-icon \" aria-hidden=\"true\" focusable=\"false\" role=\"presentation\">\n                    <use xlink:href=\"#chevron\"></use>\n                </svg>\n              </fdx-icon>\n\n              <label id=\"\" class=\"cc-aem-c-form-group__label\" for=\"INPUT\" id=\"conditionalform\"><%= labelText %></label>\n          </span>\n        </div>\n        ";
                            var currentItem = data;
                            var optedData = currentItem ? currentItem.data : $visibleItems[0];
                            var itemDropDownLabel = currentItem ? currentItem.title : properties.dropDownLabel;

                            var rendered = _.template(html)({
                                defaultOption: properties.dropDownChoose,
                                labelText: itemDropDownLabel,
                                index: position,
                                selection: optedData
                            });

                            return promise.resolve(rendered);
                        }
                        /**
                         * Hack to fix SVG images on holiday-schedule page (D-41606)
                         *
                         * @private
                         */


                        function holdaySVGFix() {
                            if (FDX.DATALAYER.page.pageInfo.pageName === 'holiday-schedule') {
                                $contentContainer.find("table img[src*='.svg']").each(function() {
                                    $(this).attr("width", "20px");
                                    $(this).attr("height", "20px");
                                });
                            }
                        }
                        /**
                         * Fetch the content and add to DOM
                         *
                         * @private
                         */


                        function fetchContent() {
                            var data = $visibleItems[position - 1];

                            var isLink = _.get(data, 'isLink');

                            $loader.removeClass(IS_HIDDEN);

                            if (isLink === 'true') {
                                var path = FDX.contextPath ? FDX.contextPath + data.content : data.content;
                                $fetch.ajax(path, '', {
                                    'dataType': 'html'
                                }).then(function(response) {
                                    var content = $('<div/>').append(response).find('.js-cms-conditional-form-template');
                                    $loader.addClass(IS_HIDDEN);
                                    $contentContainer.empty().append(content); // Bootstrap the lazy loaded form component.

                                    _.each($root.find(FORM), function(component) {
                                        FormModule.init($(component)); // lazy INIT form elements like date picker

                                        var $datePkr = $(component).find('.js-fxg-date-picker-wrapper');

                                        if ($datePkr.length > 0 && window.FDX.DATEPICKER) {
                                            $datePkr.each(function(index, dpicker) {
                                                DatePicker.init($(dpicker));
                                            });
                                        }
                                    });

                                    holdaySVGFix();
                                }, function(resp) {
                                    $loader.addClass(IS_HIDDEN);
                                    $contentContainer.empty().append('<span class="fxg-field__validation">' + properties.errorMessage + '</span>');
                                });
                            } else {
                                $loader.addClass(IS_HIDDEN);
                                $contentContainer.empty().append(data.content);
                            }
                        }
                        /**
                         * create selection dropdown
                         *
                         * @private
                         * @param {Object} selectedItem opted dropdown configurations
                         */


                        function createSelection(selectedItem) {
                            render(selectedItem).then(function(html) {
                                if (html) {
                                    $conditionalDropdown.append(html);
                                }
                            });
                        }
                        /**
                         * update or remove all the child selections which are after the opted selection
                         *
                         * @param {number} [optedPosition] positon of the opted selection in the list of visible dropdown items
                         * @private
                         */


                        function updateSelections(optedPosition) {
                            if (!optedPosition) return false;
                            var $selections = $conditionalDropdown.find('.js-form-selection');

                            _.each($selections, function(item) {
                                var $item = $(item);
                                var currentPosition = $item.find(SELECT).data('index'); // remove the child dropdowns after opted item Position

                                if (currentPosition > optedPosition) {
                                    $item.remove();
                                }
                            });
                        }
                        /**
                         * update the position based on opted selection
                         *
                         * @private
                         * @return {number} positon of the opted selection in the list of visible selections
                         */


                        function updatePosition(optedPosition) {
                            if (!optedPosition) return position;
                            var currentPosition = optedPosition;
                            var newPosition = position;

                            if (currentPosition === newPosition) {
                                newPosition = newPosition + 1;
                            } else if (currentPosition < newPosition) {
                                newPosition = currentPosition + 1;
                            }

                            return newPosition;
                        }
                        /**
                         * selection or dropdown onchange handler
                         *
                         * @private
                         * @param {string} label or value of the selection
                         */


                        function selectionHandler(label) {
                            var labelValue = _.isObject(label) ? $(this).val() : label;
                            var optedPosition = _.isObject(label) ? $(this).data('index') : position;

                            if (FDX.DTM) {
                                FDX.DTM.pushButtonInfo('dropdown:' + labelValue, 'samePage');
                            } // empty the previously selected content


                            $contentContainer.empty();
                            position = updatePosition(optedPosition);
                            updateSelections(optedPosition); // update visible selctions/items array
                            // by removing child selections after the opted position

                            $visibleItems = _.take($visibleItems, optedPosition); // fetch the current selection

                            var selection = _.find($visibleItems[optedPosition - 1], {
                                'label': labelValue
                            });

                            if (selection && selection.data) {
                                $visibleItems.push(selection.data); // to check if we still have child selections. If yes, create next/child dropdown

                                if (_.isArray(selection.data)) {
                                    createSelection(selection);
                                } else {
                                    fetchContent();
                                }

                                var selectedItem = _.find(selection.data, {
                                    'isSelected': true
                                });

                                if (selectedItem) {
                                    selectionHandler(selectedItem.label);
                                }

                                if (labelValue) {
                                    var payload = {
                                        gdl: {
                                            category: 'interaction',
                                            eventName: 'click',
                                            params: {
                                                name: 'conditionaldropdown|select--' + labelValue
                                            }
                                        }
                                    };
                                    $analytics.push(payload);
                                }
                            }
                        }
                        /**
                         * Sets the clonedConfig with 'isSelected' parameter for each item based on hashValue
                         *
                         * @private
                         * @param {Object} data clonedConfig
                         * @param {string} hashValue hash value from the url
                         * @return {Boolean} selectable true if matches with hash value else false
                         */


                        function preSelectFromHash(data, hashValue) {
                            var selectable = false;

                            _.each(data, function(item) {
                                item.isSelected = false;

                                if (_.isArray(item.data)) {
                                    // iterate the child items(if array)
                                    selectable = preSelectFromHash(item.data, hashValue); // valid hash item then set its parent item.isSelected to true.

                                    if (selectable) {
                                        item.isSelected = true; // return/exit loop on 1st instance of selectable item

                                        return false;
                                    }
                                } else {
                                    // url format = /express/.../.../{form_name}.html#{form_name}
                                    // where {form_name} will be used as #hash value and will be unique to form.
                                    var formName = item.data.content.split('.html')[0].split('/').pop();

                                    if (formName === hashValue) {
                                        selectable = true;
                                        item.isSelected = true; // return/exit loop on 1st instance of selectable item

                                        return false;
                                    }
                                }
                            });

                            return selectable;
                        }
                        /**
                         * Initialize component instance
                         *
                         * @public
                         * @param {Object} [_$root] compnent root element (optional)
                         * @return {Promise} A promise that resolves when instance is initiated
                         */


                        function init(_$root) {
                            var promise = $.Deferred();
                            $root = _$root;
                            properties.dropDownChoose = $root.data('choose') || properties.dropDownChoose;
                            properties.dropDownLabel = $root.data('label') || properties.dropDownLabel;
                            properties.errorMessage = $root.data('error-message') || properties.errorMessage;
                            $conditionalDropdown = $root.find('.fxg-conditional-form-dropdown');
                            $contentContainer = $root.find('.fxg-content-container');
                            $loader = $root.find('.fxg-spinner'); // set FDX contextPath

                            if (FDX.contextPath === undefined) {
                                FDX.contextPath = typeof fdx !== 'undefined' ? fdx.context.envtVar : '';
                            } // rest the component state


                            $conditionalDropdown.empty();
                            $contentContainer.empty(); // clone the data to retain the original configurations

                            clonedConfig = _.clone($config.formJson, true); // store the data of each choosen item. This will be used when options are changed.

                            $visibleItems = [];
                            $visibleItems.push(clonedConfig); // position start from 1, as we already have initial data at 0th index

                            position = 1;
                            var hashValue = window.location.hash.substring(1);

                            if (hashValue) {
                                preSelectFromHash(clonedConfig, hashValue);
                            } // create default dropdown


                            createSelection();

                            var selectedItem = _.find(clonedConfig, {
                                'isSelected': true
                            }); // preselection scenario


                            if (selectedItem && selectedItem.label) {
                                selectionHandler(selectedItem.label);
                            } // ON 'change' event listener


                            $root.on('change', SELECT, function() {
                                var $option = $(this);
                                position = $option.data('index');
                                selectionHandler($option.val());
                            }); // ON 'hashchange' event listener

                            $(window).on('hashchange', init); // initialized

                            $root.data('initialized', true);
                            promise.resolve();
                            return promise;
                        }
                        /**
                         * Get component element
                         *
                         * @public
                         * @return {Object} jQuery DOM element
                         */


                        function getElement() {
                            return $root;
                        } // add and return instance


                        var instance = {
                            setConfig: setConfig,
                            init: init,
                            getElement: getElement
                        }; // pass private attributes and methods to jest

                        if (typeof jest !== 'undefined') {
                            preSelectFromHash = jest.fn(preSelectFromHash);
                            selectionHandler = jest.fn(selectionHandler);
                            createSelection = jest.fn(createSelection);
                            updateSelections = jest.fn(updateSelections);
                            updatePosition = jest.fn(updatePosition);
                            fetchContent = jest.fn(fetchContent);

                            instance.$private = function() {
                                return {
                                    $root: $root,
                                    $conditionalDropdown: $conditionalDropdown,
                                    $contentContainer: $contentContainer,
                                    $loader: $loader,
                                    $visibleItems: $visibleItems,
                                    clonedConfig: clonedConfig,
                                    position: position,
                                    preSelectFromHash: preSelectFromHash,
                                    selectionHandler: selectionHandler,
                                    createSelection: createSelection,
                                    updateSelections: updateSelections,
                                    updatePosition: updatePosition,
                                    fetchContent: fetchContent
                                };
                            };
                        }

                        instances.push(instance);
                        return instance;
                    }
                    /**
                     * Create instances
                     *
                     * @public
                     * @return {Promise} A promise that resolves when all instances are initiated
                     */


                    function createInstances() {
                        var promise = $.Deferred();
                        var initPromises = []; // find all related elements

                        $(selector).each(function() {
                            // skip already initialized elements
                            var $element = $(this);
                            if ($element.data('initialized')) return; // create instance

                            var instance = window.FDX.components.conditionalform.create(); // Set configuration

                            var $config = $.trim($('[data-config="js-conditional-form-config"]', $element).html());
                            if (!$config) return;
                            var config = $.parseJSON($config); // fix for " double quote and &amp; decode character decoding issue

                            encodeFix(config.formJson);
                            instance.setConfig(config); // initialize instance

                            var initPromise = instance.init($element);
                            initPromises.push(initPromise);
                        }); // resolve after all inits

                        $.when.apply($, initPromises).then(function() {
                            promise.resolve();
                        });
                        return promise;
                    }
                    /**
                     * Replace the encoded special characters
                     *
                     * @private
                     * @param {Object} json configurations json object
                     */


                    function encodeFix(json) {
                        if (!json) return;

                        _.forEach(json, function(item) {
                            item.label = item.label ? item.label.replace(/"/g, "'").replace(/&amp;/g, "&") : ''; // check if current item has deeper levels

                            if (_.isArray(item.data)) {
                                encodeFix(item.data);
                            }
                        });
                    } // return component


                    return {
                        create: create,
                        instances: instances,
                        createInstances: createInstances,
                        selector: selector
                    };
                }();
            })(jQuery, _, FDX.services.analytics, FDX.services.fetch);
        } catch (e) {
            console.error(e);
        }

        /***/
    }),
    /* 2 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // extracted by mini-css-extract-plugin


        /***/
    })
    /******/
]);
/* This is the FedEx.com column control javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-04-01
 */
if (!FDX) {
    var FDX = {};
}

FDX.COLUMN_CONTROL = {
    columnClass: 'fxg-col',
    openColumnClass: 'fxg-col--open'
};
/* This is the FedEx.com code snippet javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-09-05
 */
if (!FDX) {
    var FDX = {};
}

FDX.CODE_SNIPPET = {
    containerClass: 'fxg-code-snippet',
    buttonClass: 'fxg-code-snippet-expand-collapse',
    closedHeight: '58px',
    expandClass: 'expanded',
    expandedButtonText: 'Collapse',
    collapsedButtonText: 'Expand',

    init: function() {
        $('.' + FDX.CODE_SNIPPET.containerClass).css({
            'height': FDX.CODE_SNIPPET.closedHeight
        });
    },

    toggle: function(elem) {
        if ($(elem).parent().hasClass(FDX.CODE_SNIPPET.expandClass)) {
            // collapse  
            $(elem).parent().removeClass(FDX.CODE_SNIPPET.expandClass);
            $(elem).parent().animate({
                'height': FDX.CODE_SNIPPET.closedHeight
            });
            $(elem).text(FDX.CODE_SNIPPET.collapsedButtonText);
        } else {
            // expand
            preHeight = 0;
            $(elem).parent().find('pre').each(function() {
                preHeight = $(this).height() + 30;
            });
            $(elem).parent().addClass(FDX.CODE_SNIPPET.expandClass);
            $(elem).parent().animate({
                'height': preHeight
            });
            $(elem).text(FDX.CODE_SNIPPET.expandedButtonText);
        }

    },

    expanded: function() {
        $('.fxg-code-snippet-expand-collapse').each(function() {
            FDX.CODE_SNIPPET.toggle(this);
        });
    }
};

$(document).ready(function() {
    FDX.CODE_SNIPPET.init();
    FDX.CODE_SNIPPET.expanded();

    $('.' + FDX.CODE_SNIPPET.buttonClass).click(function(e) {
        e.preventDefault();
        FDX.CODE_SNIPPET.toggle(this);
    });
});
/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 1);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports) {

        function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }

        var g; // This works in non-strict mode

        g = function() {
            return this;
        }();

        try {
            // This works if eval is allowed (see CSP)
            g = g || new Function("return this")();
        } catch (e) {
            // This works if the window reference is available
            if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
        } // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}


        module.exports = g;

        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports, __webpack_require__) {

        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 2 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(setImmediate, global) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

            function _typeof(obj) {
                "@babel/helpers - typeof";
                if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof(obj) {
                        return typeof obj;
                    };
                } else {
                    _typeof = function _typeof(obj) {
                        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                    };
                }
                return _typeof(obj);
            }

            /**
             * CHAT
             *
             * This component enables customers to start a live chat with our customper support agents if they
             * are available. If they are not available a message will be shown. This enables us to track demand
             * in both cases of live agents being available or not.
             */
            (function($, _) {
                window.FDX.components.chat = function() {
                    /**
                     * @type {Object[]} list of instances
                     */
                    var instances = [];
                    /**
                     * @type {string} root selector
                     */

                    var selector = '.fxg-chat';
                    /**
                     * Create component instance
                     *
                     * @public
                     * @return {Object} instance
                     */

                    function create() {
                        /**
                         * @type {Object} configuration
                         */
                        var config = {};
                        /**
                         * @type {Object} jQuery DOM root element
                         */

                        var $root = null;
                        /**
                         * Set configuration
                         *
                         * @public
                         * @param {Object} _config - key/value pair
                         * @return {Object} instance
                         */

                        function setConfig(_config) {
                            var defaultConfig = {};
                            config = $.extend({}, defaultConfig, _config);
                        }

                        ;
                        /**
                         * Render HTML
                         *
                         * @private
                         * @return {Promise<string>} - A promise that resolves with rendered HTML
                         */

                        function render() {}
                        /**
                         * Promises Polyfill
                         * For IE11, Remove when polyfills are part of the build setup
                         */


                        ! function(e, t) {
                            "object" == (false ? undefined : _typeof(exports)) && "undefined" != typeof module ? t() : true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (t),
                                __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                    (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
                                    __WEBPACK_AMD_DEFINE_FACTORY__),
                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
                        }(0, function() {
                            "use strict";

                            function e(e) {
                                var t = this.constructor;
                                return this.then(function(n) {
                                    return t.resolve(e()).then(function() {
                                        return n;
                                    });
                                }, function(n) {
                                    return t.resolve(e()).then(function() {
                                        return t.reject(n);
                                    });
                                });
                            }

                            function t(e) {
                                return new this(function(t, n) {
                                    function o(e, n) {
                                        if (n && ("object" == _typeof(n) || "function" == typeof n)) {
                                            var f = n.then;
                                            if ("function" == typeof f) return void f.call(n, function(t) {
                                                o(e, t);
                                            }, function(n) {
                                                r[e] = {
                                                    status: "rejected",
                                                    reason: n
                                                }, 0 == --i && t(r);
                                            });
                                        }

                                        r[e] = {
                                            status: "fulfilled",
                                            value: n
                                        }, 0 == --i && t(r);
                                    }

                                    if (!e || "undefined" == typeof e.length) return n(new TypeError(_typeof(e) + " " + e + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
                                    var r = Array.prototype.slice.call(e);
                                    if (0 === r.length) return t([]);

                                    for (var i = r.length, f = 0; r.length > f; f++) {
                                        o(f, r[f]);
                                    }
                                });
                            }

                            function n(e) {
                                return !(!e || "undefined" == typeof e.length);
                            }

                            function o() {}

                            function r(e) {
                                if (!(this instanceof r)) throw new TypeError("Promises must be constructed via new");
                                if ("function" != typeof e) throw new TypeError("not a function");
                                this._state = 0, this._handled = !1, this._value = undefined, this._deferreds = [], l(e, this);
                            }

                            function i(e, t) {
                                for (; 3 === e._state;) {
                                    e = e._value;
                                }

                                0 !== e._state ? (e._handled = !0, r._immediateFn(function() {
                                    var n = 1 === e._state ? t.onFulfilled : t.onRejected;

                                    if (null !== n) {
                                        var o;

                                        try {
                                            o = n(e._value);
                                        } catch (r) {
                                            return void u(t.promise, r);
                                        }

                                        f(t.promise, o);
                                    } else(1 === e._state ? f : u)(t.promise, e._value);
                                })) : e._deferreds.push(t);
                            }

                            function f(e, t) {
                                try {
                                    if (t === e) throw new TypeError("A promise cannot be resolved with itself.");

                                    if (t && ("object" == _typeof(t) || "function" == typeof t)) {
                                        var n = t.then;
                                        if (t instanceof r) return e._state = 3, e._value = t, void c(e);
                                        if ("function" == typeof n) return void l(function(e, t) {
                                            return function() {
                                                e.apply(t, arguments);
                                            };
                                        }(n, t), e);
                                    }

                                    e._state = 1, e._value = t, c(e);
                                } catch (o) {
                                    u(e, o);
                                }
                            }

                            function u(e, t) {
                                e._state = 2, e._value = t, c(e);
                            }

                            function c(e) {
                                2 === e._state && 0 === e._deferreds.length && r._immediateFn(function() {
                                    e._handled || r._unhandledRejectionFn(e._value);
                                });

                                for (var t = 0, n = e._deferreds.length; n > t; t++) {
                                    i(e, e._deferreds[t]);
                                }

                                e._deferreds = null;
                            }

                            function l(e, t) {
                                var n = !1;

                                try {
                                    e(function(e) {
                                        n || (n = !0, f(t, e));
                                    }, function(e) {
                                        n || (n = !0, u(t, e));
                                    });
                                } catch (o) {
                                    if (n) return;
                                    n = !0, u(t, o);
                                }
                            }

                            var a = setTimeout,
                                s = "undefined" != typeof setImmediate ? setImmediate : null;
                            r.prototype["catch"] = function(e) {
                                return this.then(null, e);
                            }, r.prototype.then = function(e, t) {
                                var n = new this.constructor(o);
                                return i(this, new function(e, t, n) {
                                    this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof t ? t : null, this.promise = n;
                                }(e, t, n)), n;
                            }, r.prototype["finally"] = e, r.all = function(e) {
                                return new r(function(t, o) {
                                    function r(e, n) {
                                        try {
                                            if (n && ("object" == _typeof(n) || "function" == typeof n)) {
                                                var u = n.then;
                                                if ("function" == typeof u) return void u.call(n, function(t) {
                                                    r(e, t);
                                                }, o);
                                            }

                                            i[e] = n, 0 == --f && t(i);
                                        } catch (c) {
                                            o(c);
                                        }
                                    }

                                    if (!n(e)) return o(new TypeError("Promise.all accepts an array"));
                                    var i = Array.prototype.slice.call(e);
                                    if (0 === i.length) return t([]);

                                    for (var f = i.length, u = 0; i.length > u; u++) {
                                        r(u, i[u]);
                                    }
                                });
                            }, r.allSettled = t, r.resolve = function(e) {
                                return e && "object" == _typeof(e) && e.constructor === r ? e : new r(function(t) {
                                    t(e);
                                });
                            }, r.reject = function(e) {
                                return new r(function(t, n) {
                                    n(e);
                                });
                            }, r.race = function(e) {
                                return new r(function(t, o) {
                                    if (!n(e)) return o(new TypeError("Promise.race accepts an array"));

                                    for (var i = 0, f = e.length; f > i; i++) {
                                        r.resolve(e[i]).then(t, o);
                                    }
                                });
                            }, r._immediateFn = "function" == typeof s && function(e) {
                                s(e);
                            } || function(e) {
                                a(e, 0);
                            }, r._unhandledRejectionFn = function(e) {
                                void 0 !== console && console && console.warn("Possible Unhandled Promise Rejection:", e);
                            };

                            var d = function() {
                                if ("undefined" != typeof self) return self;
                                if ("undefined" != typeof window) return window;
                                if ("undefined" != typeof global) return global;
                                throw Error("unable to locate global object");
                            }();

                            "function" != typeof d.Promise ? d.Promise = r : (d.Promise.prototype["finally"] || (d.Promise.prototype["finally"] = e), d.Promise.allSettled || (d.Promise.allSettled = t));
                        });
                        /**
                         * Initialize component instance
                         *
                         * @public
                         * @param {Object} [_$root] - component root element (optional)
                         * @return {Promise} - A promise that resolves when instance is initiated
                         */

                        function init(_$root) {
                            var promise = $.Deferred();
                            $root = _$root;
                            var $component = $root[0];

                            if (!$component.classList.contains('fxg-chat')) {
                                $component = $root[0].querySelector('.fxg-chat');
                            }

                            var modalTriggered = false;
                            var noAgentModalMessage = $component.dataset.noagentmodalmessage; // use id to also handle special chars

                            var offlineButton = $component.querySelector("[id='liveagent_button_offline_".concat(config.buttonId, "']"));
                            var offlineButtonLink = offlineButton.querySelector('.js-chat-link-offline'); // use id to also handle special chars

                            var onlineButton = $component.querySelector("[id='liveagent_button_online_".concat(config.buttonId, "']"));
                            var onlineButtonLink = onlineButton.querySelector('.js-chat-link-online'); // Only apply eventListener if the modal experience is enabled

                            if (config.enableNoAgentModal) {
                                var Modal = window.FDX.MODAL.init(); // Listen to modal button clicks

                                offlineButtonLink.addEventListener('click', function(event) {
                                    event.preventDefault();

                                    if (!modalTriggered) {
                                        modalTriggered = true;
                                        Modal[config.buttonId] = Modal();
                                        Modal[config.buttonId].set(noAgentModalMessage);
                                    }

                                    Modal[config.buttonId].open();
                                });
                            } // Listen to link clicks from the start
                            // Prevents incidentally added urls  to be clicked/opened
                            // TODO: Transform this component to use buttons instead of a link component


                            onlineButtonLink.addEventListener('click', function(event) {
                                event.preventDefault();
                            });
                            /**
                             * Load LiveAgent Script
                             *
                             * @param  {string} url - script deployment url
                             * @param  {boolean} async
                             * @param  {string} type - script type
                             */

                            var loadScript = function loadScript(url) {
                                var async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                                var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'text/javascript';
                                return new Promise(function(resolve, reject) {
                                    try {
                                        var scriptElement = document.createElement('script');
                                        scriptElement.src = url;
                                        scriptElement.async = async;
                                        scriptElement.type = type;
                                        scriptElement.addEventListener('load', function() {
                                            resolve({
                                                status: true
                                            });
                                        });
                                        scriptElement.addEventListener('error', function() {
                                            reject({
                                                status: false,
                                                message: "Failed to load the script ".concat(url)
                                            });
                                        });
                                        $component.appendChild(scriptElement);
                                    } catch (error) {
                                        reject(error);
                                    }
                                });
                            };

                            loadScript(config.deploymentUrl).then(function() {
                                initLiveAgent();
                            }).catch(function(error) {
                                console.error(error);
                            });
                            /**
                             * Initiate LiveAgent
                             *
                             * API Docs: https://developer.salesforce.com/docs/atlas.en-us.live_agent_dev.meta/live_agent_dev/live_agent_deployment_api_code_sample.htm
                             */

                            function initLiveAgent() {
                                liveagent.init(config.instanceUrl, config.deploymentId, config.orgId);

                                if (!window._laq) {
                                    window._laq = [];
                                } // Handle showing online / offline button


                                window._laq.push(function() {
                                    liveagent.showWhenOnline("".concat(config.buttonId), onlineButton);
                                    liveagent.showWhenOffline("".concat(config.buttonId), offlineButton);
                                });

                                onlineButtonLink.addEventListener('click', function(event) {
                                    event.preventDefault();
                                    liveagent.startChat("".concat(config.buttonId));
                                });
                            } // Initialized


                            $root.data('initialized', true);
                            promise.resolve();
                            return promise;
                        }
                        /**
                         * Get component element
                         *
                         * @public
                         * @return {Object} jQuery DOM element
                         */


                        function getElement() {
                            return $root;
                        } // add and return instance


                        var instance = {
                            setConfig: setConfig,
                            init: init,
                            getElement: getElement
                        };
                        instances.push(instance);
                        return instance;
                    }
                    /**
                     * Create instances
                     *
                     * @public
                     * @return {Promise} A promise that resolves when all instances are initiated
                     */


                    function createInstances() {
                        var promise = $.Deferred();
                        var initPromises = []; // find all related elements

                        $(selector).each(function() {
                            // skip already initialized elements
                            var $element = $(this);
                            if ($element.data('initialized')) return; // create instance

                            var instance = window.FDX.components.chat.create(); // Set configuration

                            var $config = $('[data-config="js-chat-config"]', $element);

                            if ($config.length) {
                                instance.setConfig($.parseJSON($config.html().trim()));
                            } // initialize instance


                            var initPromise = instance.init($element);
                            initPromises.push(initPromise);
                        }); // resolve after all inits

                        $.when.apply($, initPromises).then(function() {
                            promise.resolve();
                        });
                        return promise;
                    } // return component


                    return {
                        create: create,
                        instances: instances,
                        createInstances: createInstances
                    };
                }();
            })(window.jQuery, window._);
            /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(3).setImmediate, __webpack_require__(0)))

        /***/
    }),
    /* 3 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global) {
            var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
            var apply = Function.prototype.apply; // DOM APIs, for completeness

            exports.setTimeout = function() {
                return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
            };

            exports.setInterval = function() {
                return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
            };

            exports.clearTimeout = exports.clearInterval = function(timeout) {
                if (timeout) {
                    timeout.close();
                }
            };

            function Timeout(id, clearFn) {
                this._id = id;
                this._clearFn = clearFn;
            }

            Timeout.prototype.unref = Timeout.prototype.ref = function() {};

            Timeout.prototype.close = function() {
                this._clearFn.call(scope, this._id);
            }; // Does not start the time, just sets up the members needed.


            exports.enroll = function(item, msecs) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = msecs;
            };

            exports.unenroll = function(item) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = -1;
            };

            exports._unrefActive = exports.active = function(item) {
                clearTimeout(item._idleTimeoutId);
                var msecs = item._idleTimeout;

                if (msecs >= 0) {
                    item._idleTimeoutId = setTimeout(function onTimeout() {
                        if (item._onTimeout) item._onTimeout();
                    }, msecs);
                }
            }; // setimmediate attaches itself to the global object


            __webpack_require__(4); // On some exotic environments, it's not clear which object `setimmediate` was
            // able to install onto.  Search each possibility in the same order as the
            // `setimmediate` library.


            exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
            exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
            /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(0)))

        /***/
    }),
    /* 4 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global, process) {
            (function(global, undefined) {
                "use strict";

                if (global.setImmediate) {
                    return;
                }

                var nextHandle = 1; // Spec says greater than zero

                var tasksByHandle = {};
                var currentlyRunningATask = false;
                var doc = global.document;
                var registerImmediate;

                function setImmediate(callback) {
                    // Callback can either be a function or a string
                    if (typeof callback !== "function") {
                        callback = new Function("" + callback);
                    } // Copy function arguments


                    var args = new Array(arguments.length - 1);

                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i + 1];
                    } // Store and register the task


                    var task = {
                        callback: callback,
                        args: args
                    };
                    tasksByHandle[nextHandle] = task;
                    registerImmediate(nextHandle);
                    return nextHandle++;
                }

                function clearImmediate(handle) {
                    delete tasksByHandle[handle];
                }

                function run(task) {
                    var callback = task.callback;
                    var args = task.args;

                    switch (args.length) {
                        case 0:
                            callback();
                            break;

                        case 1:
                            callback(args[0]);
                            break;

                        case 2:
                            callback(args[0], args[1]);
                            break;

                        case 3:
                            callback(args[0], args[1], args[2]);
                            break;

                        default:
                            callback.apply(undefined, args);
                            break;
                    }
                }

                function runIfPresent(handle) {
                    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
                    // So if we're currently running a task, we'll need to delay this invocation.
                    if (currentlyRunningATask) {
                        // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                        // "too much recursion" error.
                        setTimeout(runIfPresent, 0, handle);
                    } else {
                        var task = tasksByHandle[handle];

                        if (task) {
                            currentlyRunningATask = true;

                            try {
                                run(task);
                            } finally {
                                clearImmediate(handle);
                                currentlyRunningATask = false;
                            }
                        }
                    }
                }

                function installNextTickImplementation() {
                    registerImmediate = function registerImmediate(handle) {
                        process.nextTick(function() {
                            runIfPresent(handle);
                        });
                    };
                }

                function canUsePostMessage() {
                    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
                    // where `global.postMessage` means something completely different and can't be used for this purpose.
                    if (global.postMessage && !global.importScripts) {
                        var postMessageIsAsynchronous = true;
                        var oldOnMessage = global.onmessage;

                        global.onmessage = function() {
                            postMessageIsAsynchronous = false;
                        };

                        global.postMessage("", "*");
                        global.onmessage = oldOnMessage;
                        return postMessageIsAsynchronous;
                    }
                }

                function installPostMessageImplementation() {
                    // Installs an event handler on `global` for the `message` event: see
                    // * https://developer.mozilla.org/en/DOM/window.postMessage
                    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
                    var messagePrefix = "setImmediate$" + Math.random() + "$";

                    var onGlobalMessage = function onGlobalMessage(event) {
                        if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                            runIfPresent(+event.data.slice(messagePrefix.length));
                        }
                    };

                    if (global.addEventListener) {
                        global.addEventListener("message", onGlobalMessage, false);
                    } else {
                        global.attachEvent("onmessage", onGlobalMessage);
                    }

                    registerImmediate = function registerImmediate(handle) {
                        global.postMessage(messagePrefix + handle, "*");
                    };
                }

                function installMessageChannelImplementation() {
                    var channel = new MessageChannel();

                    channel.port1.onmessage = function(event) {
                        var handle = event.data;
                        runIfPresent(handle);
                    };

                    registerImmediate = function registerImmediate(handle) {
                        channel.port2.postMessage(handle);
                    };
                }

                function installReadyStateChangeImplementation() {
                    var html = doc.documentElement;

                    registerImmediate = function registerImmediate(handle) {
                        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                        var script = doc.createElement("script");

                        script.onreadystatechange = function() {
                            runIfPresent(handle);
                            script.onreadystatechange = null;
                            html.removeChild(script);
                            script = null;
                        };

                        html.appendChild(script);
                    };
                }

                function installSetTimeoutImplementation() {
                    registerImmediate = function registerImmediate(handle) {
                        setTimeout(runIfPresent, 0, handle);
                    };
                } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


                var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
                attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

                if ({}.toString.call(global.process) === "[object process]") {
                    // For Node.js before 0.9
                    installNextTickImplementation();
                } else if (canUsePostMessage()) {
                    // For non-IE10 modern browsers
                    installPostMessageImplementation();
                } else if (global.MessageChannel) {
                    // For web workers, where supported
                    installMessageChannelImplementation();
                } else if (doc && "onreadystatechange" in doc.createElement("script")) {
                    // For IE 6–8
                    installReadyStateChangeImplementation();
                } else {
                    // For older browsers
                    installSetTimeoutImplementation();
                }

                attachTo.setImmediate = setImmediate;
                attachTo.clearImmediate = clearImmediate;
            })(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
            /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(0), __webpack_require__(5)))

        /***/
    }),
    /* 5 */
    /***/
    (function(module, exports) {

        // shim for using process in browser
        var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
        }

        function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
        }

        (function() {
            try {
                if (typeof setTimeout === 'function') {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }

            try {
                if (typeof clearTimeout === 'function') {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        })();

        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                //normal enviroments in sane situations
                return setTimeout(fun, 0);
            } // if setTimeout wasn't available but was latter defined


            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }

            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }

        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                //normal enviroments in sane situations
                return clearTimeout(marker);
            } // if clearTimeout wasn't available but was latter defined


            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }

            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }

        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }

            draining = false;

            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }

            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }

            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;

            while (len) {
                currentQueue = queue;
                queue = [];

                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }

                queueIndex = -1;
                len = queue.length;
            }

            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }

        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);

            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }

            queue.push(new Item(fun, args));

            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        }; // v8 likes predictible objects


        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }

        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };

        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues

        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function(name) {
            return [];
        };

        process.binding = function(name) {
            throw new Error('process.binding is not supported');
        };

        process.cwd = function() {
            return '/';
        };

        process.chdir = function(dir) {
            throw new Error('process.chdir is not supported');
        };

        process.umask = function() {
            return 0;
        };

        /***/
    })
    /******/
]);
/* This is the FedEx.com carousel component javascript file.
 The global FDX object must already be defined

 Author: quantrel.sanford@vml.com
 Created: 2017-10-05
 */

if (!FDX) {
    var FDX = {};
}

FDX.CAROUSEL = {
    carouselClass: ".fxg-carousel__carousel",
    carouselArray: [],
    carouselOuter: '.owl-wrapper-outer',
    carouselWrapper: '.owl-wrapper',
    carouselOwlItem: '.owl-item',
    arrowClass: ".fxg-carousel__arrow",
    prevArrow: ".fxg-carousel__arrow-prev",
    nextArrow: ".fxg-carousel__arrow-next",
    isRTL: $('html').attr('dir') === 'rtl' ? true : false,
    carouselPage: '.owl-page',

    initCarousels: function() {
        $(FDX.CAROUSEL.carouselClass).each(function(i, e) {
            var owl = $(e).owlCarousel({
                items: $(e).data('visible-count'),
                itemsDesktop: false,
                itemsDesktopSmall: false,
                itemsTablet: false,
                itemsTabletSmall: false,
                itemsMobile: [767, 1],
                scrollPerPage: true,
                autoHeight: true,
                afterMove: function(elem) {
                    FDX.CAROUSEL.afterMove(elem);
                }
            }).data('owlCarousel');

            if (owl.orignalItems > 1) {
                $('.owl-wrapper .owl-item').css('padding', '0px 10px 0px 10px');
            }

            if (owl.orignalItems < owl.itemsAmount) {
                $(e).parent().siblings(FDX.CAROUSEL.arrowClass).each(function(index, elem) {
                    $(elem).data("carousel-index", i);
                    $(elem).css('display', 'inline-block');
                });
            }

            if ($(e).data("jump-to") > 1) {
                // jump to specific slide number without animation. Useful for authoring on page load.
                owl.jumpTo($(e).data("jump-to") - 1);
            }

            FDX.CAROUSEL.carouselArray.push(owl);

        });
    },

    moveCarouselNext: function(index) {
        if (FDX.CAROUSEL.isRTL == false) {
            FDX.CAROUSEL.carouselArray[index].next();
        }
        if (FDX.CAROUSEL.isRTL == true) {
            FDX.CAROUSEL.carouselArray[index].prev();
            FDX.CAROUSEL.changeTransformXVal();
        }
    },

    moveCarouselPrev: function(index) {
        if (FDX.CAROUSEL.isRTL == false) {
            FDX.CAROUSEL.carouselArray[index].prev();
        }
        if (FDX.CAROUSEL.isRTL == true) {
            FDX.CAROUSEL.carouselArray[index].next();
            FDX.CAROUSEL.changeTransformXVal();
        }
    },

    afterMove: function(elem) {
        // only trigger after the video played
        //if(FDX.OOYALA.players.length > 0){
        //  FDX.CAROUSEL.checkVideosInCarousel(elem, elem.find(FDX.CAROUSEL.carouselWrapper));
        //}
    },

    checkVideosInCarousel: function(element, wrapper) {
        //Find wrapper and children for ooyala player
        $(element).find(FDX.OOYALA.playerClass).each(function() {
            var isInvisible = FDX.CORE.isVisiable(this, wrapper);
            // data-container-id attribute for video
            var containerId = $(this).attr('data-container-id');
            var playersId = FDX.OOYALA.players.map(function(e) {
                return e.getElementId();
            });

            // Checked is invisible of view and only pause the video inside of this element
            if (isInvisible && playersId.indexOf(containerId) !== -1) {
                FDX.OOYALA.pauseVideoInCarousel(containerId);
            }
        })
    },

    //carousel height adjustment for other slides based on max slide height.
    maxheightofslide: function() {
        $.each($(".owl-wrapper-outer .owl-wrapper"), function() {
            var owlItem = 0;
            var owlWrapper = $(this);
            owlWrapper.children(FDX.CAROUSEL.carouselOwlItem).each(function() {
                if (owlItem < this.clientHeight) {
                    owlItem = this.clientHeight;
                }
            });
            owlWrapper.children(FDX.CAROUSEL.carouselOwlItem).each(function() {
                $(this).css({
                    "height": owlItem
                });
            });
            $(this).parent().css({
                "height": owlItem
            });
        });
    },
    changeTransformXVal: function() {
        $('.owl-wrapper')
            .on('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function() {
                FDX.CAROUSEL.changeTransformOnLoad();

            })
    },

    changeTransformOnLoad: function() {
        $('.owl-wrapper').each(function() {
            var transformCss = $(this).css("transform");
            var transformXVal = parseInt(transformCss.split(",")[4]);
            var transform = "translate3d(" + -transformXVal + "px, 0px,0px)";
            var owlWrapStyle = $(this).attr("style").replace(
                "translate3d(" + transformXVal +
                "px, 0px, 0px)", transform);
            $(this).attr('style', owlWrapStyle);
        });
    }
};

$(window).on("load", function() {

    FDX.CAROUSEL.maxheightofslide();

    $(FDX.CAROUSEL.nextArrow).on('click', function() {
        FDX.CAROUSEL.moveCarouselNext($(this).data("carouselIndex"));
    });

    $(FDX.CAROUSEL.prevArrow).on('click', function() {
        FDX.CAROUSEL.moveCarouselPrev($(this).data("carouselIndex"));
    });

    $(FDX.CAROUSEL.carouselPage).on('click touchstart touchmove ', function(e) {
        if (FDX.CAROUSEL.isRTL === true) {
            FDX.CAROUSEL.changeTransformXVal();
        }
    });

    $(FDX.CAROUSEL.carouselOwlItem).on('click touchstart touchmove', function(e) {
        if (FDX.CAROUSEL.isRTL === true) {
            e.stopImmediatePropagation();
        }
    })

    if (FDX.CAROUSEL.isRTL === true) {
        FDX.CAROUSEL.changeTransformOnLoad(); // Call to modify the transform value in RTL mode
    }
});
$(document).ready(function() {
    FDX.CAROUSEL.initCarousels();
});


/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        module.exports = __webpack_require__(2);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * Breadcrumb
         *
         * Page trail navigation header
         */
        (function($, _) {
            window.FDX.components.breadcrumbs = function() {
                /**
                 * @type {Object[]} list of instances
                 */
                var instances = [];
                /**
                 * @type {string} root selector
                 */

                var selector = '.fxg-breadcrumbs';
                /**
                 * Create component instance
                 *
                 * @public
                 * @return {Object} instance
                 */

                function create() {
                    /**
                     * @type {Object} configuration
                     */
                    var config = {};
                    /**
                     * @type {Object} jQuery DOM root element
                     */

                    var $root = null;
                    /**
                     * Set configuration
                     *
                     * @public
                     * @param {Object} _config - key/value pair
                     * @return {Object} instance
                     */

                    function setConfig(_config) {}
                    /**
                     * Render HTML
                     *
                     * @private
                     * @return {Promise<string>} A promise that resolves with rendered HTML
                     */


                    function render() {}
                    /**
                     * Initialize component instance
                     *
                     * @public
                     * @param {Object} [_$root] compnent root element (optional)
                     * @return {Promise} A promise that resolves when instance is initiated
                     */


                    function init(_$root) {
                        var promise = $.Deferred();
                        $root = _$root; // initialized

                        $root.data('initialized', true);
                        promise.resolve();
                        return promise;
                    }
                    /**
                     * Get component element
                     *
                     * @public
                     * @return {Object} jQuery DOM element
                     */


                    function getElement() {
                        return $root;
                    } // add and return instance


                    var instance = {
                        setConfig: setConfig,
                        init: init,
                        getElement: getElement
                    };
                    instances.push(instance);
                    return instance;
                }
                /**
                 * Create instances
                 *
                 * @public
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function createInstances() {
                    var promise = $.Deferred();
                    var initPromises = []; // find all related elements

                    $(selector).each(function() {
                        // skip already initialized elements
                        var $element = $(this);
                        if ($element.data('initialized')) return; // create instance

                        var instance = window.FDX.components.breadcrumbs.create(); // initialize instance

                        var initPromise = instance.init($element);
                        initPromises.push(initPromise);
                    }); // resolve after all inits

                    $.when.apply($, initPromises).then(function() {
                        promise.resolve();
                    });
                    return promise;
                } // return component


                return {
                    create: create,
                    instances: instances,
                    createInstances: createInstances,
                    selector: selector
                };
            }();
        })(window.jQuery);

        /***/
    }),
    /* 2 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // extracted by mini-css-extract-plugin


        /***/
    })
    /******/
]);
if (!FDX) {
    var FDX = {};
}

FDX.APPBASE = {

    throttleURL: null,
    appJSpath: null,
    initFunction: null,
    userLoginFnCall: null,
    userLogoutFnCall: null,
    browserType: null,
    browserVersion: null,
    browserCondition: null,
    percntUserTraffic: null,
    dependentScripts: [],
    appBaseData: null,
    appBase: null,
    appState: false,
    dependencyType: null,
    extAppHTML: null,
    domainName: window.location.hostname,
    appThrottled: false,
    loadGenApp: false,
    isWebComponent: false,
    appBaseObject: true,

    loadAppData: function() {
        if (document.querySelector('.fxg-cube--active') !== null) {
            FDX.APPBASE.appBase = "";
            if (document.querySelector('.fxg-app--active input[name=baseData]') !== null) {
                FDX.APPBASE.appBase = document.querySelector('.fxg-app--active input[name=baseData]').value;
            }
        } else if (document.querySelector('.tracking_app input[name=baseData]') !== null) {
            FDX.APPBASE.appBase = document
                .querySelector('.tracking_app input[name=baseData]').value;
        } else if (document.querySelector('.tracking_app_v1 input[name=baseData]') !== null) {
            FDX.APPBASE.appBase = document
                .querySelector('.tracking_app_v1 input[name=baseData]').value;
        } else if (document.querySelector('.genericAppContainer input[name=baseData]') !== null) {
            FDX.APPBASE.appBase = document
                .querySelector('.genericAppContainer input[name=baseData]').value;
            FDX.APPBASE.loadGenApp = true;
            //Moved the App load call to Generic app load JS.
            /*setTimeout(function(){
				FDX.RATE_SHIP.externalAppInject();
            },0);*/
        }

    },

    loadAppBaseData: function() {

        FDX.APPBASE.appBaseData = JSON.parse(FDX.APPBASE.appBase);
        FDX.APPBASE.dependentScripts = [];
        //check for appBaseObject availability
        FDX.APPBASE.appBaseObject = !!FDX.APPBASE.appBaseData ? true : false;
        if (FDX.APPBASE.appBaseObject) {
            if ((FDX.BREAKPOINTS.getViewPort() == "mediumViewPort") && (!FDX.APPBASE.appBaseData.setLvDefault)) {
                console.log("The view port:: " + FDX.BREAKPOINTS.getViewPort())
                FDX.APPBASE.percntUserTraffic = FDX.APPBASE.appBaseData.mvUserTraffic;
                FDX.APPBASE.browserType = FDX.APPBASE.appBaseData.mvBrowserType;
                FDX.APPBASE.browserVersion = FDX.APPBASE.appBaseData.mvBrowserVersion;
                FDX.APPBASE.browserCondition = FDX.APPBASE.appBaseData.mvBrowserCondition;
                FDX.APPBASE.dependencyType = FDX.APPBASE.appBaseData.mvDependecyType;
                FDX.APPBASE.extAppHTML = FDX.APPBASE.appBaseData.mvExtAppHTML;
                FDX.APPBASE.isWebComponent = FDX.APPBASE.appBaseData.isWebComponent;


                if (FDX.APPBASE.appBaseData.mvScripts != null) {
                    for (var i = 0; i < FDX.APPBASE.appBaseData.mvScripts.length; i++) {
                        FDX.APPBASE.dependentScripts
                            .push(FDX.APPBASE.appBaseData.mvScripts[i]);
                    }
                }

                if (Number(FDX.THROTTLE.getThrottlePercentage()) <= Number(FDX.APPBASE.percntUserTraffic)) {

                    FDX.APPBASE.initFunction = FDX.APPBASE.appBaseData.mvInitializationFnmet;
                    FDX.APPBASE.throttleURL = FDX.APPBASE.appBaseData.mvURLrequestMet;

                    FDX.APPBASE.appJSpath = FDX.APPBASE.appBaseData.mvAppJSmet;

                    if ((FDX.APPBASE.appBaseData.mvLogsinPageReloadmet !== "") && (FDX.APPBASE.appBaseData.mvLogsinPageReloadmet != null)) {
                        FDX.APPBASE.userLoginFnCall = FDX.APPBASE.appBaseData.mvLogsinPageReloadmet;
                        $("body").on("loggedIn", FDX.APPBASE.userLoginFnCall);
                    }
                    if ((FDX.APPBASE.appBaseData.mvLogsoutPageReloadmet !== "") && (FDX.APPBASE.appBaseData.mvLogsoutPageReloadmet != null)) {
                        FDX.APPBASE.userLogoutFnCall = FDX.APPBASE.appBaseData.mvLogsoutPageReloadmet;
                        $("body").on("loggedOut", FDX.APPBASE.userLogoutFnCall);
                    }

                } else {
                    FDX.APPBASE.initFunction = FDX.APPBASE.appBaseData.mvInitializationFnNotmet;
                    FDX.APPBASE.throttleURL = FDX.APPBASE.appBaseData.mvURLrequestNotMet;

                    FDX.APPBASE.appJSpath = FDX.APPBASE.appBaseData.mvAppJSnotMet;

                    if ((FDX.APPBASE.appBaseData.mvLogsinPageReloadNotmet !== "") && (FDX.APPBASE.appBaseData.mvLogsinPageReloadNotmet != null)) {
                        FDX.APPBASE.userLoginFnCall = FDX.APPBASE.appBaseData.mvLogsinPageReloadNotmet;
                        $("body").on("loggedIn", FDX.APPBASE.userLoginFnCall);
                    }
                    if ((FDX.APPBASE.appBaseData.mvLogsoutPageReloadNotmet !== "") && (FDX.APPBASE.appBaseData.mvLogsoutPageReloadNotmet != null)) {
                        FDX.APPBASE.userLogoutFnCall = FDX.APPBASE.appBaseData.mvLogsoutPageReloadNotmet;
                        $("body").on("loggedOut", FDX.APPBASE.userLogoutFnCall);
                    }

                }
                FDX.APPBASE.loadThrottleURL(FDX.APPBASE.throttleURL);

            } else if ((FDX.BREAKPOINTS.getViewPort() == "smallViewPort") && (!FDX.APPBASE.appBaseData.setLvDefault)) {
                console.log("THe view port:: " + FDX.BREAKPOINTS.getViewPort())
                FDX.APPBASE.percntUserTraffic = FDX.APPBASE.appBaseData.svUserTraffic;
                FDX.APPBASE.browserType = FDX.APPBASE.appBaseData.svBrowserType;
                FDX.APPBASE.browserVersion = FDX.APPBASE.appBaseData.svBrowserVersion;
                FDX.APPBASE.browserCondition = FDX.APPBASE.appBaseData.svBrowserCondition;
                FDX.APPBASE.dependencyType = FDX.APPBASE.appBaseData.svDependecyType;
                FDX.APPBASE.extAppHTML = FDX.APPBASE.appBaseData.svExtAppHTML;
                FDX.APPBASE.isWebComponent = FDX.APPBASE.appBaseData.isWebComponent;

                if (FDX.APPBASE.appBaseData.svScripts != null) {
                    for (var i = 0; i < FDX.APPBASE.appBaseData.svScripts.length; i++) {
                        FDX.APPBASE.dependentScripts
                            .push(FDX.APPBASE.appBaseData.svScripts[i]);
                    }
                }

                if (Number(FDX.THROTTLE.getThrottlePercentage()) <= Number(FDX.APPBASE.percntUserTraffic)) {

                    FDX.APPBASE.initFunction = FDX.APPBASE.appBaseData.svInitializationFnmet;
                    FDX.APPBASE.throttleURL = FDX.APPBASE.appBaseData.svURLrequestMet;

                    FDX.APPBASE.appJSpath = FDX.APPBASE.appBaseData.svAppJSmet;

                    if ((FDX.APPBASE.appBaseData.svLogsinPageReloadmet !== "") && (FDX.APPBASE.appBaseData.svLogsinPageReloadmet != null)) {
                        FDX.APPBASE.userLoginFnCall = FDX.APPBASE.appBaseData.svLogsinPageReloadmet;
                        $("body").on("loggedIn", FDX.APPBASE.userLoginFnCall);
                    }
                    if ((FDX.APPBASE.appBaseData.svLogsoutPageReloadmet !== "") && (FDX.APPBASE.appBaseData.svLogsoutPageReloadmet != null)) {
                        FDX.APPBASE.userLogoutFnCall = FDX.APPBASE.appBaseData.svLogsoutPageReloadmet;
                        $("body").on("loggedOut", FDX.APPBASE.userLogoutFnCall);
                    }

                } else {

                    FDX.APPBASE.initFunction = FDX.APPBASE.appBaseData.svInitializationFnNotmet;
                    FDX.APPBASE.throttleURL = FDX.APPBASE.appBaseData.svURLrequestNotMet;

                    FDX.APPBASE.appJSpath = FDX.APPBASE.appBaseData.svAppJSnotMet;

                    if ((FDX.APPBASE.appBaseData.svLogsinPageReloadNotmet !== "") && (FDX.APPBASE.appBaseData.svLogsinPageReloadNotmet != null)) {
                        FDX.APPBASE.userLoginFnCall = FDX.APPBASE.appBaseData.svLogsinPageReloadNotmet;
                        $("body").on("loggedIn", FDX.APPBASE.userLoginFnCall);
                    }
                    if ((FDX.APPBASE.appBaseData.svLogsoutPageReloadNotmet !== "") && (FDX.APPBASE.appBaseData.svLogsoutPageReloadNotmet != null)) {
                        FDX.APPBASE.userLogoutFnCall = FDX.APPBASE.appBaseData.svLogsoutPageReloadNotmet;
                        $("body").on("loggedOut", FDX.APPBASE.userLogoutFnCall);
                    }

                }
                FDX.APPBASE.loadThrottleURL(FDX.APPBASE.throttleURL);
            } else {

                FDX.APPBASE.percntUserTraffic = FDX.APPBASE.appBaseData.lvUserTraffic;
                FDX.APPBASE.browserType = FDX.APPBASE.appBaseData.lvBrowserType;
                FDX.APPBASE.browserVersion = FDX.APPBASE.appBaseData.lvBrowserVersion;
                FDX.APPBASE.browserCondition = FDX.APPBASE.appBaseData.lvBrowserCondition;
                FDX.APPBASE.dependencyType = FDX.APPBASE.appBaseData.lvDependecyType;
                FDX.APPBASE.extAppHTML = FDX.APPBASE.appBaseData.lvExtAppHTML;
                FDX.APPBASE.isWebComponent = FDX.APPBASE.appBaseData.isWebComponent;

                if (FDX.APPBASE.appBaseData.lvScripts != null) {
                    for (var i = 0; i < FDX.APPBASE.appBaseData.lvScripts.length; i++) {
                        FDX.APPBASE.dependentScripts
                            .push(FDX.APPBASE.appBaseData.lvScripts[i]);
                    }
                }

                if (Number(FDX.THROTTLE.getThrottlePercentage()) <= Number(FDX.APPBASE.percntUserTraffic)) {

                    FDX.APPBASE.initFunction = FDX.APPBASE.appBaseData.lvInitializationFnmet;
                    FDX.APPBASE.throttleURL = FDX.APPBASE.appBaseData.lvURLrequestMet;

                    FDX.APPBASE.appJSpath = FDX.APPBASE.appBaseData.lvAppJSmet;

                    if ((FDX.APPBASE.appBaseData.lvLogsinPageReloadmet !== "") && (FDX.APPBASE.appBaseData.lvLogsinPageReloadmet != null)) {
                        FDX.APPBASE.userLoginFnCall = FDX.APPBASE.appBaseData.lvLogsinPageReloadmet;
                        $("body").on("loggedIn", FDX.APPBASE.userLoginFnCall);
                    }
                    if ((FDX.APPBASE.appBaseData.lvLogsoutPageReloadmet !== "") && (FDX.APPBASE.appBaseData.lvLogsoutPageReloadmet != null)) {
                        FDX.APPBASE.userLogoutFnCall = FDX.APPBASE.appBaseData.lvLogsoutPageReloadmet;
                        $("body").on("loggedOut", FDX.APPBASE.userLogoutFnCall);
                    }

                } else {

                    FDX.APPBASE.initFunction = FDX.APPBASE.appBaseData.lvInitializationFnNotmet;
                    FDX.APPBASE.throttleURL = FDX.APPBASE.appBaseData.lvURLrequestNotMet;

                    FDX.APPBASE.appJSpath = FDX.APPBASE.appBaseData.lvAppJSnotMet;

                    if ((FDX.APPBASE.appBaseData.lvLogsinPageReloadNotmet !== "") && (FDX.APPBASE.appBaseData.lvLogsinPageReloadNotmet != null)) {
                        FDX.APPBASE.userLoginFnCall = FDX.APPBASE.appBaseData.lvLogsinPageReloadNotmet;
                        $("body").on("loggedIn", FDX.APPBASE.userLoginFnCall);
                    }
                    if ((FDX.APPBASE.appBaseData.lvLogsoutPageReloadNotmet !== "") && (FDX.APPBASE.appBaseData.lvLogsoutPageReloadNotmet != null)) {
                        FDX.APPBASE.userLogoutFnCall = FDX.APPBASE.appBaseData.lvLogsoutPageReloadNotmet;
                        $("body").on("loggedOut", FDX.APPBASE.userLogoutFnCall);
                    }

                }
                FDX.APPBASE.loadThrottleURL(FDX.APPBASE.throttleURL);
            }
        }

        return {
            throttleURL: FDX.APPBASE.throttleURLConditionNotMet,
            appJSpath: FDX.APPBASE.appJSpath,
            initFunction: FDX.APPBASE.initFunction,
            userLoginFnCall: FDX.APPBASE.userLoginFnCall,
            userLogoutFnCall: FDX.APPBASE.userLogoutFnCall,
            browserType: FDX.APPBASE.browserType,
            browserVersion: FDX.APPBASE.browserVersion,
            browserCondition: FDX.APPBASE.browserCondition,
            percntUserTraffic: FDX.APPBASE.percntUserTraffic,
            dependentScripts: FDX.APPBASE.dependentScripts,
            dependencyType: FDX.APPBASE.dependencyType,
            extAppHTML: FDX.APPBASE.extAppHTML,
        };
    },

    loadThrottleURL: function(url) {
        if ((typeof(url) !== "undefined") && (url !== null) && (url !== "") && window.top.location.href.indexOf('/editor.html/') < 0) {
            FDX.APPBASE.appThrottled = true;
            $(".fxg-cube.fxg-cube--active").attr("data-link-path", url);
            if ($(".fxg-cube.fxg-cube--active").hasClass("notTarget")) {
                window.open(url, "_self");
            }


        }
    }
}
FDX.APPBASE.loadAppData();
if (!FDX) {
    var FDX = {};
}

FDX.GENERIC_APPLOAD = {

    isBrand: false,

    dependentScriptLoaded: false,

    loadDepScripts: function() {

        var def = $.Deferred();

        if ((FDX.APPBASE.dependentScripts.length > 0) &&
            !FDX.GENERIC_APPLOAD.dependentScriptLoaded) {

            var scriptTag = [];
            for (var i = 0; i < FDX.APPBASE.dependentScripts.length; i++) {
                var scriptID = 'dep' + [i];
                scriptTag[i] = document.createElement('script');
                scriptTag[i].src = FDX.APPBASE.dependentScripts[i];
                scriptTag[i].id = scriptID;
                scriptTag[i].async = true;

                var headTag = document.getElementsByTagName('head')[0];
                headTag.appendChild(scriptTag[i]);
            }

            def.resolve();
            FDX.GENERIC_APPLOAD.dependentScriptLoaded = true;
            console.log("Dependent scripts executed!!");
        }
        return def.promise();
    },

    externalAppInject: function() {

        var externalAppID = document.getElementById("app-external").value;
        var externalAppURL = document.getElementById("app-external-url").value;
        var fdx = FDX;
        //FDX.APPBASE.loadAppBaseData();

        if ((typeof(externalAppID) !== "undefined") && externalAppID !== null) {

            try {

                jQuery.ajax({
                    type: "GET",
                    url: FDX.APPBASE.extAppHTML,
                    cache: false,
                    crossDomain: true,

                    success: function(result) {
                        try {

                            if (FDX.GENERIC_APPLOAD.isBrand) {
                                result = result.replace('<base href="/fedex-brand/">', '<base href="" taget="_blank">');
                                result = result.replaceAll("./assets", "/fedex-brand/assets");
                                localStorage.setItem("aemFlag", true);
                                localStorage.setItem("brand-aem", FDX.APPBASE.extAppHTML.split("/")[2]);
                            }
                            $.when(jQuery("#" + externalAppID).append(result))
                                .then(function() {
                                    FDX = fdx;
                                    setTimeout(function() {
                                        FDX.CUBE.openApp();
                                    }, 300);
                                });

                        } catch (e) {
                            // fdx_debug(e, "IM", "loadApp:success");
                        }
                    },

                });
            } catch (e) {
                console.error(e);
            }
        }

    },

};

/*if (FDX.APPBASE.loadGenApp && !FDX.APPBASE.appThrottled) {
	FDX.GENERIC_APPLOAD.loadDepScripts();
}*/

$(document).ready(function() {
    if (FDX.APPBASE.loadGenApp && !FDX.APPBASE.appThrottled) {
        if (window.top.location.href.indexOf('/editor.html/') < 0) {
            FDX.APPBASE.loadAppBaseData();
            FDX.GENERIC_APPLOAD.loadDepScripts();
            FDX.GENERIC_APPLOAD.isBrand = fdx.isBrand;
            setTimeout(function() {
                FDX.GENERIC_APPLOAD.externalAppInject();
            }, 50);
        }
    }
});


/* This is the FedEx.com API Form Validator component javascript file.

 Author: troy.gottier.osv@fedex.com
 Created: 2018-09-25
 */
if (!FDX) {
    var FDX = {};
}

$(document).ready(function() {
    "use strict";

    var form = $(".fx-apiform_validator"),
        submitButton = $(".fx-av_submit_button"),
        errorContainer = '<div role="alert" class="fxg-field__validation"></div>',
        formIsValid = false;

    form.on('submit', function(e) {

        var fields = $(this).find(".fx-av_fields").find("input"),
            validArray = [];

        $.each(fields, function() {
            var list = $(this).siblings(".fx-av_vlist").text(),
                errorMessage = $(this).siblings(".fx-av_error").text(),
                inputValue = $(this).val(),
                required = $(this).attr("data-required"),
                fieldIsValid = false;

            if (required == "notRequired") {
                // If field is not required but has a list of valid values,
                // Then blank space is a valid value. Add to var list
                list = list + ", ";
            }
            if (list.length > 0) {
                fieldIsValid = validateList(inputValue, list);
                validArray.push(fieldIsValid);
            }

            if (fieldIsValid) {
                // remove the error container if there is no error to show
                $(this).removeClass("fxg-field__input--error").attr("aria-invalid", "false");
                $(this).siblings(".fxg-field__validation").remove();
                //custom button behavior 
                form.find(".fx-av_submit_wrap").css("padding-top", "35px");
            } else {
                displayError($(this), errorMessage);
                //custom button behavior 
                form.find(".fx-av_submit_wrap").css("padding-top", "10px");
            }


        });

        if ($.inArray(false, validArray) !== -1) {
            // Prevent form submission. Do Nothing. Field errors will be displayed.
            e.preventDefault();
        }
        // Form validated and will now submit.

        function displayError(input, reason) {
            //remove the previous error and display the new error.
            input.siblings(".fxg-field__validation").remove();
            input.addClass("fxg-field__input--error").attr("aria-invalid", "true");
            input.after(errorContainer);
            input.siblings(".fxg-field__validation").text(reason);
        }

        function validateList(value, list) {
            var arrayList = list.replace(/,\s+/g, ',').split(','),
                validationStatus = false;

            arrayList.map(function(item) {
                if (item.indexOf('*') > -1) {
                    // Wildcard validation string. 
                    if (item.length == value.length) {
                        // possible match is length is the same.
                        var charArray = item.split(''),
                            valCharArray = value.split(''),
                            wordTest = true;

                        for (var i = 0; i < item.length; i++) {
                            if (wordTest == true && ((charArray[i] == valCharArray[i]) || charArray[i] == "*")) {
                                // If character matches or wildcard is present (*) - PASS

                            } else {
                                wordTest = false;
                            }
                        }
                        if (wordTest == true) {
                            validationStatus = true;
                        }
                    }

                } else if (item == value) {
                    // strings match value has been found
                    validationStatus = true;
                }

            });
            if (validationStatus == true) {
                // Validation Success
                return true;
            }
            // Validation Failed
            return false;
        }

    });
});
/* This is the FedEx.com alert component javascript file.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-06-30
 */

if (!FDX) {
    var FDX = {};
}

FDX.ALERT = {
    alertClass: 'fxg-alert',
    showAlertClass: 'fxg-alert--show',
    detailsClass: 'fxg-alert__details',
    detailsBtnClass: 'fxg-alert__details-btn',
    detailsShowClass: 'fxg-alert__details--show',
    closeButtonClass: 'fxg-alert__close-btn',
    cookieNameAttr: 'data-cname',
    cookieExpireAttr: 'data-cexpire',
    hiddenClass: 'fxg-hidden',

    setAlertCookie: function(elem) {
        var cname = $(elem).attr(FDX.ALERT.cookieNameAttr);
        var cexpire = $(elem).attr(FDX.ALERT.cookieExpireAttr);

        if (FDX.SESSION) {
            // set the cookie alert
            FDX.SESSION.setCookieBySeconds(cname, Math.floor(Date.now() / 1000), cexpire);
        }
    },
    closeAlert: function(elem) {
        var cname = $(elem).attr(FDX.ALERT.cookieNameAttr);
        $('.' + cname).removeClass(FDX.ALERT.showAlertClass);
        FDX.HEADER.calcHeight();
    },
    toggleAlertDetails: function(elem) {
        $(elem).parent().toggleClass(FDX.ALERT.detailsShowClass);
        FDX.HEADER.calcHeight();
    },
}

$(document).ready(function() {
    $('header').on('click keydown', '.' + FDX.ALERT.closeButtonClass, function(e) {
        if (e.type === 'keydown' && e.which !== 13) {
            return;
        }

        var cookieConsentWrapper = $('.js-init-fdx-cookie-consent').find('.fxg-cookie-consent__wrapper');
        var CookieConsent = window.FDX.CookieConsent();

        e.preventDefault();
        FDX.ALERT.closeAlert($(this));
        FDX.ALERT.setAlertCookie($(this));
        if (CookieConsent) CookieConsent.setPosition(cookieConsentWrapper);
    })

    $('header').on('click keydown', '.' + FDX.ALERT.detailsBtnClass, function(e) {
        if (e.type === 'keydown' && e.which !== 13) {
            return;
        }

        var cookieConsentWrapper = $('.js-init-fdx-cookie-consent').find('.fxg-cookie-consent__wrapper');
        var CookieConsent = window.FDX.CookieConsent();

        e.preventDefault();

        $(this)
            .find('a')
            .toggle(0, function() {
                if ($(this).hasClass(FDX.ALERT.hiddenClass)) {
                    $(this).removeClass(FDX.ALERT.hiddenClass);
                    $(this).focus();
                } else {
                    $(this).addClass(FDX.ALERT.hiddenClass);
                }
            });

        FDX.ALERT.toggleAlertDetails(this);
        if (CookieConsent) CookieConsent.setPosition(cookieConsentWrapper);
    })

})





/*
This file is appending Alert content to alert component after getting response from AJAX.
The Servlet is sending the alerts in a list. 0th element being highest priority alert.
The code will check the cookies for corresponding alert and if cookie is not present in browser
then the respective alert will be shown on browser. Else next alert will be shown.
Cookies are set once user closes the alert. It means User got the alert and now next alert should be 
shown to the user.
*/

if (!FDX) {
    var FDX = {};
}

// FDX.ALERT_CONETNT will only return one public function i.e showAlert. Others are specific and need not to be made public.
FDX.ALERT_CONTENT = (function() {
    var addHeaderClasses = function(alert) {
        if (alert.location === 'footer') {
            return ("<div class='fxg-alert fxg-alert__" + alert.cookieUniqueID + " " + alert.showAlertClass + " " + alert.noDetailsClass + " " + alert.alertColor + " " + alert.hideOnDesktop + " " + alert.hideOnTablet + " " + alert.hideOnMobile + " fxg-alert__footer js-alert-footer'>" + "<div class='fxg-wrapper'>");
        } else {
            return ("<div class='fxg-alert fxg-alert__" + alert.cookieUniqueID + " " + alert.showAlertClass + " " + alert.noDetailsClass + " " + alert.alertColor + " " + alert.hideOnDesktop + " " + alert.hideOnTablet + " " + alert.hideOnMobile + " js-alert-header'>" + "<div class='fxg-wrapper'>");
        }
    };
    var showAlertIcon = function(alert) {
        return (alert.showIcon == 'yes' ? "<span class='fxg-alert__icon'>" + alert.alertIcon + "</span>" : "");
    };
    var showAlertText = function(alert) {
        return (alert.showIcon === 'yes' ? "<div class='fxg-alert__text fxg-alert__text-spacer'>" + alert.alertText + "</div>" : "<div class='fxg-alert__text'>" + alert.alertText + "</div>");
    };
    var showAlertDetails = function(alert) {
        return (alert.showDetails == 'yes' ? " <span class='fxg-alert__details-info'> " + alert.alertDetails + "</span>" : "")
    };
    var showAlertOnLoad = function(alert) {
        return (alert.detailsOpen === 'yes' ? "<div>" + "<a href='#' role='button' aria-label='" + alert.alertsAltSeeDetailsButton + "' class='fxg-link fxg-hidden' style='display: none'>" + alert.alertsDetailsButton + "</a>" + "<a href='#' role='button' aria-label='" + alert.alertsAltHideDetailsButton + "' class='fxg-link'>" + alert.alertsHideDetailsButton + "</a>" + "<span>" + alert.alertDetailsChevronIcon + "</span>" + "</div >" : "");
    };
    var doNotShowAlertOnLoad = function(alert) {
        return (alert.detailsOpen === "no" ? "<div>" + "<a href='#' role='button' aria-label='" + alert.alertsAltSeeDetailsButton + "' class='fxg-link'>" + alert.alertsDetailsButton + "</a>" + "<a href='#' class='fxg-link fxg-hidden' role='button' aria-label='" + alert.alertsAltHideDetailsButton + "' style='display: none'>" + alert.alertsHideDetailsButton + "</a>" + "<span>" + alert.alertDetailsChevronIcon + "</span>" + "</div >" : "");
    };
    var showAlertDetailsButton = function(alert) {
        return (alert.showDetails == 'yes' ? "<div  class='fxg-alert__details-btn'>" + showAlertOnLoad(alert) + doNotShowAlertOnLoad(alert) + "</div>" : "")
    };
    var addShowAlertDetailsClass = function(alert) {
        return (alert.detailsOpen === 'yes' ? alert.showAlertDetailsClass : "");
    };
    var adjustShowDetailsIcon = function(alert) {
        return (alert.showIcon === 'yes' ? "<div class='fxg-alert__details fxg-alert__details-icon-spacer " + addShowAlertDetailsClass(alert) + "'>" : " <div class='fxg-alert__details " + alert.detailsOpen + "'>");
    };
    var showDetailsSection = function(alert) {
        return (alert.alertDetails ? adjustShowDetailsIcon(alert) + showAlertDetails(alert) + showAlertDetailsButton(alert) + "</div>" : "")
    };
    var closeIcon = function(alert) {
        return (alert.isDismissible == 'yes' ? " <span  tabindex='0' role='button' aria-label='" + alert.closeButtonAltText + "' class='fxg-alert__close-btn' data-cname='fxg-alert__" + alert.cookieUniqueID + "'" + " data-cexpire= " + alert.cookieExpire + " >" + alert.alertCloseIcon + "</span>" : "");
    };
    var showAlert = function(alert) {
        return (addHeaderClasses(alert) + showAlertIcon(alert) + showAlertText(alert) + showDetailsSection(alert) + closeIcon(alert) + "</div></div>")
    };

    // GDPR Template.
    var alertCookieTemplate = function() {
        return '' +
            '<div class="fxg-cookie-consent fxg-cookie-consent--footer js-init-fdx-cookie-consent">' +
            '<div class="fxg-cookie-consent__wrapper u-scroll-vertical">' +
            '<div class="fxg-wrapper">' +

            '<span class="fxg-cookie-consent__icon">' +
            '<%= alertIcon %>' +
            '</span>' +

            '<h5 class="fxg-cookie-consent__title"><%= gdprtitle %></h5>' +

            '<div class="fxg-cookie-consent__body">' +

            '<div class="fxg-cookie-consent__text">' +
            '<%= alertText %>' +
            '</div>' +

            '<form>' +
            '<fieldset>' +

            '<div class="fxg-cookie-consent__settings">' +

            '<% if(option1Label) { %>' +
            '<div class="fxg-form-element__checkbox-label js-fxg-cookie-option <% if(isOption1Disabled) { %> is-disabled  <% } %>">' +
            '<input type="checkbox" <% if(isOption1Selected) { %> checked <% } %> <% if(isOption1Disabled) { %> disabled  <% } %> name="level1" id="level1">' +
            '<label for="level1">' +
            '<%= option1Label %>' +
            '</label>' +
            '</div>' +
            '<% } %>' +

            '<% if(option2Label) { %>' +
            '<div class="fxg-form-element__checkbox-label js-fxg-cookie-option <% if(isOption2Disabled) { %> is-disabled  <% } %>">' +
            '<input type="checkbox" <% if(isOption2Selected) { %> checked <% } %> <% if(isOption2Disabled) { %> disabled  <% } %> name="level2" id="level2">' +
            '<label for="level2">' +
            '<%= option2Label %>' +
            '</label>' +
            '</div>' +
            '<% } %>' +

            '<% if(option3Label) { %>' +
            '<div class="fxg-form-element__checkbox-label js-fxg-cookie-option <% if(isOption3Disabled) { %> is-disabled  <% } %>">' +
            '<input type="checkbox" <% if(isOption3Selected) { %> checked <% } %> <% if(isOption3Disabled) { %> disabled  <% } %> name="level3" id="level3">' +
            '<label for="level3">' +
            '<%= option3Label %>' +
            '</label>' +
            '</div>' +
            '<% } %>' +

            '<% if(option4Label) { %>' +
            '<div class="fxg-form-element__checkbox-label js-fxg-cookie-option <% if(isOption4Disabled) { %> is-disabled  <% } %>">' +
            '<input type="checkbox" <% if(isOption4Selected) { %> checked <% } %> <% if(isOption4Disabled) { %> disabled  <% } %> name="level4" id="level4">' +
            '<label for="level4">' +
            '<%= option4Label %>' +
            '</label>' +
            '</div>' +
            '<% } %>' +

            '</div>' +

            '<% if(alertDetails) { %>' +
            '<div class="fxg-cookie-consent__text">' +
            '<%= alertDetails %>' +
            '</div>' +
            '<% } %>' +

            '<div class="fxg-cookie-consent__actions">' +
            '<button class="fxg-cookie-consent__apply fxg-button fxg-button--orange fxg-button--orange-secondary js-fxg-cookie-save"><%= secondarybuttontext %></button>' +
            '<button class="fxg-cookie-consent__accept fxg-button fxg-button--orange js-fxg-cookie-save is-save-all"><%= primarybuttontext %></button>' +
            '</div>' +
            '</fieldset>' +
            '</form>' +
            '</div>' +

            '</div>' +
            '</div>' +
            '</div>';
    };

    // construct cookie consent context/data as configured in the template.
    var cookieConsentData = function(alert) {
        var data = {};

        data.alertIcon = alert.alertIcon || '';
        data.alertText = alert.alertText || '';
        data.gdprtitle = alert.gdprtitle || '';
        data.alertDetails = alert.alertDetails || '';
        data.isCookieConsent = alert.isCookieConsent || '';

        data.option1Label = alert.option1Label || '';
        data.isOption1Selected = alert.isOption1Selected || '';
        data.isOption1Disabled = alert.isOption1Disabled || '';

        data.option2Label = alert.option2Label || '';
        data.isOption2Selected = alert.isOption2Selected || '';
        data.isOption2Disabled = alert.isOption2Disabled || '';

        data.option3Label = alert.option3Label || '';
        data.isOption3Selected = alert.isOption3Selected || '';
        data.isOption3Disabled = alert.isOption3Disabled || '';

        data.option4Label = alert.option4Label || '';
        data.isOption4Selected = alert.isOption4Selected || '';
        data.isOption4Disabled = alert.isOption4Disabled || '';

        data.primarybuttontext = alert.primarybuttontext || '';
        data.secondarybuttontext = alert.secondarybuttontext || '';

        return data;
    };

    var fetchCookieConsent = function(alert) {
        var alertData = cookieConsentData(alert);
        var baseTemplate = alertCookieTemplate();
        var alertCookieConsent = $(_.template(baseTemplate)(alertData));

        return alertCookieConsent || '';
    };

    return {
        getAlert: showAlert,
        getAlertCookieConsent: fetchCookieConsent
    };
})();
//Once the jquery is loaded, the ajax call will be made. On success, the alert will be extracted and specific alert gets appended in the alert component.
$(document).ready(function() {
    var jsonDataTemplate = {
        alertText: "",
        cookieUniqueID: "",
        showAlertClass: "",
        noDetailsClass: "",
        alertColor: "",
        hideOnDesktop: "",
        hideOnTablet: "",
        hideOnMobile: "",
        showIcon: "",
        alertIcon: "",
        detailsOpen: "",
        alertDetails: "",
        showDetails: "",
        alertDetailsButton: "",
        alertHideDetailsButton: "",
        alertDetailsChevronIcon: "",
        isDismissible: "",
        closeButtonAltText: "",
        cookieExpire: ""
    };
    var $body = $('body');
    var countryParam = FDX.DATALAYER.page.pageInfo.country;
    var regionParam = FDX.DATALAYER.page.pageInfo.region;
    var localeParam = FDX.DATALAYER.page.pageInfo.locale;
    var pathParam = encodeURI(window.location.pathname);
    var brand = "false";
    var trimPath = pathParam.replace(/\/aem._l./i, '');
    if (pathParam.match("^/apps")) {
        FDX.contextPath = "";
    }
    if (FDX.contextPath == undefined) {
        if (typeof(fdx) !== 'undefined') {
            FDX.contextPath = fdx.context.envtVar;
        }
    }
    if (typeof(fdx) !== 'undefined' && fdx.isBrand !== 'undefined' && fdx.isBrand == "true") {
        brand = "true";
    }
    var apiURL = FDX.contextPath + "/etc/services/getalerts." + brand + "." + regionParam + "." + countryParam + "." + localeParam + "." + trimPath + ".jsonp";


    /*To FIX ERROR on console  */
    var host = encodeURI(window.location.host);


    if (host.indexOf("www") > -1 || FDX.DATALAYER.page.category.pageType == "sharednav") {
        // always 'https' protocol in PROD/L6 envi
        apiURL = ("https://" + host + "/etc/services/getalerts." + brand + "." + regionParam + "." + countryParam + "." + localeParam + "." + trimPath + ".jsonp");
    }


    var calculateDateTime = function(ms) {
        var date = new Date(ms);
        var options = {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            hour12: true
        };
        return FDX.SESSION ? (new Intl.DateTimeFormat(FDX.SESSION.getCookie("fdx_locale").replace("_", "-"), options).format(date)) : '';
    };
    var replaceDateTime = function(alert) {
        if (alert.toFromShow === 'yes') {
            alert.alertDetails = alert.alertDetails.replace("$[to]", calculateDateTime(alert.to));
            alert.alertDetails = alert.alertDetails.replace("$[from]", calculateDateTime(alert.from));
            alert.alertText = alert.alertText.replace("$[to]", calculateDateTime(alert.to));
            alert.alertText = alert.alertText.replace("$[from]", calculateDateTime(alert.from));
        }
        return alert;
    };
    $.when($.ajax(apiURL)).then(function(data, textStatus, jqXHR) {
        if (!data) {
            // if No data then do nothing.
            return;
        }

        var jsonDataFull = data;
        var alertArray = [];
        var headerAlert = {};
        var footerAlert = {};
        if (typeof data === 'string') {
            jsonDataFull = JSON.parse(data);
        }
        if (jsonDataFull.finalAlertData) {
            for (var i = 0; i < jsonDataFull.finalAlertData.length; i++) {
                var jsonData = {};
                jsonData = $.extend({}, jsonDataTemplate);
                jsonData = $.extend(jsonData, jsonDataFull.finalAlertData[i]);
                alertArray.push(jsonData);
            }
        }
        for (var i = 0; i < alertArray.length; i++) {
            if (alertArray[i]['cookieUniqueID']) {
                var cookie_name = "fxg-alert__" + alertArray[i]['cookieUniqueID'];
                if (FDX.SESSION && !FDX.SESSION.getCookie(cookie_name)) {
                    if (Object.keys(footerAlert).length === 0 && alertArray[i].location === 'footer') {
                        footerAlert = $.extend({}, alertArray[i]);
                    } else if (Object.keys(headerAlert).length === 0 && alertArray[i].location === 'header') {
                        headerAlert = $.extend({}, alertArray[i]);
                    }
                    if (Object.keys(footerAlert).length !== 0 && Object.keys(headerAlert).length !== 0) {
                        break;
                    }
                }
            }
        }

        // reset the state of alerts on body tag
        $body.removeClass('has-alert-footer has-alert-header has-cookie-consent');

        if (Object.keys(footerAlert).length !== 0) {
            var ftContent = '';
            footerAlert = replaceDateTime(footerAlert);

            if (footerAlert.hideOnDesktop === "on") {
                footerAlert.hideOnDesktop = "fxg-desktop--hide";
            }

            if (footerAlert.hideOnTablet === "on") {
                footerAlert.hideOnTablet = "fxg-tablet--hide";
            }

            if (footerAlert.hideOnMobile === "on") {
                footerAlert.hideOnMobile = "fxg-mobile--hide";
            }

            if (footerAlert.gdprmodal === 'on') {
                ftContent = FDX.ALERT_CONTENT.getAlertCookieConsent(footerAlert);
                $('fedex-cookie-consent').append(ftContent);
                $body.addClass('has-cookie-consent');
            } else {
                ftContent = FDX.ALERT_CONTENT.getAlert(footerAlert);
                $("fedex-alert").append(ftContent);
                $body.addClass('has-alert-footer');
            }
        }

        if (Object.keys(headerAlert).length !== 0) {


            if (headerAlert.hideOnDesktop === "on") {
                headerAlert.hideOnDesktop = "fxg-desktop--hide";
            }

            if (headerAlert.hideOnTablet === "on") {
                headerAlert.hideOnTablet = "fxg-tablet--hide";
            }

            if (headerAlert.hideOnMobile === "on") {
                headerAlert.hideOnMobile = "fxg-mobile--hide";
            }

            headerAlert = replaceDateTime(headerAlert);
            var hdContent = FDX.ALERT_CONTENT.getAlert(headerAlert);
            if (hdContent) {
                $("fedex-alert").append(hdContent);
                $body.addClass('has-alert-header');
                FDX.HEADER.calcHeight();
            }
        }

        // init the cookie consent when the cookieConsent is added to DOM 
        if ($('body.has-cookie-consent').length !== 0) {
            var ckConsent = window.FDX.CookieConsent();
            ckConsent.checkInit();
        }

    });
});
$(document).ready(function() {
    (function() {
        var htmlTag = document.querySelector('html');
        var dir = htmlTag.getAttribute('dir');
        var alertTag = document.querySelector('fedex-alert');
        if (FDX && FDX.SESSION && FDX.CORE) {
            var lang = FDX.SESSION.getCookie('fdx_locale');

            if (!dir) { //if page does not have dir attribute
                //if page has fdx_locale cookie and cookie value is arabic or hebrew
                if (lang && (lang.indexOf('ar') >= 0 || lang.indexOf('he') >= 0)) {
                    alertTag.setAttribute('dir', 'rtl');
                } else { //if cookie is NOT arabic or hebrew
                    htmlTag.setAttribute('dir', 'ltr');
                }
                // set the container element
                FDX.CORE.mainContentWrapper = ".fxg-sharednav";
                // recalculate the header height
                FDX.HEADER.calcHeight();
            }
        }
    })();
});
/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        module.exports = __webpack_require__(1);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * Adaptive Form
         *
         * Adaptive form container responsible for loading and submitting form created by AAF editor
         */
        (function($, _, $fetch, $analytics, $utils) {
            window.FDX.components.adaptiveform = function() {
                /**
                 * @type {Object[]} list of instances
                 */
                var instances = [];
                /**
                 * @type {string} root selector
                 */

                var selector = '.fxg-adaptiveform';
                /**
                 * Create component instance
                 *
                 * @public
                 * @return {Object} instance
                 */

                function create() {
                    /**
                     * @type {Object} configuration
                     */
                    var config = {};
                    /**
                     * @type {Object} jQuery DOM root element
                     */

                    var $root = null;
                    /**
                     * @type {Object} jQuery DOM loader element
                     */

                    var $loader = null;
                    /**
                     * Set configuration
                     *
                     * @public
                     * @param {Object} _config - key/value pair
                     * @return {Object} instance
                     */

                    function setConfig(_config) {
                        var defaultConfig = {
                            formId: '',
                            analytics: '',
                            formPath: '',
                            lang: '',
                            thankyouConfig: '',
                            thankyouPage: '',
                            failureConfig: '',
                            failurePage: '',
                            placeholders: '{}'
                        };
                        config = $.extend({}, defaultConfig, _config);
                    }

                    ;
                    /**
                     * Render HTML
                     *
                     * @private
                     * @return {Promise<string>} A promise that resolves with rendered HTML
                     */

                    function render() {}
                    /**
                     * Bind interactions events
                     *
                     * @private
                     */


                    function bindInteractions() {}
                    /**
                     * Initialize component instance
                     *
                     * @public
                     * @param {Object} [_$root] compnent root element (optional)
                     * @return {Promise} A promise that resolves when instance is initiated
                     */


                    function init(_$root) {
                        var promise = $.Deferred();
                        $root = _$root;
                        $loader = $root.find('.fxg-adaptiveform__loader'); // load form

                        loadForm().then(function() {
                            //  GDL VIEW EVENT
                            var payload = {
                                gdl: {
                                    category: 'form',
                                    eventName: 'view',
                                    params: {
                                        'name': config.analytics
                                    }
                                }
                            };
                            $analytics.push(payload); // initialized

                            $root.data('initialized', true);
                            promise.resolve();
                        });
                        return promise;
                    }
                    /**
                     * Get component element
                     *
                     * @public
                     * @return {Object} jQuery DOM element
                     */


                    function getElement() {
                        return $root;
                    }
                    /**
                     * Trigger GDL error event for every field validation failure,
                     *
                     * @private
                     * @param {Object} payload object containing array list with error messages
                     */


                    function handleValidationComplete(payload) {
                        $loader.addClass('fxg-hidden');
                        payload.newText.forEach(function(error) {
                            var _field;

                            // GDL event for Error validation
                            // DTM event is not required for error validation event
                            var detailedName = error.som || '';

                            var field = _.split(detailedName, '.');

                            var source = (_field = field[field.length - 1]) === null || _field === void 0 ? void 0 : _field.replace('[0]', '');
                            var payload = {
                                gdl: {
                                    category: 'error',
                                    eventName: 'error',
                                    params: {
                                        'type': 'validation',
                                        'source': source,
                                        'message': error.errorText
                                    }
                                }
                            };
                            $analytics.push(payload);
                        });
                    }
                    /**
                     * Load form
                     *
                     * @private
                     */


                    function loadForm() {
                        var promise = $.Deferred();
                        var path = config.formPath + '.html?wcmmode=disabled&afAcceptLang=' + config.lang;
                        $fetch.ajax(path, '', {
                            'dataType': 'html'
                        }).then(function(data) {
                            var response = data || '';

                            if (response) {
                                // interpolate placeholders
                                response = interpolatePlaceholders(response); // remove unnecessary head tags

                                var $afDOM = $('<div/>').append(response);
                                $afDOM.find('title').remove();
                                $afDOM.find('meta').remove(); // to avoid CSS issues, we have to make sure we delete all the default AAF style sheets
                                // except the main adaptiveform-editor stylesheet

                                $afDOM.find('link[rel=stylesheet]:not([href*="adaptiveform-editor"])').remove(); // update the DOM, and evaluates the code embedded in the script tag.

                                $root.append($afDOM); // init form

                                initForm();
                            }

                            promise.resolve();
                        }, function(error) {
                            console.error(error);
                            promise.reject(error);
                        });
                        return promise;
                    }
                    /**
                     * Interpolate the placeholders using the configurations
                     *
                     * @param {string} html - The AAF HTML to be interpolated
                     * @return {string} The interpolated AAF HTML with placeholder values.
                     */


                    function interpolatePlaceholders(html) {
                        // parse placeholders json
                        var decoded = decodeURIComponent(config.placeholders) || '{}';
                        var placeholders = JSON.parse(decoded); // lets replace ${...} to $[...] prevent conflict with our placeholders

                        html = html.replace(/\$\{(\s*[a-zA-Z0-9_.-]+?\s*)\}/g, function(match, key) {
                            return '$[' + key + ']';
                        }); // interpolate placeholders in multiple iterations

                        var interpolated = '';
                        var lastInterpolated = html;
                        var continueInterpolating = true;
                        var loopSafe = 10;

                        while (continueInterpolating) {
                            // interpolate placeholders everywhere with format {placeholder}
                            interpolated = lastInterpolated.replace(/\{\s*([a-zA-Z0-9_.-]+?)\s*\}/g, function(match, key) {
                                return placeholders[key] || key;
                            }); // Continue interpolating ?

                            loopSafe--;
                            continueInterpolating = (!lastInterpolated || interpolated !== lastInterpolated) && loopSafe > 0;
                            lastInterpolated = interpolated;
                        } // lets replace $[...] back to $[...]


                        interpolated = interpolated.replace(/\$\[(\s*[a-zA-Z0-9_.-]+?\s*)\]/g, function(match, key) {
                            return '${' + key + '}';
                        });
                        return interpolated;
                    }
                    /**
                     * Init form
                     *
                     * @private
                     */


                    function initForm() {
                        initFocus();
                        initToolTip();
                        setDisabled();
                        var $form = $root.find('form');

                        if ($form.length !== 0) {
                            $form.attr('id', config.formId);
                        } // Check if GUIDE API is Available


                        if (!guideBridge) {
                            console.error('Guide API is not available to carry out form submit actions');
                            return;
                        }

                        guideBridge.on('validationComplete', function(event, payload) {
                            if (!payload.prevText && payload.newText.length) {
                                handleValidationComplete(payload);
                            }
                        }); // SUBMIT FORM

                        $form.submit(function(event) {
                            event.preventDefault();
                            submit();
                        });
                    }
                    /**
                     * Set Disabled state for readonly input elements
                     *
                     * @private
                     */


                    function setDisabled() {
                        $root.find('input[readonly="readOnly"], textarea[readonly="readOnly"]').each(function() {
                            this.disabled = true;
                        });
                    }
                    /**
                     * Set ADA compliant Focus ring to Radio and Checkbox elements
                     *
                     * @private
                     */


                    function initFocus() {
                        var $checkboxRadioElements = $root.find('.guideCheckBoxItem input, .guideRadioButtonItem input, .guide-tnc-checkboxwidget input');
                        $($checkboxRadioElements).blur(function(e) {
                            $root.find('.is-focused').removeClass('is-focused');
                        });
                        $($checkboxRadioElements).focus(function(e) {
                            $(this).parent().parent().find('.guideWidgetLabel').addClass('is-focused');
                        });
                    }
                    /**
                     * Add a 1DX styling to the current tooltip component
                     * Handle close and click events of the tooltip
                     *
                     * @private
                     */


                    function initToolTip() {
                        var $questionMark = $root.find('.guideHelpQuestionMark');
                        var $tipPanels = $root.find('.guideFieldDescription.long');
                        $questionMark.each(function() {
                            var $tipPanel = $(this).parent().find('.guideFieldDescription.long'); // append CLOSE icon

                            $tipPanel.prepend('<div tabindex="0" class="guideFieldDescriptionClose">' + '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="19" height="19" viewBox="0 0 19 19">' + '<g fill="none"><g style="stroke-width:1;stroke:#444">' + '<path d="M1.7 1.8L15.5 15.5"></path><path d="M15.5 1.8L1.7 15.5"></path>' + '</g></g>' + '</svg></div>'); // close on Escape

                            $(this).on('keydown', function(event) {
                                if (event.keyCode === 32) {
                                    $tipPanel.hide();
                                }
                            });
                        });
                        $questionMark.on('click', function() {
                            var $tipPanel = $(this).parent().find('.guideFieldDescription.long');

                            if (!$tipPanel.hasClass('open')) {
                                $tipPanels.hide();
                                $tipPanel.addClass('open');
                            } else {
                                $tipPanel.removeClass('open');
                            }
                        });
                        $root.find('.guideFieldDescriptionClose').on('click', function() {
                            var $panel = $(this).parent();
                            $panel.removeClass('open').hide();
                        });
                        $root.find('.guideFieldDescriptionClose').on('focus', function() {
                            $(this).on('keydown', function(event) {
                                if (event.keyCode === 32 || event.keyCode === 13) {
                                    event.preventDefault();
                                    $(this).parent().removeClass('open').hide();
                                }
                            });
                        });
                    }
                    /**
                     * Redirect to Thankyou or failure page
                     *
                     * @private
                     * @param {string} option thankyou or failure option
                     * @param {string} pageUrl thankyou or or failure page url
                     */


                    function redirect(option, pageUrl) {
                        if (option === 'page' && pageUrl) {
                            window.location.assign(pageUrl);
                        }
                    }
                    /**
                     * Submit form
                     *
                     * @private
                     */


                    function submit() {
                        var HIDDEN = 'fxg-hidden';
                        var $form = $root.find('form');
                        var $successText = $root.find('.js-forms-success-text');
                        var $errorText = $root.find('.js-forms-error-text');
                        var $defaultLoaderText = $root.find('#loadingPage'); // Hide default load, success and error text elements

                        $successText.addClass(HIDDEN);
                        $errorText.addClass(HIDDEN);
                        $defaultLoaderText.addClass(HIDDEN);
                        $loader.removeClass(HIDDEN);
                        guideBridge.submit({
                            validate: true,
                            error: function error(guideResultObject) {
                                var _guideBridge$_guideVi, _guideBridge$_guideVi2;

                                $loader.addClass(HIDDEN);

                                if (config.failureConfig === 'message') {
                                    $successText.addClass(HIDDEN);
                                    $errorText.removeClass(HIDDEN);
                                } // fetch the actionype from guideBridge API


                                var actionType = ((_guideBridge$_guideVi = guideBridge._guideView) === null || _guideBridge$_guideVi === void 0 ? void 0 : (_guideBridge$_guideVi2 = _guideBridge$_guideVi._model) === null || _guideBridge$_guideVi2 === void 0 ? void 0 : _guideBridge$_guideVi2.jsonModel['actionType']) || '';
                                var message = $root.find('.js-forms-error-text').text() || ''; // GDL & DTM ERROR (Form Fail error)

                                var payload = {
                                    gdl: {
                                        category: 'error',
                                        eventName: 'error',
                                        params: {
                                            'type': 'server',
                                            'source': actionType,
                                            'message': message
                                        }
                                    },
                                    dtm: {
                                        type: 'button',
                                        event: '',
                                        analyticsText: 'form:fail:' + config.analytics,
                                        target: 'samePage'
                                    }
                                };
                                $analytics.push(payload); // redirect to failure page

                                redirect(config.failureConfig, config.failurePage);
                            },
                            success: function success(guideResult) {
                                $form.hide();
                                $loader.addClass(HIDDEN);

                                if (config.thankyouConfig === 'message') {
                                    $successText.removeClass(HIDDEN);
                                    $errorText.addClass(HIDDEN);
                                } //  GDL & DTM Submit event


                                var payload = {
                                    gdl: {
                                        category: 'form',
                                        eventName: 'submit',
                                        params: {
                                            'name': config.analytics
                                        }
                                    },
                                    dtm: {
                                        type: 'button',
                                        event: '',
                                        analyticsText: 'form:submit:' + config.analytics,
                                        target: 'samePage'
                                    }
                                };
                                $analytics.push(payload); // redirect to thank you page

                                redirect(config.thankyouConfig, config.thankyouPage);
                            }
                        }); // Focus back to top of the form

                        $('html, body').animate({
                            scrollTop: $root.offset().top - FDX.HEADER.height
                        }, 'fast');
                    } // add and return instance


                    var instance = {
                        setConfig: setConfig,
                        init: init,
                        getElement: getElement
                    }; // pass private attributes and methods to jest

                    if (typeof jest !== 'undefined') {
                        loadForm = jest.fn(loadForm);
                        handleValidationComplete = jest.fn(handleValidationComplete);
                        redirect = jest.fn(redirect);
                        submit = jest.fn(submit);

                        instance.$private = function() {
                            return {
                                loadForm: loadForm,
                                handleValidationComplete: handleValidationComplete,
                                redirect: redirect,
                                submit: submit
                            };
                        };
                    }

                    instances.push(instance);
                    return instance;
                }
                /**
                 * Create instances
                 *
                 * @public
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function createInstances() {
                    var promise = $.Deferred();
                    var initPromises = []; // find all related elements

                    $(selector).each(function() {
                        // skip already initialized elements
                        var $element = $(this);
                        if ($element.data('initialized')) return; // create instance

                        var instance = window.FDX.components.adaptiveform.create(); // set configuration

                        var $config = $('[data-config="js-adaptiveform-config"]', $element);

                        if ($config.length) {
                            instance.setConfig($.parseJSON($config.html().trim()));
                        } // initialize instance


                        var initPromise = instance.init($element);
                        initPromises.push(initPromise);
                    }); // resolve after all inits

                    $.when.apply($, initPromises).then(function() {
                        promise.resolve();
                    });
                    return promise;
                } // return component


                return {
                    create: create,
                    instances: instances,
                    createInstances: createInstances,
                    selector: selector
                };
            }();
        })(jQuery, _, FDX.services.fetch, FDX.services.analytics, FDX.services.utils);

        /***/
    })
    /******/
]);

function autoExpandAccordion(targetId) {

    if (targetId) {
        sessionStorage.removeItem('target');
        var outer = $("html").find("#" + targetId).attr("id");
        if (outer) {
            var offsetValue = $("html").find("#" + outer).parent().parent().offset().top;
            if (offsetValue) {
                $('html,body').animate({
                    scrollTop: offsetValue
                }, 2000);
                $("html").find("#" + outer).collapse("show");
            } else {
                var parentAcc = $("html").find("#" + targetId).parents('.fxg-content-box.panel-collapse.clearfix.collapse').parent();
                if (parentAcc) {
                    var parentAccDiv = parentAcc.children().find('.collapsed');
                    var parent = parentAccDiv.attr("aria-controls");
                    if (parent) {
                        $("html").find("#" + parent).collapse("show");
                        $("html").find("#" + targetId).collapse("show");

                        $('html,body').animate({
                            scrollTop: $("html").find("#" + targetId).parent().parent().offset().top
                        }, 2000);

                    }
                }

            }
        }

    }
}

$(document).ready(function() {
    $(this).find('.fxg-expandable-cols__plus_sign').hide();
    $(this).find('.fxg-expandable-cols__minus_sign').hide();
    var targetId;
    targetId = sessionStorage.getItem('target');
    autoExpandAccordion(targetId);
    sessionStorage.setItem('target', '');
    var eachValue = $('.fxg-accordion-selector.fxg-accordion-style-two').find('button');
    var purpleStyle = $(this).find('div').hasClass('fxg-accordion-purple_style');
    $.each(eachValue, function() {
        var accValue = $(this).attr('class');
        if (purpleStyle === true) {
            if (accValue !== "collapsed") {
                $(this).find('.fxg-expandable-cols__minus_sign').show();
            } else {
                $(this).find('.fxg-expandable-cols__plus_sign').show();
            }
        }
    });
    $('.fxg-accordion-selector.fxg-accordion-style-two').on("click", "button", function() {
        var accValue = $(this).attr('class');
        if (purpleStyle === true) {
            if (accValue === "collapsed") {
                $(this).find('.fxg-expandable-cols__minus_sign').show();
                $(this).find('.fxg-expandable-cols__plus_sign').hide();
            } else {
                $(this).find('.fxg-expandable-cols__minus_sign').hide();
                $(this).find('.fxg-expandable-cols__plus_sign').show();
            }
        }
    });

    var hashElement = window.location.hash;
    if (hashElement) {
        var element = document.getElementById(hashElement.slice(1));
        if (element) {
            $('html,body').animate({
                scrollTop: $(hashElement).offset().top
            }, 1000);
        }
    }
});
/**
 * GENERATED BY FMOD
 * Please do not modify this file directly.
 * Check 'ui.front-end/README.md' for the instructions.
 **/

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 0);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        module.exports = __webpack_require__(1);


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports) {

        /**
         * Accordion
         */
        (function($, _) {
            window.FDX.components.accordion = function() {
                /**
                 * @type {Object[]} list of instances
                 */
                var instances = [];
                /**
                 * @type {string} root selector
                 */

                var selector = '.fxg-accordion';
                /**
                 * Create component instance
                 *
                 * @public
                 * @return {Object} instance
                 */

                function create() {
                    /**
                     * @type {Object} configuration
                     */
                    var config = {};
                    /**
                     * @type {Object} jQuery DOM root element
                     */

                    var $root = null;
                    /**
                     * Set configuration
                     *
                     * @public
                     * @param {Object} _config - key/value pair
                     * @return {Object} instance
                     */

                    function setConfig(_config) {
                        var defaultConfig = {
                            option1: '',
                            option2: ''
                        };
                        config = $.extend({}, defaultConfig, _config);
                    }

                    ;
                    /**
                     * Render HTML
                     *
                     * @private
                     * @return {Promise<string>} A promise that resolves with rendered HTML
                     */

                    function render() {}
                    /**
                     * Initialize component instance
                     *
                     * @public
                     * @param {Object} [_$root] compnent root element (optional)
                     * @return {Promise} A promise that resolves when instance is initiated
                     */


                    function init(_$root) {
                        var promise = $.Deferred();
                        $root = _$root; // initialized

                        $root.data('initialized', true); // bind events

                        $('.fxg-accordion__button', $root).on('click', function(e) {
                            var button = this;
                            var ariaExpanded = button.getAttribute('aria-expanded') === 'true' ? 'false' : 'true';
                            button.setAttribute('aria-expanded', ariaExpanded);
                            var item = $(button).next()[0];
                            item.hidden = !item.hidden;
                        });
                        promise.resolve();
                        return promise;
                    }
                    /**
                     * Get component element
                     *
                     * @public
                     * @return {Object} jQuery DOM element
                     */


                    function getElement() {
                        return $root;
                    } // add and return instance


                    var instance = {
                        setConfig: setConfig,
                        init: init,
                        getElement: getElement
                    };
                    instances.push(instance);
                    return instance;
                }
                /**
                 * Create instances
                 *
                 * @public
                 * @return {Promise} A promise that resolves when all instances are initiated
                 */


                function createInstances() {
                    var promise = $.Deferred();
                    var initPromises = []; // find all related elements

                    $(selector).each(function() {
                        // skip already initialized elements
                        var $element = $(this);
                        if ($element.data('initialized')) return; // create instance

                        var instance = window.FDX.components.accordion.create(); // Set configuration

                        var $config = $('[data-config="js-accordion-config"]', $element);

                        if ($config.length) {
                            instance.setConfig($.parseJSON($config.html().trim()));
                        } // initialize instance


                        var initPromise = instance.init($element);
                        initPromises.push(initPromise);
                    }); // resolve after all inits

                    $.when.apply($, initPromises).then(function() {
                        promise.resolve();
                    });
                    return promise;
                } // return component


                return {
                    create: create,
                    selector: selector,
                    instances: instances,
                    createInstances: createInstances
                };
            }();
        })(window.jQuery, window._);

        /***/
    })
    /******/
]);
/* This is the FedEx.com global breakpoints javascript definitions.
 The global FDX object must already be defined

 Author: joey.dukeminier@vml.com
 Created: 2017-03-20
 */
if (!FDX) {
    var FDX = {};
}

FDX.BREAKPOINTS = {
    DesktopMediaQuery: "993",
    TabletMediaQuery: "992",
    MobileMediaQuery: "767",
    viewPortType: null,

    getDesktopMediaQuery: function() {
        return window.matchMedia("(min-width: " + FDX.BREAKPOINTS.DesktopMediaQuery + "px)");
    },

    getTabletMediaQuery: function() {
        return window.matchMedia("(max-width: " + FDX.BREAKPOINTS.TabletMediaQuery + "px)");
    },

    getMobileMediaQuery: function() {
        return window.matchMedia("(max-width: " + FDX.BREAKPOINTS.MobileMediaQuery + "px)");
    },

    getViewPort: function() {
        if ($(document).width() <= FDX.BREAKPOINTS.MobileMediaQuery) {
            FDX.BREAKPOINTS.viewPortType = "smallViewPort";
            return FDX.BREAKPOINTS.viewPortType;
        } else if (($(document).width() <= FDX.BREAKPOINTS.TabletMediaQuery) && ($(document).width() > FDX.BREAKPOINTS.MobileMediaQuery)) {
            FDX.BREAKPOINTS.viewPortType = "mediumViewPort";
            return FDX.BREAKPOINTS.viewPortType;
        } else if ($(document).width() >= FDX.BREAKPOINTS.DesktopMediaQuery) {
            FDX.BREAKPOINTS.viewPortType = "largeViewPort";
            return FDX.BREAKPOINTS.viewPortType;
        }
    }
};
/**
 * Initialize all services and components on page load
 */

(function($, loader) {
    $(function() {

        // init services
        loader.initServices();

        // init components
        loader.initComponents();

    });
})(window.jQuery, window.FDX.services.loader);