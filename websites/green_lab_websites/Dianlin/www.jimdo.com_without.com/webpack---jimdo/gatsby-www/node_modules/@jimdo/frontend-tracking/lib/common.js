// This function is meant to be used exclusively for generating session ids. Since we only need to disambiguate session
// within a single (cookie_id, website_id and user_id) AND this id is not used to access anything, we use Math.random(),
// which is not cryptographically strong, in place of Crypto.getRandomValues(). Optimizes for compatibility.
export const generateRandomString = () => {
  return new Array(5).fill(0).map(() => Math.random().toString(36).slice(-1)).join('');
}; // A SID is composed of the current timestamp and a random string, this lets us sort session by start time, making sure
// we have two distinct identifiers in case 2 sessions are started at the same time. This solution was chosen over using
// uuid v4 or something like ulid, for 2 reasons: the ids are shorter, saving traffic and it allows the lib to remain
// dependecy-free.

export const generateSid = () => {
  return Date.now().toString() + '-' + generateRandomString();
};
/**
 * Transform every char in given string that's not alphanumerical or period to underscore
 * as sort of a convention, so topic name are uniform
 */

export const cleanName = text => {
  return text.toLowerCase().replace(/[^a-z0-9\.]+/g, '_');
}; // Turns main attributes form a tracking event into a string hash, e.g. "www.page.load"

export const getTopic = (event, logToConsole) => {
  const preJoin = [event.category, event.action, event.label].filter(v => {
    return v !== undefined && v !== null;
  });
  const topic = preJoin.join('.').replace(/-/g, '_');
  const clean = preJoin.map(cleanName).join('.');

  if (logToConsole && topic != clean) {
    console.warn(`frontend-tracking: topic was normalized from '${topic}' to '${clean}'`);
  }

  return clean;
}; // TODO: remove on next major version (considered a breaking change since its exported)

export const getMessage = () => {}; // Returns browsers language as 2-char format, e.g. "en" or "de", if readable, else null.
// Gets used as a fallback for the "language" attribute in a tracking event payload, if
// given configuration doesn't provide a custom solution

export const getLanguage = () => {
  const lang = navigator.language || navigator.userLanguage;

  if (typeof lang === 'string') {
    return lang.substr(0, 2).toLowerCase();
  }

  return null;
};
/**
 * Based on this array we decide whether to fire tracking events to staging or to
 * production endpoints. If we wouldn't differentiate here, tracking events that
 * come up in development or staging envs would clutter prod endpoints.
 */

export const STAGING_HOSTS = ['localhost', 'stable-staging.com', 'jimdosite-stage.com', 'jimdo-platform.net', 'stage.jimdo.systems', 'jimdo-dev-staging.com', 'storybook', 'pv-url' // Maverick Preview URL
];