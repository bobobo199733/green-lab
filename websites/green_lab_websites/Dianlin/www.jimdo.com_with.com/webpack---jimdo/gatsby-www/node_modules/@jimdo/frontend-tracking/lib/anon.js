import { generateSid, getLanguage, getTopic, STAGING_HOSTS } from './common';
export const ANON_TRACKING_ENDPOINT_STAGE = 'https://at.stage.jimdo.systems/anon';
export const ANON_TRACKING_ENDPOINT_PROD = 'https://at.prod.jimdo.systems/anon';
export const CONTEXT_FREE_TRACKING_ENDPOINT_STAGE = 'https://at.stage.jimdo.systems/cf';
export const CONTEXT_FREE_TRACKING_ENDPOINT_PROD = 'https://at.prod.jimdo.systems/cf';
export const ANON_TRACKING_SID = generateSid();
export const CONTEXT_FREE_TRACKING_SID = generateSid();
/**
 * Tracker factory function, configure it with a session identifer obtained from `generateSid()`
 * it then returns a function that is initially configured with AnonTrackingConfig and then can be used to track to this
 * tracker
 *
 * @param sid the session identifier for the generated tracker
 * @returns - tracker function
 */

export const Tracking = sid => {
  // Monotonically increasing ticker for sent messages.
  // This allows us to detect if messages went missing or arrived out of order
  let seq = 0;
  return config => event => {
    var _config$getSeedPayloa, _config$getLanguage, _config$getLocation, _config$websiteId;

    // e.g. www.page.load
    const topic = getTopic(event, config.logToConsole || false);
    const seedPayload = (config === null || config === void 0 ? void 0 : (_config$getSeedPayloa = config.getSeedPayload) === null || _config$getSeedPayloa === void 0 ? void 0 : _config$getSeedPayloa.call(config)) ?? {};
    const message = {
      language: (config === null || config === void 0 ? void 0 : (_config$getLanguage = config.getLanguage) === null || _config$getLanguage === void 0 ? void 0 : _config$getLanguage.call(config)) ?? getLanguage(),
      location: (config === null || config === void 0 ? void 0 : (_config$getLocation = config.getLocation) === null || _config$getLocation === void 0 ? void 0 : _config$getLocation.call(config)) ?? document.location.href,
      ...seedPayload,
      ...event.payload
    };
    const data = {
      meta: JSON.stringify(message),
      topic,
      seq: seq++,
      sid,
      websiteId: config === null || config === void 0 ? void 0 : (_config$websiteId = config.websiteId) === null || _config$websiteId === void 0 ? void 0 : _config$websiteId.call(config)
    };

    if (config.logToConsole) {
      console.log(`frontend-tracking: anonymous event "${data.topic}" tracked`, message, data);
    }

    const dataJSON = JSON.stringify(data);
    /* takes into account that the consumer optionally has given a custom method
    to use instead of browsers sendBeacon. Also used for testing.
    It can also be used to implement backward compatibility using XHR if
    needed, but we don't use that afaik, we polyfill sendBeacon */

    const sendBeacon = (config === null || config === void 0 ? void 0 : config.sendBeacon) ?? navigator.sendBeacon.bind(navigator);
    sendBeacon(config.endpoint, dataJSON);
  };
};
/**
 * Provide a tracking config to get an anonymous tracking tracker.
 *
 * This tracker provides 24h sessionalization based on UA and IP address
 *
 * @remarks
 * Compared to DWH tracking the payload doesn't contain userAccountId or anonId (shd cookie),
 * because with such values we could identify a user
 *
 * Also websiteId though present, is used differently. With DWH tracking websiteId is sent in the CMS when the user is editing the website,
 * in Anon tracking it is the website being tracked.
 *
 * @param config - AnonTrackingConfig (endpoint, websiteId, ... etc.)
 * @returns - tracker function
 */

export const AnonTracking = Tracking(ANON_TRACKING_SID);
/**
 * Provide a tracking config to get a context free tracker
 *
 * This tracker does not allow sessionalization beyond a single page view.
 *
 * @remarks
 * Compared to DWH tracking the payload doesn't contain userAccountId or anonId (shd cookie),
 * because with such values we could identify a user
 *
 * Also websiteId though present, is used differently. With DWH tracking websiteId is sent in the CMS when the user is editing the website,
 * in Anon tracking it is the website being tracked.
 *
 * @param config - AnonTrackingConfig (endpoint, websiteId, ... etc.)
 * @returns - tracker function
 */

export const ContextFreeTracking = Tracking(CONTEXT_FREE_TRACKING_SID);
/**
 * Gets tracking endpoint URL by hostname for anonymous tracking
 *
 * @remarks
 * Provide a hostname to decide which endpoint to use (staging vs. prod)
 *
 * @param hostname - e.g. window.location
 * @returns - URL of tracking endpoint
 */

export function getAnonTrackingEndpoint(hostname) {
  return STAGING_HOSTS.some(val => hostname.includes(val)) ? ANON_TRACKING_ENDPOINT_STAGE : ANON_TRACKING_ENDPOINT_PROD;
}
/**
 * Gets tracking endpoint URL by hostname for Context Free tracking
 *
 * @remarks
 * Provide a hostname to decide which endpoint to use (staging vs. prod)
 *
 * @param hostname - e.g. window.location
 * @returns - URL of tracking endpoint
 */

export function getContextFreeTrackingEndpoint(hostname) {
  return STAGING_HOSTS.some(val => hostname.includes(val)) ? CONTEXT_FREE_TRACKING_ENDPOINT_STAGE : CONTEXT_FREE_TRACKING_ENDPOINT_PROD;
}